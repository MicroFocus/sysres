# sysres "System Restore" Partition backup and restore utility.
# Copyright Â© 2019-2020 Micro Focus or one of its affiliates.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/config.h.in package_partclone/config.h.in
--- package_partclone_orig/config.h.in	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/config.h.in	2019-11-12 14:03:06.493163483 -0300
@@ -7,11 +7,11 @@
 /* Define to 1 if you have the <blkid/blkid.h> header file. */
 #undef HAVE_BLKID_BLKID_H

-/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
    CoreFoundation framework. */
 #undef HAVE_CFLOCALECOPYCURRENT

-/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
    the CoreFoundation framework. */
 #undef HAVE_CFPREFERENCESCOPYAPPVALUE

@@ -22,6 +22,9 @@
    */
 #undef HAVE_DCGETTEXT

+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
 /* Define to 1 if you have the <ext2fs/ext2fs.h> header file. */
 #undef HAVE_EXT2FS_EXT2FS_H

@@ -34,7 +37,7 @@
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H

-/* Define if you have the iconv() function. */
+/* Define if you have the iconv() function and it works. */
 #undef HAVE_ICONV

 /* Define to 1 if you have the <inttypes.h> header file. */
@@ -133,6 +136,13 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H

+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
 /* Name of package */
 #undef PACKAGE

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/configure.ac package_partclone/configure.ac
--- package_partclone_orig/configure.ac	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/configure.ac	2019-11-12 13:59:47.889149882 -0300
@@ -1,11 +1,14 @@
 AC_INIT([Partclone], [0.3.12], [thomas@nchc.org.tw])
-AM_INIT_AUTOMAKE([-Wall foreign])
-AM_GNU_GETTEXT_VERSION([0.16.1])
+AC_CONFIG_MACRO_DIR([m4])
+AM_INIT_AUTOMAKE([-Wall -Werror foreign])
+AM_GNU_GETTEXT_VERSION([0.19.8])
 AM_GNU_GETTEXT([external])
 AC_PROG_CC
 AM_PROG_CC_C_O
 AM_PROG_AS
+AM_PROG_AR
 AC_PROG_INSTALL
+AC_PROG_LIBTOOL
 AC_PATH_PROG(RM, rm, rm)
 AC_PROG_LN_S

@@ -50,7 +53,7 @@ if test "x$GCC" = "xyes"; then
   esac
 fi

-dnl Check for uuid
+dnl Check for uuid
 PKG_CHECK_MODULES(UUID, uuid,,exit)
 uuidcfg=`pkg-config --cflags --libs uuid`

@@ -294,7 +297,7 @@ AM_CONDITIONAL(ENABLE_UFS, test "$enable
 if test "$enable_ufs" = "yes"; then
 #check library of some filesystems

-dnl Check for UFS
+dnl Check for UFS
 AC_CHECKING([ for UFS Library ... ])
 AC_CHECK_LIB([ufs], [ufs_disk_fillout], true,
         AC_MSG_ERROR([*** ufs depend library (libufs2) not found]))
@@ -314,7 +317,7 @@ AM_CONDITIONAL(ENABLE_VMFS, test "$enabl
 if test "$enable_vmfs" = "yes"; then
 #check library of some filesystems

-dnl Check for VMFS
+dnl Check for VMFS
 ##AC_CHECKING([ for VMFS Library and Header files ... ])
 ##AC_CHECK_HEADERS([uuid/uuid.h vmfs/vmfs.h], ,
 ##   AC_MSG_ERROR([*** VMFS(vmfs-tools) header not found]))
@@ -337,7 +340,7 @@ AM_CONDITIONAL(ENABLE_JFS, test "$enable
 if test "$enable_jfs" = "yes"; then
 #check library of some filesystems

-dnl Check for JFS
+dnl Check for JFS
 ##AC_CHECKING([ for JFS Library and Header files ... ])
 ##AC_CHECK_HEADERS([uuid/uuid.h jfs/jfs_superblock.h], ,
 ##   AC_MSG_ERROR([*** JFS(libjfs) header not found]))
@@ -435,10 +438,7 @@ AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_FILES([
 	Makefile
 	src/Makefile
-	fail-mbr/Makefile
-	po/Makefile.in
-	docs/Makefile
-	tests/Makefile
+  po/Makefile.in
 	])
 AC_OUTPUT

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/Makefile.am package_partclone/Makefile.am
--- package_partclone_orig/Makefile.am	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/Makefile.am	2019-11-12 13:59:47.890149882 -0300
@@ -1,5 +1,5 @@
-AUTOMAKE_OPTIONS = subdir-objects
-SUBDIRS= po src docs tests fail-mbr
+AUTOMAKE_OPTIONS = subdir-objects
+SUBDIRS= po src

 ACLOCAL_AMFLAGS = -I m4

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/extfsclone.c package_partclone/src/extfsclone.c
--- package_partclone_orig/src/extfsclone.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/extfsclone.c	2019-11-12 13:59:47.890149882 -0300
@@ -27,7 +27,7 @@

 #include "partclone.h"
 #include "extfsclone.h"
-#include "progress.h"
+//#include "progress.h"
 #include "fs_common.h"

 #ifndef EXT2_FLAG_64BITS
@@ -57,7 +57,7 @@ static void fs_open(char* device){
     } else
 	retval = ext2fs_open (device, flags, use_superblock, use_blocksize, unix_io_manager, &fs);

-    if (retval)
+    if (retval)
 	log_mesg(0, 1, 1, fs_opt.debug, "%s: Couldn't find valid filesystem superblock.\n", __FILE__);

     ext2fs_mark_valid(fs);
@@ -97,7 +97,7 @@ static unsigned long long get_used_block
 }

 // reference dumpe2fs
-void read_bitmap(char* device, file_system_info fs_info, unsigned long* bitmap, int pui) {
+void read_bitmap_extfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui) {
     errcode_t retval;
     unsigned long group;
     unsigned long long current_block, block;
@@ -106,8 +106,8 @@ void read_bitmap(char* device, file_syst
     int block_nbytes;
     unsigned long long blk_itr;
     int bg_flags = 0;
-    int start = 0;
-    int bit_size = 1;
+    //int start = 0;
+    //int bit_size = 1;
     int B_UN_INIT = 0;
     int ext4_gfree_mismatch = 0;

@@ -123,15 +123,17 @@ void read_bitmap(char* device, file_syst
 	block_bitmap = malloc(block_nbytes);

     /// initial image bitmap as 1 (all block are used)
-    pc_init_bitmap(bitmap, 0xFF, fs_info.totalblock);
+    pc_init_bitmap(bitmap, 0xFF, fs_info->totalblock);

     lfree = 0;
     current_block = 0;
     blk_itr = fs->super->s_first_data_block;

     /// init progress
+    /*
     progress_bar	prog;		/// progress_bar structure defined in progress.h
     progress_init(&prog, start, fs_info.totalblock, fs_info.totalblock, BITMAP, bit_size);
+    */

     /// each group
     for (group = 0; group < fs->group_desc_count; group++) {
@@ -160,28 +162,28 @@ void read_bitmap(char* device, file_syst
 		    }
 	    }
 	    /// each block in group
-	    for (block = 0; ((block < fs->super->s_blocks_per_group) && (current_block < (fs_info.totalblock-1))); block++) {
+	    for (block = 0; ((block < fs->super->s_blocks_per_group) && (current_block < (fs_info->totalblock-1))); block++) {
 		current_block = block + blk_itr;

 		if (in_use (block_bitmap, block)){
-			pc_set_bit(current_block, bitmap, fs_info.totalblock);
+			pc_set_bit(current_block, bitmap, fs_info->totalblock);
 			log_mesg(3, 0, 0, fs_opt.debug, "%s: used block %llu at group %lu\n", __FILE__, current_block, group);
 		} else {
 		    lfree++;
 		    gfree++;
-		    pc_clear_bit(current_block, bitmap, fs_info.totalblock);
+		    pc_clear_bit(current_block, bitmap, fs_info->totalblock);
 		    log_mesg(3, 0, 0, fs_opt.debug, "%s: free block %llu at group %lu init %i\n", __FILE__, current_block, group, (int)B_UN_INIT);
 		}
-
+
 		/// update progress
-		update_pui(&prog, current_block, current_block, 0);//keep update
+		//update_pui(&prog, current_block, current_block, 0);//keep update
 	    }
 	    blk_itr += fs->super->s_blocks_per_group;
 	}
 	log_mesg(2, 0, 0, fs_opt.debug, "%s: free bitmap (gfree = %lli, bg_blocks_count = %lli)at %lu group.\n", __FILE__, gfree, ext2fs_bg_free_blocks_count(fs, group), group);
 	/// check free blocks in group
 #ifdef EXTFS_1_41
-	if (gfree != fs->group_desc[group].bg_free_blocks_count){
+	if (gfree != fs->group_desc[group].bg_free_blocks_count){
 #else
 	if (gfree != ext2fs_bg_free_blocks_count(fs, group)){
 #endif
@@ -201,7 +203,7 @@ void read_bitmap(char* device, file_syst

     fs_close();
     /// update progress
-    update_pui(&prog, 1, 1, 1);//finish
+    //update_pui(&prog, 1, 1, 1);//finish
     free(block_bitmap);
 }

@@ -227,7 +229,7 @@ static int test_extfs_type(char* device)
     return device_type;
 }

-void read_super_blocks(char* device, file_system_info* fs_info)
+void read_super_block_extfs(char* device, file_system_info* fs_info)
 {
     int fs_type = 0;
     fs_type = test_extfs_type(device);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/extfsclone.h package_partclone/src/extfsclone.h
--- package_partclone_orig/src/extfsclone.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/extfsclone.h	2019-11-12 13:59:47.890149882 -0300
@@ -10,3 +10,6 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  */
+
+extern void read_super_block_extfs(char* device, file_system_info* fs_info);
+extern void read_bitmap_extfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/fatclone.c package_partclone/src/fatclone.c
--- package_partclone_orig/src/fatclone.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/fatclone.c	2019-11-12 13:59:47.891149882 -0300
@@ -24,7 +24,7 @@

 #include "partclone.h"
 #include "fatclone.h"
-#include "progress.h"
+//#include "progress.h"
 #include "fs_common.h"

 struct FatBootSector fat_sb;
@@ -34,9 +34,9 @@ int FS;
 char *fat_type = "FATXX";
 #define FAT12_THRESHOLD  4085
 #define FAT16_THRESHOLD 65525
-/* Unaligned fields must first be accessed byte-wise */
+/* Unaligned fields must first be accessed byte-wise */
 #define GET_UNALIGNED_W(f) ( (uint16_t)f[0] | ((uint16_t)f[1]<<8) )
-/* don't divide by zero */
+/* don't divide by zero */
 #define ROUND_TO_MULTIPLE(n,m) ((n) && (m) ? (n)+(m)-1-((n)-1)%(m) : 0)
 #define MSDOS_DIR_BITS 5        /* log2(sizeof(struct msdos_dir_entry)) */
 unsigned long long total_block = 0;
@@ -73,7 +73,7 @@ static void get_fat_type(){
             FS = FAT_16;
             fat_type = "FAT16";
             log_mesg(2, 0, 0, fs_opt.debug, "%s: FAT Type : FAT 16(clusters %lu)\n", __FILE__, clusters);
-	    if (clusters >= FAT16_THRESHOLD)
+	    if (clusters >= FAT16_THRESHOLD)
 		log_mesg(2, 0, 0, fs_opt.debug, "Too many clusters (%lu) for FAT16 filesystem.", clusters);

         } else {
@@ -166,7 +166,7 @@ int check_fat_status() {
     int fs_bad = 1;


-    /// fix. 1.check ret;
+    /// fix. 1.check ret;

     if (FS == FAT_16){
         /// FAT[0] contains BPB_Media code
@@ -185,7 +185,7 @@ int check_fat_status() {

         if (Fat16_Entry & 0x4000)
             log_mesg(2, 0, 0, fs_opt.debug, "%s: I/O correct!\n", __FILE__);
-        else
+        else
             return fs_error;

     } else if (FS == FAT_32) {
@@ -366,7 +366,7 @@ unsigned long long check_fat12_entry(uns
     return block;
 }

-void read_super_blocks(char* device, file_system_info* fs_info)
+void read_super_block_fat(char* device, file_system_info* fs_info)
 {
     unsigned long long total_sector = 0;
     unsigned long long bused = 0;
@@ -395,7 +395,7 @@ void read_super_blocks(char* device, fil
     log_mesg(2, 0, 0, fs_opt.debug, "%s: initial_image down\n", __FILE__);
 }

-void read_bitmap(char* device, file_system_info fs_info, unsigned long* bitmap, int pui)
+void read_bitmap_fat(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui)
 {
     unsigned long long i = 0;
     int fat_stat = 0;
@@ -403,18 +403,20 @@ void read_bitmap(char* device, file_syst
     unsigned long long cluster_count = 0;
     unsigned long long total_sector = 0;
     unsigned long long FatReservedBytes = 0;
-    int start = 0;
-    int bit_size = 1;
+//    int start = 0;
+//    int bit_size = 1;

     fs_open(device);

     total_sector = get_total_sector();
     cluster_count = get_cluster_count();
-    total_block = fs_info.totalblock;
+    total_block = fs_info->totalblock;

     /// init progress
+    /*
     progress_bar   prog;	/// progress_bar structure defined in progress.h
     progress_init(&prog, start, cluster_count, fs_info.totalblock, BITMAP, bit_size);
+    */

     /// init bitmap
     pc_init_bitmap(bitmap, 0xFF, total_sector);
@@ -450,17 +452,17 @@ void read_bitmap(char* device, file_syst
             block = check_fat32_entry(bitmap, block, &bfree, &bused, &DamagedClusters);
         } else if (FS == FAT_12){ /// FAT12
             block = check_fat12_entry(bitmap, block, &bfree, &bused, &DamagedClusters);
-        } else
+        } else
             log_mesg(2, 0, 0, fs_opt.debug, "%s: error fs\n", __FILE__);
         /// update progress
-        update_pui(&prog, i, i, 0);//keep update
+        //update_pui(&prog, i, i, 0);//keep update
     }

     log_mesg(2, 0, 0, fs_opt.debug, "%s: done\n", __FILE__);
     fs_close();

     /// update progress
-    update_pui(&prog, 1, 1, 1);//finish
+    //update_pui(&prog, 1, 1, 1);//finish
 }

 /// get_used_block - get FAT used blocks
@@ -511,7 +513,7 @@ static unsigned long long get_used_block
             block = check_fat32_entry(fat_bitmap, block, &bfree, &bused, &DamagedClusters);
         } else if (FS == FAT_12){ /// FAT12
             block = check_fat12_entry(fat_bitmap, block, &bfree, &bused, &DamagedClusters);
-        } else
+        } else
             log_mesg(2, 0, 0, fs_opt.debug, "%s: error fs\n", __FILE__);
     }

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/fatclone.h package_partclone/src/fatclone.h
--- package_partclone_orig/src/fatclone.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/fatclone.h	2019-11-12 13:59:47.891149882 -0300
@@ -106,3 +106,6 @@ unsigned long long check_fat32_entry(uns

 /// check per FAT16 entry
 unsigned long long check_fat16_entry(unsigned long* fat_bitmap, unsigned long long block, unsigned long long* bfree, unsigned long long* bused, unsigned long long* DamagedClusters);
+
+extern void read_super_block_fat(char* device, file_system_info* fs_info);
+extern void read_bitmap_fat(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/libpartclone.h package_partclone/src/libpartclone.h
--- package_partclone_orig/src/libpartclone.h	1969-12-31 21:00:00.000000000 -0300
+++ package_partclone/src/libpartclone.h	2019-11-12 13:59:47.891149882 -0300
@@ -0,0 +1,22 @@
+/*****************************************************************************
+*** (C) Copyright 2019 Micro Focus or one of its affiliates
+**
+* File: libpartclone.h
+** Desc: Compiler setup for libpartclone interfaces.
+**
+** Author: Adam Jerome  adam.jerome@microfocus.com
+**
+**
+*/
+
+#ifndef _LIBPARTCLONE_H_
+ #define _LIBPARTCLONE_H_
+
+/*----------------------------------------------------------------------------
+** Function prototypes.
+*/
+extern int LIBPARTCLONE_GetVersion();
+extern int LIBPARTCLONE_Mainentry(int pType, int fd, int argc, char **argv);
+
+
+#endif /* _LIBPARTCLONE_H_ */
Binary files package_partclone_orig/src/libpartclone_la-cache.o and package_partclone/src/libpartclone_la-cache.o differ
Binary files package_partclone_orig/src/libpartclone_la-checksum.o and package_partclone/src/libpartclone_la-checksum.o differ
Binary files package_partclone_orig/src/libpartclone_la-crc32.o and package_partclone/src/libpartclone_la-crc32.o differ
Binary files package_partclone_orig/src/libpartclone_la-extfsclone.o and package_partclone/src/libpartclone_la-extfsclone.o differ
Binary files package_partclone_orig/src/libpartclone_la-fatclone.o and package_partclone/src/libpartclone_la-fatclone.o differ
Binary files package_partclone_orig/src/libpartclone_la-init.o and package_partclone/src/libpartclone_la-init.o differ
Binary files package_partclone_orig/src/libpartclone_la-kmem.o and package_partclone/src/libpartclone_la-kmem.o differ
Binary files package_partclone_orig/src/libpartclone_la-linux.o and package_partclone/src/libpartclone_la-linux.o differ
Binary files package_partclone_orig/src/libpartclone_la-logitem.o and package_partclone/src/libpartclone_la-logitem.o differ
Binary files package_partclone_orig/src/libpartclone_la-main.o and package_partclone/src/libpartclone_la-main.o differ
Binary files package_partclone_orig/src/libpartclone_la-ntfsclone-ng.o and package_partclone/src/libpartclone_la-ntfsclone-ng.o differ
Binary files package_partclone_orig/src/libpartclone_la-partclone.o and package_partclone/src/libpartclone_la-partclone.o differ
Binary files package_partclone_orig/src/libpartclone_la-radix-tree.o and package_partclone/src/libpartclone_la-radix-tree.o differ
Binary files package_partclone_orig/src/libpartclone_la-rdwr.o and package_partclone/src/libpartclone_la-rdwr.o differ
Binary files package_partclone_orig/src/libpartclone_la-trans.o and package_partclone/src/libpartclone_la-trans.o differ
Binary files package_partclone_orig/src/libpartclone_la-util.o and package_partclone/src/libpartclone_la-util.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_alloc_btree.o and package_partclone/src/libpartclone_la-xfs_alloc_btree.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_alloc.o and package_partclone/src/libpartclone_la-xfs_alloc.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_attr_leaf.o and package_partclone/src/libpartclone_la-xfs_attr_leaf.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_attr_remote.o and package_partclone/src/libpartclone_la-xfs_attr_remote.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_bit.o and package_partclone/src/libpartclone_la-xfs_bit.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_bmap_btree.o and package_partclone/src/libpartclone_la-xfs_bmap_btree.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_bmap.o and package_partclone/src/libpartclone_la-xfs_bmap.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_btree.o and package_partclone/src/libpartclone_la-xfs_btree.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfsclone.o and package_partclone/src/libpartclone_la-xfsclone.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_da_btree.o and package_partclone/src/libpartclone_la-xfs_da_btree.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_da_format.o and package_partclone/src/libpartclone_la-xfs_da_format.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2_block.o and package_partclone/src/libpartclone_la-xfs_dir2_block.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2_data.o and package_partclone/src/libpartclone_la-xfs_dir2_data.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2_leaf.o and package_partclone/src/libpartclone_la-xfs_dir2_leaf.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2_node.o and package_partclone/src/libpartclone_la-xfs_dir2_node.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2.o and package_partclone/src/libpartclone_la-xfs_dir2.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_dir2_sf.o and package_partclone/src/libpartclone_la-xfs_dir2_sf.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_ialloc_btree.o and package_partclone/src/libpartclone_la-xfs_ialloc_btree.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_ialloc.o and package_partclone/src/libpartclone_la-xfs_ialloc.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_inode_buf.o and package_partclone/src/libpartclone_la-xfs_inode_buf.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_inode_fork.o and package_partclone/src/libpartclone_la-xfs_inode_fork.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_rtbitmap.o and package_partclone/src/libpartclone_la-xfs_rtbitmap.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_sb.o and package_partclone/src/libpartclone_la-xfs_sb.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_symlink_remote.o and package_partclone/src/libpartclone_la-xfs_symlink_remote.o differ
Binary files package_partclone_orig/src/libpartclone_la-xfs_trans_resv.o and package_partclone/src/libpartclone_la-xfs_trans_resv.o differ
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/main.c package_partclone/src/main.c
--- package_partclone_orig/src/main.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/main.c	2019-11-13 07:22:21.588484232 -0300
@@ -1,5 +1,5 @@
 /**
- * The main program of partclone
+ * The main program of partclone
  *
  * Copyright (c) 2007~ Thomas Tsai <thomas at nchc org tw>
  *
@@ -25,9 +25,10 @@
 #include <stdarg.h>
 #include <string.h>
 #include <unistd.h>
-#include <pthread.h>
+//#include <pthread.h>
 #include <assert.h>
 #include <dirent.h>
+#include <limits.h>

 // SHA1 for torrent info
 #include <openssl/sha.h>
@@ -35,16 +36,22 @@
 /**
  * progress.h - only for progress bar
  */
+/*
 #include "progress.h"

 void *thread_update_pui(void *arg);
 /// progress_bar structure defined in progress.h
 progress_bar prog;
+*/
 unsigned long long copied;
 unsigned long long block_id;
 int done;

 #include "partclone.h"
+#include "xfsclone.h"
+#include "ntfsclone-ng.h"
+#include "extfsclone.h"
+#include "fatclone.h"

 /// cmd_opt structure defined in partclone.h
 cmd_opt opt;
@@ -56,10 +63,83 @@ cmd_opt opt;
 /// cmd_opt structure defined in partclone.h
 fs_cmd_opt fs_opt;

-/**
- * main function - for clone or restore data
- */
-int main(int argc, char **argv) {
+//TODO determine defines in get_header and read_bitmap
+
+#define PART_MSDOS  1
+#define PART_VFAT   2
+#define PART_NTFS   3
+#define PART_EXT2   4
+#define PART_EXT3   5
+#define PART_EXT4   6
+#define PART_XFS    7
+
+void get_header(char* source, file_system_info *image_hdr, int p_type){
+    switch(p_type){
+
+        case PART_EXT2:
+        case PART_EXT3:
+        case PART_EXT4:
+            read_super_block_extfs(source, image_hdr);
+            break;
+        case PART_XFS:
+            read_super_block_xfs(source, image_hdr);
+            break;
+        case PART_MSDOS:
+        case PART_VFAT:
+            read_super_block_fat(source, image_hdr);
+            break;
+        case PART_NTFS:
+            read_super_block_ntfs(source, image_hdr);
+            break;
+        default:
+            break;
+    }
+
+}
+
+void read_bitmap_pclone(char *source, file_system_info *image_hdr, unsigned long *bitmap, int pui, int p_type){
+    switch(p_type){
+        case PART_EXT2:
+        case PART_EXT3:
+        case PART_EXT4:
+            read_bitmap_extfs(source, image_hdr, bitmap, pui);
+            break;
+        case PART_XFS:
+            read_bitmap_xfs(source, image_hdr, bitmap, pui);
+            break;
+        case PART_MSDOS:
+        case PART_VFAT:
+            read_bitmap_fat(source, image_hdr, bitmap, pui);
+            break;
+        case PART_NTFS:
+            read_bitmap_ntfs(source, image_hdr, bitmap, pui);
+            break;
+        default:
+            break;
+    }
+}
+
+/*----------------------------------------------------------------------------
+** Report library version.
+*/
+int LIBPARTCLONE_GetVersion(
+		char **_O_libVersionString
+		)
+	{
+	int rCode = EXIT_SUCCESS;
+
+//RESULTS:
+
+	if(_O_libVersionString)
+		*_O_libVersionString = "libpartclone " VERSION;
+
+	return(rCode);
+	}
+
+/*----------------------------------------------------------------------------
+** main function - for clone or restore data
+*/
+int LIBPARTCLONE_MainEntry(int ptype, int fd, int argc, char **argv) {
 #ifdef MEMTRACE
 	setenv("MALLOC_TRACE", "partclone_mtrace.log", 1);
 	mtrace();
@@ -70,17 +150,17 @@ int main(int argc, char **argv) {
 	int			r_size, w_size;		/// read and write size
 	unsigned		cs_size = 0;		/// checksum_size
 	int			cs_reseed = 1;
-	int			start;
-	unsigned long long      stop;		/// start, range, stop number for progress bar
+	//int			start;
+	//unsigned long long      stop;		/// start, range, stop number for progress bar
 	unsigned long *bitmap = NULL;		/// the point for bitmap data
 	int			debug = 0;		/// debug level
-	int			tui = 0;		/// text user interface
+  //int			tui = 0;		/// text user interface
 	int			pui = 0;		/// progress mode(default text)
-
-	int			flag;
-	int			pres = 0;
-	pthread_t		prog_thread;
-	void			*p_result;
+
+	//int			flag;
+	//int			pres = 0;
+	//pthread_t		prog_thread;
+	//void			*p_result;
 	struct stat st_dev;

 	static const char *const bad_sectors_warning_msg =
@@ -106,7 +186,7 @@ int main(int argc, char **argv) {

 	/**
 	 * if "-d / --debug" given
-	 * open debug file in "/var/log/partclone.log" for log message
+	 * open debug file in "/var/log/partclone.log" for log message
 	 */
 	memset(&fs_opt, 0, sizeof(fs_cmd_opt));
 	debug = opt.debug;
@@ -119,6 +199,7 @@ int main(int argc, char **argv) {
 	/**
 	 * using Text User Interface
 	 */
+    /*
 	if (opt.ncurses) {
 		pui = NCURSES;
 		log_mesg(1, 0, 0, debug, "Using Ncurses User Interface mode.\n");
@@ -131,6 +212,7 @@ int main(int argc, char **argv) {
 		pui = TEXT;
 		log_mesg(1, 0, 0, debug, "Open Ncurses User Interface Error.\n");
 	}
+    */

 	/// print partclone info
 	print_partclone_info(opt);
@@ -155,13 +237,25 @@ int main(int argc, char **argv) {
 	source = opt.source;
 	target = opt.target;
 	log_mesg(1, 0, 0, debug, "source=%s, target=%s \n", source, target);
-	dfr = open_source(source, &opt);
+    if (opt.restore && fd){
+        dfr = fd;
+    }
+    else{
+        dfr = open_source(source, &opt);
+    }
+    // set it to fd if fd != -1 and mode is restore
 	if (dfr == -1) {
 		log_mesg(0, 1, 1, debug, "Error exit\n");
 	}

 #ifndef CHKIMG
-	dfw = open_target(target, &opt);
+	//dfw = open_target(target, &opt);
+    if(opt.clone && fd){
+        dfw = fd;
+    }
+    else{
+        dfw = open_target(target, &opt);
+    }
 	if (opt.blockfile == 0) {
 	    if (dfw == -1) {
 		log_mesg(0, 1, 1, debug, "Error exit\n");
@@ -190,7 +284,7 @@ int main(int argc, char **argv) {
 		log_mesg(0, 0, 1, debug, "Reading Super Block\n");

 		/// get Super Block information from partition
-		read_super_blocks(source, &fs_info);
+        get_header(source, &fs_info, ptype);

 		if (img_opt.checksum_mode != CSM_NONE && img_opt.blocks_per_checksum == 0) {

@@ -215,7 +309,7 @@ int main(int argc, char **argv) {

 		/// read and check bitmap from partition
 		log_mesg(0, 0, 1, debug, "Calculating bitmap... Please wait... \n");
-		read_bitmap(source, fs_info, bitmap, pui);
+        read_bitmap_pclone(source, &fs_info, bitmap, pui, ptype);
 		update_used_blocks_count(&fs_info, bitmap);

 		if (opt.check) {
@@ -232,8 +326,10 @@ int main(int argc, char **argv) {
 		log_mesg(2, 0, 0, debug, "check main bitmap pointer %p\n", bitmap);
 		log_mesg(1, 0, 0, debug, "Writing super block and bitmap...\n");

-		write_image_desc(&dfw, fs_info, img_opt, &opt);
-		write_image_bitmap(&dfw, fs_info, img_opt, bitmap, &opt);
+        if (opt.blockfile == 0){
+            write_image_desc(&dfw, fs_info, img_opt, &opt);
+            write_image_bitmap(&dfw, fs_info, img_opt, bitmap, &opt);
+        }

 		log_mesg(0, 0, 1, debug, "done!\n");

@@ -288,7 +384,7 @@ int main(int argc, char **argv) {
 		log_mesg(1, 0, 1, debug, "Reading Super Block\n");

 		/// get Super Block information from partition
-		read_super_blocks(source, &fs_info);
+        get_header(source, &fs_info, ptype);

 		check_mem_size(fs_info, img_opt, opt);

@@ -303,7 +399,7 @@ int main(int argc, char **argv) {

 		/// read and check bitmap from partition
 		log_mesg(0, 0, 1, debug, "Calculating bitmap... Please wait... ");
-		read_bitmap(source, fs_info, bitmap, pui);
+		read_bitmap_pclone(source, &fs_info, bitmap, pui, ptype);

 		/// check the dest partition size.
 		if (opt.dd && opt.check) {
@@ -319,17 +415,17 @@ int main(int argc, char **argv) {

 		if (dfr != 0){
 		    fs_info.device_size = get_partition_size(&dfr);
-		    read_super_blocks(source, &fs_info);
+            get_header(source, &fs_info, ptype);
 		}else{
 		    if (stat(target, &st_dev) != -1) {
-		        if (S_ISBLK(st_dev.st_mode))
+		        if (S_ISBLK(st_dev.st_mode))
 			    fs_info.device_size = get_partition_size(&dfw);
 			else
 			    fs_info.device_size = get_free_space(target);
 		    } else {
 			fs_info.device_size = get_free_space(target);
 		    }
-		    read_super_blocks(target, &fs_info);
+            get_header(target, &fs_info, ptype);
 		}
 		img_opt.checksum_mode = opt.checksum_mode;
 		img_opt.checksum_size = get_checksum_size(opt.checksum_mode, opt.debug);
@@ -347,13 +443,13 @@ int main(int argc, char **argv) {

 		/// read and check bitmap from partition
 		log_mesg(0, 0, 1, debug, "Calculating bitmap... Please wait... ");
-		read_bitmap(source, fs_info, bitmap, pui);
+		read_bitmap_pclone(source, &fs_info, bitmap, pui, ptype);

 		/// check the dest partition size.
 		if (opt.check) {
 		    struct stat target_stat;
 		    if ((stat(opt.target, &target_stat) != -1) && (strcmp(opt.target, "-") != 0)) {
-			if (S_ISBLK(target_stat.st_mode))
+			if (S_ISBLK(target_stat.st_mode))
 			    check_size(&dfw, fs_info.device_size);
 			else {
 			    unsigned long long needed_space = 0;
@@ -370,7 +466,7 @@ int main(int argc, char **argv) {

 		log_mesg(2, 0, 0, debug, "check main bitmap pointer %p\n", bitmap);
 		log_mesg(0, 0, 1, debug, "done!\n");
-
+
 	}

 	log_mesg(1, 0, 0, debug, "print image information\n");
@@ -384,6 +480,7 @@ int main(int argc, char **argv) {
 	/**
 	 * initial progress bar
 	 */
+    /*
 	start = 0;				/// start number of progress bar
 	stop = (fs_info.usedblocks);		/// get the end of progress number, only used block
 	log_mesg(1, 0, 0, debug, "Initial Progress bar\n");
@@ -394,13 +491,16 @@ int main(int argc, char **argv) {
 		flag = IO;
 	progress_init(&prog, start, stop, fs_info.totalblock, flag, fs_info.block_size);
 	copied = 0;				/// initial number is 0
+    */

 	/**
 	 * thread to print progress
 	 */
+    /*
 	pres = pthread_create(&prog_thread, NULL, thread_update_pui, NULL);
 	if(pres)
 	    log_mesg(0, 1, 1, debug, "%s, %i, thread create error\n", __func__, __LINE__);
+    */


 	/**
@@ -575,11 +675,13 @@ int main(int argc, char **argv) {
 		unsigned long long blocks_used_fix = 0, test_block = 0;

 		// SHA1 for torrent info
+        /*
 		SHA_CTX ctx;
 		unsigned char hash[SHA_DIGEST_LENGTH + 1] = {'\0'};
 		unsigned long long sha_length = 0;
 		const unsigned long long BT_PIECE_SIZE = 16ULL * 1024 * 1024;
 		int tinfo = -1;
+        */

 		log_mesg(1, 0, 0, debug, "#\nBuffer capacity = %u, Blocks per cs = %u\n#\n", buffer_capacity, blocks_per_cs);

@@ -622,6 +724,7 @@ int main(int argc, char **argv) {
 			init_checksum(img_opt.checksum_mode, checksum, debug);

 		// init SHA1 for torrent info
+        /*
 		if (opt.blockfile == 1) {
 			char torrent_name[PATH_MAX + 1] = {'\0'};
 			sprintf(torrent_name,"%s/torrent.info", target);
@@ -629,6 +732,7 @@ int main(int argc, char **argv) {

 			SHA1_Init(&ctx);
 		}
+        */

 		block_id = 0;
 		do {
@@ -748,48 +852,51 @@ int main(int argc, char **argv) {
 				        if (opt.blockfile == 1){
 					    // SHA1 for torrent info
 					    // Not always bigger or smaller than 16MB
-
+
 					    // first we write out block_id * block_size for filename
 					    // because when calling write_block_file
 					    // we will create a new file to describe a continuous block (or buffer is full)
 					    // and never write to same file again
-					    dprintf(tinfo, "offset: %032llx\n", block_id * block_size);
-					    dprintf(tinfo, "length: %032llx\n", blocks_write * block_size);
+					    //dprintf(tinfo, "offset: %032llx\n", block_id * block_size);
+					    //dprintf(tinfo, "length: %032llx\n", blocks_write * block_size);

 					    // every BT piece is 16MiB
+                        /*
 					    unsigned long long sha_remain_length = BT_PIECE_SIZE - sha_length;
 					    unsigned long long buffer_remain_length = blocks_write * block_size;
 					    unsigned long long buffer_offset = 0;
 					    while (buffer_remain_length > 0) {
 					        sha_remain_length = BT_PIECE_SIZE - sha_length;
-						if (sha_remain_length <= 0) {
-						    // finish a piece
-						    SHA1_Final(hash, &ctx);
-						    dprintf(tinfo, "sha1: ");
-						    for (int x = 0; x < SHA_DIGEST_LENGTH; x++) {
-						        dprintf(tinfo, "%02x", hash[x]);
-						    }
-						    dprintf(tinfo, "\n");
-						    // start for next piece;
-						    SHA1_Init(&ctx);
-						    sha_length = 0;
-					            sha_remain_length = BT_PIECE_SIZE;
-						}
-						if (buffer_remain_length <= 0) {
-						    break;
-						}
-						else if (sha_remain_length > buffer_remain_length) {
-						    SHA1_Update(&ctx, write_buffer + blocks_written * block_size + buffer_offset, buffer_remain_length);
-						    sha_length += buffer_remain_length;
-						    break;
-						}
-						else {
-						    SHA1_Update(&ctx, write_buffer + blocks_written * block_size + buffer_offset, sha_remain_length);
-						    buffer_offset += sha_remain_length;
-						    buffer_remain_length -= sha_remain_length;
-						    sha_length += sha_remain_length;
-						}
+                            if (sha_remain_length <= 0) {
+                                // finish a piece
+                                SHA1_Final(hash, &ctx);
+                                dprintf(tinfo, "sha1: ");
+                                int x;
+                                for (x = 0; x < SHA_DIGEST_LENGTH; x++) {
+                                    dprintf(tinfo, "%02x", hash[x]);
+                                }
+                                dprintf(tinfo, "\n");
+                                // start for next piece;
+                                SHA1_Init(&ctx);
+                                sha_length = 0;
+                                    sha_remain_length = BT_PIECE_SIZE;
+                            }
+                            if (buffer_remain_length <= 0) {
+                                break;
+                            }
+                            else if (sha_remain_length > buffer_remain_length) {
+                                SHA1_Update(&ctx, write_buffer + blocks_written * block_size + buffer_offset, buffer_remain_length);
+                                sha_length += buffer_remain_length;
+                                break;
+                            }
+                            else {
+                                SHA1_Update(&ctx, write_buffer + blocks_written * block_size + buffer_offset, sha_remain_length);
+                                buffer_offset += sha_remain_length;
+                                buffer_remain_length -= sha_remain_length;
+                                sha_length += sha_remain_length;
+                            }
 					    }
+                        */

 					    w_size = write_block_file(target, write_buffer + blocks_written * block_size,
 						    blocks_write * block_size, (block_id*block_size), &opt);
@@ -815,14 +922,17 @@ int main(int argc, char **argv) {

 		// finish SHA1 for torrent info
 		if (opt.blockfile == 1) {
+            /*
 			if (sha_length) {
 				SHA1_Final(hash, &ctx);
 				dprintf(tinfo, "sha1: ");
-				for (int x = 0; x < SHA_DIGEST_LENGTH; x++) {
+                int x;
+				for (x = 0; x < SHA_DIGEST_LENGTH; x++) {
 					dprintf(tinfo, "%02x", hash[x]);
 				}
 				dprintf(tinfo, "\n");
 			}
+            */
 		}

 		free(write_buffer);
@@ -1066,11 +1176,13 @@ int main(int argc, char **argv) {

 	}

+    /*
 	done = 1;
 	pres = pthread_join(prog_thread, &p_result);
 	if(pres)
 	    log_mesg(0, 1, 1, debug, "%s, %i, thread join error\n", __func__, __LINE__);
 	update_pui(&prog, copied, block_id, done);
+    */
 #ifndef CHKIMG
 	sync_data(dfw, &opt);
 #endif
@@ -1083,12 +1195,17 @@ int main(int argc, char **argv) {
 		close_target(dfw);
 	/// free bitmp
 	free(bitmap);
-	close_pui(pui);
-#ifndef CHKIMG
-	fprintf(stderr, "Cloned successfully.\n");
-#else
-	printf("Checked successfully.\n");
+	//close_pui(pui);
+
+/*This causes ncurses screen garbage.  --ABJ */
+#if 0
+  #ifndef CHKIMG
+  	fprintf(stderr, "Cloned successfully\n");
+  #else
+  	printf("Checked successfully\n");
+  #endif
 #endif
+
 	if (opt.debug)
 		close_log();
 #ifdef MEMTRACE
@@ -1097,6 +1214,7 @@ int main(int argc, char **argv) {
 	return 0;      /// finish
 }

+/*
 void *thread_update_pui(void *arg) {

 	while (!done) {
@@ -1106,3 +1224,4 @@ void *thread_update_pui(void *arg) {
 	}
 	pthread_exit("exit");
 }
+*/
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/Makefile.am package_partclone/src/Makefile.am
--- package_partclone_orig/src/Makefile.am	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/Makefile.am	2019-11-12 13:59:47.893149882 -0300
@@ -1,242 +1,28 @@
-AUTOMAKE_OPTIONS = subdir-objects
-AM_CPPFLAGS = -DLOCALEDIR=\"$(localedir)\" -D_FILE_OFFSET_BITS=64
-LDADD = $(LIBINTL) -lcrypto
-sbin_PROGRAMS=partclone.info partclone.dd partclone.restore partclone.chkimg partclone.imager #partclone.imgfuse #partclone.block
-TOOLBOX = srcdir=$(top_srcdir) builddir=$(top_builddir) $(top_srcdir)/toolbox
-
-BTRFS_SOURCE=\
-btrfs/bitops.h btrfs/ctree.h btrfs/extent_io.c btrfs/inode-item.c btrfs/math.h btrfs/radix-tree.c btrfs/root-tree.c btrfs/ulist.c btrfs/volumes.c\
-btrfs/btrfsck.h btrfs/dir-item.c btrfs/extent_io.h btrfs/inode-map.c btrfs/print-tree.c btrfs/radix-tree.h btrfs/send.h btrfs/ulist.h btrfs/volumes.h\
-btrfs/btrfs-list.c btrfs/disk-io.c btrfs/extent-tree.c btrfs/ioctl.h btrfs/print-tree.h btrfs/raid6.c btrfs/send-stream.c btrfs/utils.c\
-btrfs/btrfs-list.h btrfs/disk-io.h btrfs/file-item.c btrfs/kerncompat.h btrfs/qgroup.c btrfs/rbtree.c btrfs/send-stream.h btrfs/utils.h\
-btrfs/crc32c.c btrfs/free-space-cache.c btrfs/list.h btrfs/qgroup.h btrfs/rbtree.h btrfs/send-utils.c btrfs/utils-lib.c btrfs/rbtree-utils.c\
-btrfs/crc32c.h btrfs/extent-cache.c btrfs/free-space-cache.h btrfs/list_sort.c btrfs/qgroup-verify.c btrfs/repair.c btrfs/send-utils.h\
-btrfs/uuid-tree.c btrfs/ctree.c btrfs/extent-cache.h btrfs/hash.h btrfs/list_sort.h btrfs/qgroup-verify.h btrfs/repair.h btrfs/transaction.h\
-btrfs/version.h btrfs/rbtree-utils.h btrfs/rbtree_augmented.h btrfs/internal.h btrfs/commands.h
-
-XFS_SOURCE=xfs/libxfs/cache.c xfs/libxfs/crc32.c xfs/libxfs/defer_item.c xfs/libxfs/init.c xfs/libxfs/kmem.c xfs/libxfs/list_sort.c xfs/libxfs/logitem.c xfs/libxfs/radix-tree.c xfs/libxfs/rdwr.c xfs/libxfs/trans.c xfs/libxfs/util.c xfs/libxfs/xfs_ag_resv.c xfs/libxfs/xfs_alloc.c xfs/libxfs/xfs_alloc_btree.c xfs/libxfs/xfs_attr.c xfs/libxfs/xfs_attr_leaf.c xfs/libxfs/xfs_attr_remote.c xfs/libxfs/xfs_bit.c xfs/libxfs/xfs_bmap.c xfs/libxfs/xfs_bmap_btree.c xfs/libxfs/xfs_btree.c xfs/libxfs/xfs_da_btree.c xfs/libxfs/xfs_da_format.c xfs/libxfs/xfs_defer.c xfs/libxfs/xfs_dir2.c xfs/libxfs/xfs_dir2_block.c xfs/libxfs/xfs_dir2_data.c xfs/libxfs/xfs_dir2_leaf.c xfs/libxfs/xfs_dir2_node.c xfs/libxfs/xfs_dir2_sf.c xfs/libxfs/xfs_dquot_buf.c xfs/libxfs/xfs_ialloc.c xfs/libxfs/xfs_inode_buf.c xfs/libxfs/xfs_inode_fork.c xfs/libxfs/xfs_ialloc_btree.c xfs/libxfs/xfs_log_rlimit.c xfs/libxfs/xfs_refcount.c xfs/libxfs/xfs_refcount_btree.c xfs/libxfs/xfs_rmap.c xfs/libxfs/xfs_rmap_btree.c xfs/libxfs/xfs_rtbitmap.c xfs/libxfs/xfs_sb.c xfs/libxfs/xfs_symlink_remote.c xfs/libxfs/xfs_trans_resv.c xfs/libxfs/linux.c
-
-EXFATFS_SOURCE=exfat/cluster.c exfat/utf.c exfat/utils.c exfat/lookup.c exfat/io.c exfat/log.c exfat/node.c exfat/mount.c exfat/time.c
-
-F2FS_SOURCE=f2fs/fsck.c f2fs/libf2fs.c f2fs/fsck.h f2fs/mount.c f2fs/f2fs_fs.h f2fs/list.h f2fs/f2fs.h
-
-if ENABLE_STATIC
-AM_LDFLAGS=-static
-endif
-
-if ENABLE_TINFO
-LIBS+=-ltinfo
-endif
-
-AM_CFLAGS=-D_FILE_OFFSET_BITS=64
-
-if ENABLE_MEMTRACE
-AM_CFLAGS+=-DMEMTRACE -DMEMWATCH -DMW_STDIO
-endif
-
-if ENABLE_NCURSESW
-AM_CFLAGS+=-I/usr/include/ncursesw
-endif
-
-version.h: FORCE
-	$(TOOLBOX) --update-version
-
-main_files=main.c partclone.c progress.c checksum.c partclone.h progress.h gettext.h checksum.h
-
-partclone_info_SOURCES=info.c partclone.c checksum.c partclone.h fs_common.h checksum.h
-partclone_restore_SOURCES=$(main_files) ddclone.c ddclone.h
-partclone_restore_CFLAGS=-DRESTORE -DDD
-
-partclone_chkimg_SOURCES=$(main_files) ddclone.c ddclone.h
-partclone_chkimg_CFLAGS=-DCHKIMG -DDD
-
-partclone_dd_SOURCES=$(main_files) ddclone.c ddclone.h
-partclone_dd_CFLAGS=-DDD
-
-partclone_imager_SOURCES=$(main_files) ddclone.c ddclone.h
-partclone_imager_CFLAGS=-DIMG
-
-if ENABLE_EXTFS
-sbin_PROGRAMS += partclone.extfs
-partclone_extfs_SOURCES=$(main_files) extfsclone.c extfsclone.h
-partclone_extfs_CFLAGS=-DEXTFS
-partclone_extfs_LDADD=-lext2fs -lcom_err -lpthread -lcrypto
-endif
-
-if ENABLE_REISERFS
-sbin_PROGRAMS += partclone.reiserfs
-partclone_reiserfs_SOURCES=$(main_files) reiserfsclone.c reiserfsclone.h
-partclone_reiserfs_CFLAGS=-DREISERFS
-partclone_reiserfs_LDADD=-lreiserfs -ldal -lcrypto
-endif
-
-if ENABLE_REISER4
-sbin_PROGRAMS += partclone.reiser4
-partclone_reiser4_SOURCES=$(main_files) reiser4clone.c reiser4clone.h
-partclone_reiser4_CFLAGS=-DREISER4
-partclone_reiser4_LDADD=-lreiser4 -laal -lcrypto
-endif
-
-if ENABLE_HFSP
-sbin_PROGRAMS += partclone.hfsp
-partclone_hfsp_SOURCES=$(main_files) hfsplusclone.c hfsplusclone.h
-partclone_hfsp_CFLAGS=-DHFSPLUS
-endif
-
-if ENABLE_XFS
-sbin_PROGRAMS += partclone.xfs
-partclone_xfs_SOURCES=$(main_files) xfsclone.c xfsclone.h $(XFS_SOURCE)
-partclone_xfs_CFLAGS=-Ixfs/include -Ixfs/libxfs/ -Ixfs/include/xfs/ -DXFS -D_GNU_SOURCE -DNDEBUG  $(UUID_CFLAGS)
-partclone_xfs_LDADD=-lrt -lpthread -luuid -lcrypto
-endif
-
-if ENABLE_EXFAT
-sbin_PROGRAMS += partclone.exfat
-partclone_exfat_SOURCES=$(main_files) exfatclone.c exfatclone.h $(EXFATFS_SOURCE)
-partclone_exfat_CFLAGS=-DEXFAT -D_GNU_SOURCE -std=c99
-endif
-
-if ENABLE_F2FS
-sbin_PROGRAMS += partclone.f2fs
-partclone_f2fs_SOURCES=$(main_files) f2fsclone.c f2fsclone.h $(F2FS_SOURCE)
-partclone_f2fs_CFLAGS=-DF2FS
-partclone_f2fs_LDADD=-luuid -lcrypto
-endif
-
-if ENABLE_NILFS2
-sbin_PROGRAMS += partclone.nilfs2
-partclone_nilfs2_SOURCES=$(main_files) nilfsclone.c nilfsclone.h
-partclone_nilfs2_CFLAGS=-DNILFS
-partclone_nilfs2_LDADD=-lnilfs -lcrypto
-endif
-
-if ENABLE_FAT
-sbin_PROGRAMS += partclone.fat
-partclone_fat_SOURCES=$(main_files) fatclone.c fatclone.h
-partclone_fat_CFLAGS=-DFAT
-endif
-
-sbin_PROGRAMS += partclone.ntfsfixboot
-partclone_ntfsfixboot_SOURCES=ntfsfixboot.c
-if ENABLE_NTFS
-sbin_PROGRAMS += partclone.ntfs
-partclone_ntfs_SOURCES=$(main_files) ntfsclone-ng.c ntfsclone-ng.h
-if ENABLE_NTFS_3G
-partclone_ntfs_CFLAGS=-DNTFS3G
-partclone_ntfs_LDADD=-lntfs-3g -lcrypto
-else
-partclone_ntfs_CFLAGS=-DNTFS
-partclone_ntfs_LDADD=-lntfs -lcrypto
-endif
-endif
-
-if ENABLE_UFS
-sbin_PROGRAMS += partclone.ufs
-partclone_ufs_SOURCES=$(main_files) ufsclone.c ufsclone.h
-partclone_ufs_CFLAGS=-DUFS -D_GNU_SOURCE
-partclone_ufs_LDADD=-lufs -lbsd -lcrypto
-endif
-
-if ENABLE_VMFS
-sbin_PROGRAMS += partclone.vmfs
-partclone_vmfs_SOURCES=$(main_files) vmfsclone.c vmfsclone.h
-partclone_vmfs_CFLAGS=-DVMFS -D_GNU_SOURCE $(UUID_CFLAGS)
-partclone_vmfs_LDADD=-lvmfs -luuid -lcrypto
-
-sbin_PROGRAMS += partclone.vmfs5
-partclone_vmfs5_SOURCES=$(main_files) vmfs5clone.c vmfsclone.h
-partclone_vmfs5_CFLAGS=-DVMFS -D_GNU_SOURCE $(UUID_CFLAGS)
-partclone_vmfs5_LDADD=-lvmfs -luuid -lcrypto
-
-sbin_PROGRAMS += partclone.fstype
-partclone_fstype_SOURCES=fstype.c
-partclone_fstype_CFLAGS=-DVMFS -D_GNU_SOURCE $(UUID_CFLAGS)
-partclone_fstype_LDADD=-lvmfs -luuid -lcrypto
-
-endif
-
-if ENABLE_JFS
-sbin_PROGRAMS += partclone.jfs
-#partclone_jfs_SOURCES=$(main_files) jfs_devices.c jfs_devices.h jfsclone.c jfsclone.h
-partclone_jfs_SOURCES=$(main_files) jfsclone.c jfsclone.h
-partclone_jfs_CFLAGS=-DJFS
-partclone_jfs_LDADD=-luuid -ljfs -lcrypto
-endif
-
-if ENABLE_BTRFS
-sbin_PROGRAMS += partclone.btrfs
-partclone_btrfs_SOURCES=$(main_files) btrfsclone.c btrfsclone.h $(BTRFS_SOURCE)
-partclone_btrfs_CFLAGS=-DBTRFS -DBTRFS_FLAT_INCLUDES -D_XOPEN_SOURCE=700 -D_GNU_SOURCE
-partclone_btrfs_LDADD=-luuid -lblkid -lcrypto
-endif
-
-if ENABLE_MINIX
-sbin_PROGRAMS += partclone.minix
-partclone_minix_SOURCES=$(main_files) minixclone.c minixclone.h
-partclone_minix_CFLAGS=-DMINIX
-endif
-
-if ENABLE_FUSE
-sbin_PROGRAMS+=partclone.imgfuse
-partclone_imgfuse_SOURCES=fuseimg.c partclone.c checksum.c partclone.h fs_common.h checksum.h
-partclone_imgfuse_LDADD=-lfuse -lcrypto
-if ENABLE_STATIC
-partclone_imgfuse_LDADD+=-ldl -lcrypto
-endif
-endif
-
-
-
-# Extra
-install-exec-hook:
-if ENABLE_EXTFS
-	$(LN_S) -f partclone.extfs $(DESTDIR)$(sbindir)/partclone.ext2
-	$(LN_S) -f partclone.extfs $(DESTDIR)$(sbindir)/partclone.ext3
-	$(LN_S) -f partclone.extfs $(DESTDIR)$(sbindir)/partclone.ext4
-	$(LN_S) -f partclone.extfs $(DESTDIR)$(sbindir)/partclone.ext4dev
-endif
-if ENABLE_HFSP
-	$(LN_S) -f partclone.hfsp $(DESTDIR)$(sbindir)/partclone.hfs+
-	$(LN_S) -f partclone.hfsp $(DESTDIR)$(sbindir)/partclone.hfsplus
-endif
-if ENABLE_NTFS
-	$(LN_S) -f partclone.ntfsfixboot $(DESTDIR)$(sbindir)/partclone.ntfsreloc
-endif
-if ENABLE_FAT
-	$(LN_S) -f partclone.fat $(DESTDIR)$(sbindir)/partclone.fat12
-	$(LN_S) -f partclone.fat $(DESTDIR)$(sbindir)/partclone.fat16
-	$(LN_S) -f partclone.fat $(DESTDIR)$(sbindir)/partclone.fat32
-	$(LN_S) -f partclone.fat $(DESTDIR)$(sbindir)/partclone.vfat
-endif
-if ENABLE_VMFS
-	$(LN_S) -f partclone.vmfs $(DESTDIR)$(sbindir)/partclone.VMFS_volume_member
-	$(LN_S) -f partclone.vmfs $(DESTDIR)$(sbindir)/partclone.vmfs3
-#	$(LN_S) -f partclone.vmfs $(DESTDIR)$(sbindir)/partclone.vmfs5
-endif
-
-uninstall-local:
-if ENABLE_EXTFS
-	$(RM) -f $(sbindir)/partclone.ext4dev
-	$(RM) -f $(sbindir)/partclone.ext4
-	$(RM) -f $(sbindir)/partclone.ext3
-	$(RM) -f $(sbindir)/partclone.ext2
-endif
-if ENABLE_HFSP
-	$(RM) -f $(sbindir)/partclone.hfs+
-	$(RM) -f $(sbindir)/partclone.hfsplus
-endif
-if ENABLE_FAT
-	$(RM) -f $(sbindir)/partclone.fat12
-	$(RM) -f $(sbindir)/partclone.fat16
-	$(RM) -f $(sbindir)/partclone.fat32
-	$(RM) -f $(sbindir)/partclone.vfat
-endif
-if ENABLE_NTFS
-	$(RM) -f $(sbindir)/partclone.ntfsreloc
-endif
-
-if ENABLE_VMFS
-	$(RM) -f $(sbindir)/partclone.VMFS_volume_member
-endif
+# ABJ XFS_SOURCE=xfs/libxfs/cache.c xfs/libxfs/crc32.c xfs/libxfs/defer_item.c xfs/libxfs/init.c xfs/libxfs/kmem.c xfs/libxfs/list_sort.c xfs/libxfs/logitem.c xfs/libxfs/radix-tree.c xfs/libxfs/rdwr.c xfs/libxfs/trans.c xfs/libxfs/util.c xfs/libxfs/xfs_ag_resv.c xfs/libxfs/xfs_alloc.c xfs/libxfs/xfs_alloc_btree.c xfs/libxfs/xfs_attr.c xfs/libxfs/xfs_attr_leaf.c xfs/libxfs/xfs_attr_remote.c xfs/libxfs/xfs_bit.c xfs/libxfs/xfs_bmap.c xfs/libxfs/xfs_bmap_btree.c xfs/libxfs/xfs_btree.c xfs/libxfs/xfs_da_btree.c xfs/libxfs/xfs_da_format.c xfs/libxfs/xfs_defer.c xfs/libxfs/xfs_dir2.c xfs/libxfs/xfs_dir2_block.c xfs/libxfs/xfs_dir2_data.c xfs/libxfs/xfs_dir2_leaf.c xfs/libxfs/xfs_dir2_node.c xfs/libxfs/xfs_dir2_sf.c xfs/libxfs/xfs_dquot_buf.c xfs/libxfs/xfs_ialloc.c xfs/libxfs/xfs_inode_buf.c xfs/libxfs/xfs_inode_fork.c xfs/libxfs/xfs_ialloc_btree.c xfs/libxfs/xfs_log_rlimit.c xfs/libxfs/xfs_refcount.c xfs/libxfs/xfs_refcount_btree.c xfs/libxfs/xfs_rmap.c xfs/libxfs/xfs_rmap_btree.c xfs/libxfs/xfs_rtbitmap.c xfs/libxfs/xfs_sb.c xfs/libxfs/xfs_symlink_remote.c xfs/libxfs/xfs_trans_resv.c xfs/libxfs/linux.c
+XFS_SOURCE=xfs/libxfs/rdwr.c xfs/libxfs/cache.c xfs/libxfs/init.c xfs/libxfs/radix-tree.c xfs/libxfs/trans.c xfs/libxfs/logitem.c xfs/libxfs/linux.c xfs/libxfs/xfs_inode_buf.c xfs/libxfs/xfs_sb.c xfs/libxfs/xfs_ialloc_btree.c xfs/libxfs/crc32.c xfs/libxfs/xfs_inode_fork.c xfs/libxfs/kmem.c xfs/libxfs/xfs_bmap_btree.c xfs/libxfs/xfs_bmap.c xfs/libxfs/util.c xfs/libxfs/xfs_btree.c xfs/libxfs/xfs_ialloc.c xfs/libxfs/xfs_dir2_block.c xfs/libxfs/xfs_dir2_sf.c xfs/libxfs/xfs_dir2_leaf.c xfs/libxfs/xfs_dir2_data.c xfs/libxfs/xfs_alloc_btree.c xfs/libxfs/xfs_alloc.c xfs/libxfs/xfs_dir2_node.c xfs/libxfs/xfs_da_btree.c xfs/libxfs/xfs_attr_leaf.c xfs/libxfs/xfs_bit.c xfs/libxfs/xfs_dir2.c xfs/libxfs/xfs_symlink_remote.c xfs/libxfs/xfs_da_format.c xfs/libxfs/xfs_attr_remote.c xfs/libxfs/xfs_trans_resv.c xfs/libxfs/xfs_rtbitmap.c
+
+
+
+
+lib_LTLIBRARIES = libpartclone.la
+
+libpartclone_la_SOURCES=main.c gettext.h
+libpartclone_la_SOURCES+=partclone.c partclone.h
+libpartclone_la_SOURCES+=extfsclone.c extfsclone.h
+libpartclone_la_SOURCES+=xfsclone.c xfsclone.h $(XFS_SOURCE)
+libpartclone_la_SOURCES+=fatclone.c fatclone.h
+libpartclone_la_SOURCES+=ntfsclone-ng.c ntfsclone-ng.h
+libpartclone_la_SOURCES+=checksum.c checksum.h
+
+libpartclone_la_LDFLAGS=-shared
+
+libpartclone_la_CXXFLAGS =
+libpartclone_la_CPPFLAGS = -DLOCALEDIR=\"$(localedir)\"
+
+libpartclone_la_CFLAGS=-DEXTFS -DXFS -DFAT -DNTFS3G -D_FILE_OFFSET_BITS=64 -DHAVE_TIME_H
+libpartclone_la_CFLAGS+=-Ixfs/include -Ixfs/libxfs/ -Ixfs/include/xfs/ -D_GNU_SOURCE -DNDEBUG
+
+libpartclone_la_LIBADD=-lext2fs -lcom_err -lhandle -lntfs-3g
+
+

-FORCE:
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/ntfsclone-ng.c package_partclone/src/ntfsclone-ng.c
--- package_partclone_orig/src/ntfsclone-ng.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/ntfsclone-ng.c	2019-11-12 13:59:47.893149882 -0300
@@ -30,22 +30,23 @@
 #define NTFS_MAX_CLUSTER_SIZE   65536

 #ifdef NTFS3G
-#include <ntfs-3g/device.h>
-#include <ntfs-3g/volume.h>
-#include <ntfs-3g/bitmap.h>
-#include <ntfs-3g/misc.h>
+ #include <ntfs-3g/device.h>
+ #include <ntfs-3g/volume.h>
+ #include <ntfs-3g/bitmap.h>
+ #include <ntfs-3g/misc.h>
 #else
-#include <ntfs/device.h>
-#include <ntfs/volume.h>
-#include <ntfs/bitmap.h>
-#include <ntfs/support.h>
+ #include <ntfs/device.h>
+ #include <ntfs/volume.h>
+ #include <ntfs/bitmap.h>
+ #include <ntfs/support.h>
+ #include <ntfs-3g/misc.h>
 #endif

 #include <assert.h>

 #include "partclone.h"
 #include "ntfsclone-ng.h"
-#include "progress.h"
+//#include "progress.h"
 #include "fs_common.h"

 /// define mount flag
@@ -136,7 +137,7 @@ out:
 #endif

 /// open device
-static void fs_open(char* device){
+static void fs_open_ntfs(char* device){

     int	    err;
     unsigned long long device_size, volume_size;
@@ -146,7 +147,7 @@ static void fs_open(char* device){
         err = errno;
         log_mesg(0, 1, 1, fs_opt.debug, "%s: NOT NTFS partition, ntfs mount error %i\n", __FILE__, err);
     } else {
-
+
         if(fs_opt.ignore_fschk){
             log_mesg(1, 0, 0, fs_opt.debug, "%s: Ignore filesystem check\n", __FILE__);
         }else{
@@ -177,7 +178,7 @@ static void fs_open(char* device){

         if ( ntfs->free_clusters < 0 || ntfs->free_clusters >= ntfs->nr_clusters) {
             log_mesg(0, 1, 1, fs_opt.debug, "%s: Bad number of free (%"PRId64") or total (%"PRId64") clusters!\n", __FILE__,
-                ntfs->free_clusters, ntfs->nr_clusters);
+                ntfs->free_clusters, ntfs->nr_clusters);
         }

 #else
@@ -185,7 +186,7 @@ static void fs_open(char* device){

         if ( ntfs->nr_free_clusters < 0 || ntfs->nr_free_clusters >= ntfs->nr_clusters) {
             log_mesg(0, 1, 1, fs_opt.debug, "%s: Bad number of free (%ld) or total (%"PRId64") clusters!\n", __FILE__,
-                ntfs->nr_free_clusters, ntfs->nr_clusters);
+                ntfs->nr_free_clusters, ntfs->nr_clusters);
         }

 #endif
@@ -193,7 +194,7 @@ static void fs_open(char* device){
         volume_size = ntfs->nr_clusters * ntfs->cluster_size;

         log_mesg(3, 0, 0, fs_opt.debug, "%s: Cluster size\t: %"PRIu32"\n", __FILE__, ntfs->cluster_size);
-        log_mesg(3, 0, 0, fs_opt.debug, "%s: Volume size\t: %"PRIu32" * %"PRId64" + 512 = %llu + 512 = %llu\n", __FILE__,
+        log_mesg(3, 0, 0, fs_opt.debug, "%s: Volume size\t: %"PRIu32" * %"PRId64" + 512 = %llu + 512 = %llu\n", __FILE__,
                 ntfs->cluster_size,
                 ntfs->nr_clusters,
                 volume_size,
@@ -211,7 +212,7 @@ static void fs_open(char* device){
 }

 /// close device
-static void fs_close(){
+static void fs_close_ntfs(){
     int ret = ntfs_umount(ntfs, 0);

     if (ret != 0) {
@@ -219,22 +220,22 @@ static void fs_close(){
     }
 }

-void read_bitmap(char* device, file_system_info fs_info, unsigned long* bitmap, int pui)
+void read_bitmap_ntfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui)
 {
     unsigned char	*ntfs_bitmap;
     unsigned long long	current_block, used_block, free_block, pos;
     long long int	count;
     unsigned long	bitmap_size;
-    int start = 0;
-    int bit_size = 1;
+//    int start = 0;
+//    int bit_size = 1;

-    fs_open(device);
+    fs_open_ntfs(device);
     bitmap_size = (ntfs->nr_clusters + 7) / 8;

     if (bitmap_size > ntfs->lcnbmp_na->data_size) {
         log_mesg(0, 1, 1, fs_opt.debug, "%s: calculated bitmap size (%lu) > lcnbmp_na->data_size (%"PRId64")\n", __FILE__, bitmap_size, ntfs->lcnbmp_na->data_size);
     }
-
+
     ntfs_bitmap = (unsigned char*)malloc(bitmap_size);
     //ntfs_bitmap = (unsigned char*)calloc(sizeof(unsigned char), bitmap_size);

@@ -250,8 +251,10 @@ void read_bitmap(char* device, file_syst
     count = ntfs_attr_pread(ntfs->lcnbmp_na, pos, bitmap_size, ntfs_bitmap);

     /// init progress
+    /*
     progress_bar   prog;
     progress_init(&prog, start, fs_info.totalblock, fs_info.totalblock, BITMAP, bit_size);
+    */

     if (count == -1){					    // On error and nothing has been read
 	log_mesg(0, 1, 1, fs_opt.debug, "%s: read ntfs attr error: %s\n", __FILE__, strerror(errno));
@@ -265,21 +268,21 @@ void read_bitmap(char* device, file_syst
         char bit;
         bit = ntfs_bit_get(ntfs_bitmap, current_block);
         if (bit == -1){                                     // Return -1 on error
-	    log_mesg(0, 1, 1, fs_opt.debug, "%s: check bitmap error\n", __FILE__);
+	    log_mesg(0, 1, 1, fs_opt.debug, "%s: check bitmap error\n", __FILE__);
 	}else if(bit == 1){				    // The value of the bit (0 or 1)
-            pc_set_bit(current_block, bitmap, fs_info.totalblock);
+            pc_set_bit(current_block, bitmap, fs_info->totalblock);
             used_block++;
         } else {
-            pc_clear_bit(current_block, bitmap, fs_info.totalblock);
+            pc_clear_bit(current_block, bitmap, fs_info->totalblock);
             free_block++;
         }
         /// update progress
-        update_pui(&prog, current_block, current_block, 0);
+        //update_pui(&prog, current_block, current_block, 0);

     }

     /// update progress
-    update_pui(&prog, 1, 1, 1);
+    //update_pui(&prog, 1, 1, 1);

     log_mesg(3, 0, 0, fs_opt.debug, "%s: [bitmap] Used Block\t: %llu\n", __FILE__, used_block);
     log_mesg(3, 0, 0, fs_opt.debug, "%s: [bitmap] Free Block\t: %llu\n", __FILE__, free_block);
@@ -290,19 +293,19 @@ void read_bitmap(char* device, file_syst

     free(ntfs_bitmap);
     log_mesg(3, 0, 0, fs_opt.debug, "%s: bitmap alloc free\n", __FILE__);
-    fs_close();
+    fs_close_ntfs();
     log_mesg(3, 0, 0, fs_opt.debug, "%s: fs_close done\n", __FILE__);

-    if (used_block != fs_info.usedblocks) {
+    if (used_block != fs_info->usedblocks) {
         log_mesg(0, 1, 1, fs_opt.debug, "%s: used blocks count mismatch: %llu in header, %llu from read_bitmap\n", __FILE__,
-            fs_info.usedblocks, used_block);
+            fs_info->usedblocks, used_block);
     }

 }

-void read_super_blocks(char* device, file_system_info* fs_info)
+void read_super_block_ntfs(char* device, file_system_info* fs_info)
 {
-    fs_open(device);
+    fs_open_ntfs(device);
     strncpy(fs_info->fs, ntfs_MAGIC, FS_MAGIC_SIZE);
     fs_info->block_size  = ntfs->cluster_size;
     fs_info->totalblock  = ntfs->nr_clusters;
@@ -314,7 +317,7 @@ void read_super_blocks(char* device, fil
     fs_info->usedblocks  = ntfs->nr_clusters - ntfs->nr_free_clusters;
 #endif
     fs_info->device_size = ntfs_device_size_get(ntfs->dev, 1);
-    fs_close();
+    fs_close_ntfs();

     log_mesg(3, 0, 0, fs_opt.debug, "%s: hdr - usedblocks:\t: %llu\n", __FILE__, fs_info->usedblocks);
     log_mesg(3, 0, 0, fs_opt.debug, "%s: hdr - totalblocks:\t: %llu\n", __FILE__, fs_info->totalblock);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/ntfsclone-ng.h package_partclone/src/ntfsclone-ng.h
--- package_partclone_orig/src/ntfsclone-ng.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/ntfsclone-ng.h	2019-11-12 13:59:47.894149882 -0300
@@ -10,3 +10,6 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  */
+
+extern void read_super_block_ntfs(char* device, file_system_info* fs_info);
+extern void read_bitmap_ntfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/partclone.c package_partclone/src/partclone.c
--- package_partclone_orig/src/partclone.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/partclone.c	2019-11-12 13:59:47.894149882 -0300
@@ -13,7 +13,9 @@


 #include <config.h>
-#define _GNU_SOURCE
+#ifndef _GNU_SOURCE
+  #define _GNU_SOURCE
+#endif
 #define _LARGEFILE64_SOURCE
 #include <features.h>
 #include <fcntl.h>
@@ -197,7 +199,9 @@ void print_readable_size_str(unsigned lo
  * parse_options            - get parameters from agrc, argv
  */
 void usage(void) {
-	fprintf(stderr, "%s v%s http://partclone.org\nUsage: %s [OPTIONS]\n"
+
+    char* MODULE="pclone module";
+	fprintf(stderr, "libpartclone v%s http://partclone.org\nUsage: %s [OPTIONS]\n"
 #ifdef CHKIMG
 		"    Check partclone image.\n"
 #else
@@ -257,7 +261,7 @@ void usage(void) {
 		"    -n,  --note NOTE        Display Message Note (128 words)\n"
 		"    -v,  --version          Display partclone version\n"
 		"    -h,  --help             Display this help\n"
-		, get_exec_name(), VERSION, get_exec_name(), DEFAULT_BUFFER_SIZE);
+		, VERSION, MODULE, DEFAULT_BUFFER_SIZE);
 	exit(0);
 }

@@ -804,7 +808,7 @@ void close_ncurses() {
  * debug message
  * open_log	- to open file default is /var/log/partclone.log
  * log_mesg	- write log to the file
- *		- write log and exit
+ *		- write log and exit
  *		- write to stderr...
  * close_log	- to close file /var/log/partclone.log
  */
@@ -821,6 +825,7 @@ void log_mesg(int log_level, int log_exi
 	va_list args;
 	extern cmd_opt opt;
 	char tmp_str[512];
+    log_level++;

 	if (log_level > debug && (!log_exit || opt.force))
 		return;
@@ -864,7 +869,9 @@ void log_mesg(int log_level, int log_exi
 	/// exit if lexit true
 	if ((!opt.force) && log_exit) {
 		close_ncurses();
-		fprintf(stderr, "Partclone fail, please check %s !\n", opt.logfile);
+		if (log_level <= debug){
+            fprintf(stderr, "Partclone fail, please check %s !\n", opt.logfile);
+        }
 		exit(1);
 	}
 }
@@ -1156,7 +1163,7 @@ int remove_directory(const char *path)
              continue;
           }

-          len = path_len + strlen(p->d_name) + 2;
+          len = path_len + strlen(p->d_name) + 2;
           buf = malloc(len);

           if (buf)
@@ -1276,7 +1283,7 @@ unsigned long long get_free_space(char*
 	return dest_size;
 }

-/// check free space
+/// check free space
 void check_free_space(char* path, unsigned long long size) {

 	unsigned long long dest_size;
@@ -1440,7 +1447,7 @@ void load_image_bitmap(int* ret, cmd_opt
  * open_source	- open device or image or stdin
  * open_target	- open device or image or stdout
  *
- *	the data string
+ *	the data string
  *	clone:	    read from device to image/stdout
  *	restore:    read from image/stdin to device
  *	dd:	    read from device to device !! not complete
@@ -1504,12 +1511,12 @@ int open_source(char* source, cmd_opt* o

 	if (opt->ddd) {
 	    if (stat(source, &st_dev) != -1) {
-		if (S_ISBLK(st_dev.st_mode))
+		if (S_ISBLK(st_dev.st_mode))
 		    ddd_block_device = 1;
 		else
 		    ddd_block_device = 0;
 	    }else{
-		ddd_block_device = 0;
+		ddd_block_device = 0;
 	    }
 	    log_mesg(1, 0, 0, debug, "ddd source file(0) or device(1) ? %i \n", ddd_block_device);
 	}
@@ -1556,7 +1563,7 @@ int open_target(char* target, cmd_opt* o
 	log_mesg(1, 0, 0, debug, "open target file/device %s\n", target);
 	if (opt->ddd) {
 	    if (stat(target, &st_dev) != -1) {
-		if (S_ISBLK(st_dev.st_mode))
+		if (S_ISBLK(st_dev.st_mode))
 		    ddd_block_device = 1;
 		else
 		    ddd_block_device = 0;
@@ -1666,7 +1673,7 @@ int write_block_file(char* target, char
 	char *block_filename = malloc(PATH_MAX + 1);
 	log_mesg(0, 0, 0,debug,  "offset %lld, size %lld\n", offset, count);
 	sprintf(block_filename,"%s/%032llx", target, offset);
-
+
 	if ((torrent_fd = open (block_filename, flags, S_IRUSR)) == -1) {
 	    log_mesg(0, 0, 1, debug, "%s,%s,%i: open %s error(%i)\n", __FILE__, __func__, __LINE__, block_filename, errno);
 	}
@@ -1809,7 +1816,7 @@ void print_partclone_info(cmd_opt opt) {
 	textdomain(PACKAGE);
 	log_mesg(0, 0, 1, debug, _("Partclone v%s http://partclone.org\n"), VERSION);
 	if (opt.chkimg)
-		log_mesg(0, 0, 1, debug, _("Starting to check image (%s)\n"), opt.source);
+		log_mesg(0, 0, 1, debug, _("Starting to check image (%s)\n"), opt.source);
 	else if (opt.clone) {
 		if (opt.compresscmd)
 			log_mesg(0, 0, 1, debug, _("Starting to clone device (%s) to compressed image (%s)\n"), opt.source, opt.target);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/partclone.h package_partclone/src/partclone.h
--- package_partclone_orig/src/partclone.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/partclone.h	2019-11-12 13:59:47.895149882 -0300
@@ -79,7 +79,7 @@ const char* get_exec_name();
 #undef crc32
 #endif

-char *EXECNAME;
+//char *EXECNAME;
 unsigned long long rescue_write_size;

 /**
@@ -302,6 +302,19 @@ extern const char *get_bitmap_mode_str(b
  */
 extern void read_super_blocks(char* device, file_system_info* fs_info);
 extern void read_bitmap(char* device, file_system_info fs_info, unsigned long* bitmap, int pui);
+
+// split out for different fs types
+//extern void read_super_blocks_xfs(char* device, file_system_info* fs_info);
+//extern void read_bitmap_xfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
+
+//extern void read_super_blocks_fat(char* device, file_system_info* fs_info);
+//extern void read_bitmap_fat(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
+
+//extern void read_super_blocks_ntfs(char* device, file_system_info* fs_info);
+//extern void read_bitmap_ntfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
+
+//extern void read_super_blocks_extfs(char* device, file_system_info* fs_info);
+//extern void read_bitmap_extfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
 /**
  * for open and close
  * open_source	- open device or image or stdin
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/builddefs.in package_partclone/src/xfs/include/builddefs.in
--- package_partclone_orig/src/xfs/include/builddefs.in	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/builddefs.in	2019-11-12 13:59:47.895149882 -0300
@@ -25,7 +25,7 @@ OPTIMIZER = @opt_build@
 MALLOCLIB = @malloc_lib@
 LOADERFLAGS = @LDFLAGS@
 LTLDFLAGS = @LDFLAGS@
-CFLAGS = @CFLAGS@ -D_FILE_OFFSET_BITS=64
+CFLAGS = @CFLAGS@

 LIBRT = @librt@
 LIBUUID = @libuuid@
@@ -102,20 +102,18 @@ HAVE_GETMNTINFO = @have_getmntinfo@
 HAVE_FALLOCATE = @have_fallocate@
 HAVE_FIEMAP = @have_fiemap@
 HAVE_PREADV = @have_preadv@
-HAVE_COPY_FILE_RANGE = @have_copy_file_range@
 HAVE_SYNC_FILE_RANGE = @have_sync_file_range@
 HAVE_READDIR = @have_readdir@
 HAVE_MNTENT = @have_mntent@
 HAVE_FLS = @have_fls@
 HAVE_FSETXATTR = @have_fsetxattr@
 HAVE_MREMAP = @have_mremap@
-NEED_INTERNAL_FSXATTR = @need_internal_fsxattr@

 GCCFLAGS = -funsigned-char -fno-strict-aliasing -Wall
 #	   -Wbitwise -Wno-transparent-union -Wno-old-initializer -Wno-decl

 ifeq ($(PKG_PLATFORM),linux)
-PCFLAGS = -D_GNU_SOURCE $(GCCFLAGS)
+PCFLAGS = -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 $(GCCFLAGS)
 ifeq ($(HAVE_UMODE_T),yes)
 PCFLAGS += -DHAVE_UMODE_T
 endif
@@ -149,9 +147,6 @@ endif
 ifeq ($(ENABLE_BLKID),yes)
 PCFLAGS+= -DENABLE_BLKID
 endif
-ifeq ($(NEED_INTERNAL_FSXATTR),yes)
-PCFLAGS+= -DOVERRIDE_SYSTEM_FSXATTR
-endif


 GCFLAGS = $(OPTIMIZER) $(DEBUG) \
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/buildmacros package_partclone/src/xfs/include/buildmacros
--- package_partclone_orig/src/xfs/include/buildmacros	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/buildmacros	2019-11-12 13:59:47.895149882 -0300
@@ -75,7 +75,13 @@ INSTALL_LTLIB_DEV = \
 	../$(INSTALL) -m 644 -T old_lib $(LIBNAME).lai $(PKG_LIB_DIR); \
 	../$(INSTALL) -m 644 $(LIBNAME).lai $(PKG_LIB_DIR)/$(LIBNAME).la ; \
 	../$(INSTALL) -m 755 -d $(PKG_ROOT_LIB_DIR); \
-	../$(INSTALL) -T so_base $(LIBNAME).lai $(PKG_ROOT_LIB_DIR);
+	../$(INSTALL) -T so_base $(LIBNAME).lai $(PKG_ROOT_LIB_DIR); \
+	if [ "x$(shell readlink -f $(PKG_LIB_DIR))" != \
+	     "x$(shell readlink -f $(PKG_ROOT_LIB_DIR))" ]; then \
+		../$(INSTALL) -S $(PKG_LIB_DIR)/$(LIBNAME).a $(PKG_ROOT_LIB_DIR)/$(LIBNAME).a; \
+		../$(INSTALL) -S $(PKG_LIB_DIR)/$(LIBNAME).la $(PKG_ROOT_LIB_DIR)/$(LIBNAME).la; \
+		../$(INSTALL) -S $(PKG_ROOT_LIB_DIR)/$(LIBNAME).so $(PKG_LIB_DIR)/$(LIBNAME).so; \
+	fi
 else
 INSTALL_LTLIB_DEV = $(INSTALL_LTLIB_STATIC)
 endif
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/command.h package_partclone/src/xfs/include/command.h
--- package_partclone_orig/src/xfs/include/command.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/command.h	2019-11-12 13:59:47.896149882 -0300
@@ -20,8 +20,7 @@

 #include <sys/time.h>

-#define CMD_FLAG_GLOBAL		(1<<31)	/* don't iterate "args" */
-#define CMD_FLAG_FOREIGN_OK	(1<<30)	/* command not restricted to XFS */
+#define CMD_FLAG_GLOBAL	((int)0x80000000)	/* don't iterate "args" */

 typedef int (*cfunc_t)(int argc, char **argv);
 typedef void (*helpfunc_t)(void);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/darwin.h package_partclone/src/xfs/include/darwin.h
--- package_partclone_orig/src/xfs/include/darwin.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/darwin.h	2019-11-12 13:59:47.896149882 -0300
@@ -134,13 +134,19 @@ typedef signed long long int	__s64;
 #define __uint16_t	u_int16_t
 #define __uint32_t	u_int32_t
 #define __uint64_t	u_int64_t
+#define off64_t		off_t

 typedef off_t		xfs_off_t;
 typedef u_int64_t	xfs_ino_t;
 typedef u_int32_t	xfs_dev_t;
 typedef int64_t		xfs_daddr_t;
-typedef __u32		xfs_nlink_t;

+#define stat64		stat
+#define fstat64		fstat
+#define lseek64		lseek
+#define pread64		pread
+#define pwrite64	pwrite
+#define ftruncate64	ftruncate
 #define fdatasync	fsync
 #define memalign(a,sz)	valloc(sz)

@@ -154,6 +160,7 @@ typedef __u32		xfs_nlink_t;

 #define EFSCORRUPTED	990	/* Filesystem is corrupted */
 #define EFSBADCRC	991	/* Bad CRC detected */
+#define constpp		char * const *

 #define HAVE_FID	1

@@ -216,6 +223,8 @@ static inline int timer_gettime (timer_t
 #  include <sys/param.h>
 #include <sys/ucred.h>
 #include <errno.h>
+#define statvfs64 statfs
+#define lstat64 lstat
 #define		_PATH_MOUNTED   "/etc/mtab"

 struct mntent
@@ -283,8 +292,7 @@ struct fsxattr {
 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
 	__u32		fsx_nextents;	/* nextents field value (get)	*/
 	__u32		fsx_projid;	/* project identifier (get/set) */
-	__u32		fsx_cowextsize;	/* cow extsize field value (get/set) */
-	unsigned char	fsx_pad[8];
+	unsigned char	fsx_pad[12];
 };

 /*
@@ -312,8 +320,4 @@ struct fsxattr {

 #endif

-#ifndef FS_XFLAG_COWEXTSIZE
-#define FS_XFLAG_COWEXTSIZE	0x00010000	/* CoW extent size allocator hint */
-#endif
-
 #endif	/* __XFS_DARWIN_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/freebsd.h package_partclone/src/xfs/include/freebsd.h
--- package_partclone_orig/src/xfs/include/freebsd.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/freebsd.h	2019-11-12 13:59:47.896149882 -0300
@@ -34,12 +34,26 @@
 #define __LITTLE_ENDIAN	LITTLE_ENDIAN

 /* FreeBSD file API is 64-bit aware */
+#define fstat64		fstat
+#define ftruncate64	ftruncate
+#define lseek64		lseek
+#define stat64		stat
+#define pwrite64	pwrite
+#define pread64		pread
 #define fdatasync	fsync
 #define memalign(a,sz)	valloc(sz)

+#define constpp	char * const *
+
 #define EFSCORRUPTED	990	/* Filesystem is corrupted */
 #define EFSBADCRC	991	/* Bad CRC detected */

+typedef off_t		xfs_off_t;
+typedef off_t		off64_t;
+typedef __uint64_t	xfs_ino_t;
+typedef __uint32_t	xfs_dev_t;
+typedef __int64_t	xfs_daddr_t;
+
 typedef unsigned char		__u8;
 typedef signed char		__s8;
 typedef unsigned short		__u16;
@@ -49,12 +63,6 @@ typedef signed int		__s32;
 typedef unsigned long long int	__u64;
 typedef signed long long int	__s64;

-typedef off_t		xfs_off_t;
-typedef __uint64_t	xfs_ino_t;
-typedef __uint32_t	xfs_dev_t;
-typedef __int64_t	xfs_daddr_t;
-typedef __u32		xfs_nlink_t;
-
 #define	O_LARGEFILE	0

 #define HAVE_FID	1
@@ -174,8 +182,7 @@ struct fsxattr {
 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
 	__u32		fsx_nextents;	/* nextents field value (get)	*/
 	__u32		fsx_projid;	/* project identifier (get/set) */
-	__u32		fsx_cowextsize;	/* cow extsize field value (get/set) */
-	unsigned char	fsx_pad[8];
+	unsigned char	fsx_pad[12];
 };

 /*
@@ -203,8 +210,5 @@ struct fsxattr {

 #endif

-#ifndef FS_XFLAG_COWEXTSIZE
-#define FS_XFLAG_COWEXTSIZE	0x00010000	/* CoW extent size allocator hint */
-#endif

 #endif	/* __XFS_FREEBSD_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/gnukfreebsd.h package_partclone/src/xfs/include/gnukfreebsd.h
--- package_partclone_orig/src/xfs/include/gnukfreebsd.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/gnukfreebsd.h	2019-11-12 13:59:47.897149882 -0300
@@ -33,9 +33,16 @@
 #include <paths.h>
 #include <mntent.h>

+#define constpp	char * const *
+
 #define EFSCORRUPTED	990	/* Filesystem is corrupted */
 #define EFSBADCRC	991	/* Bad CRC detected */

+typedef off_t		xfs_off_t;
+typedef __uint64_t	xfs_ino_t;
+typedef __uint32_t	xfs_dev_t;
+typedef __int64_t	xfs_daddr_t;
+
 typedef unsigned char		__u8;
 typedef signed char		__s8;
 typedef unsigned short		__u16;
@@ -45,12 +52,6 @@ typedef signed int		__s32;
 typedef unsigned long long int	__u64;
 typedef signed long long int	__s64;

-typedef off_t		xfs_off_t;
-typedef __uint64_t	xfs_ino_t;
-typedef __uint32_t	xfs_dev_t;
-typedef __int64_t	xfs_daddr_t;
-typedef __u32		xfs_nlink_t;
-
 #define HAVE_FID	1

 static __inline__ int xfsctl(const char *path, int fd, int cmd, void *p)
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/irix.h package_partclone/src/xfs/include/irix.h
--- package_partclone_orig/src/xfs/include/irix.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/irix.h	2019-11-12 13:59:47.897149882 -0300
@@ -43,6 +43,10 @@
 #define __int16_t	short
 #define __uint8_t	unsigned char
 #define __uint16_t	unsigned short
+typedef off64_t		xfs_off_t;
+typedef __int64_t	xfs_ino_t;
+typedef __int32_t	xfs_dev_t;
+typedef __int64_t	xfs_daddr_t;

 typedef unsigned char		__u8;
 typedef signed char		__s8;
@@ -53,12 +57,6 @@ typedef signed int		__s32;
 typedef unsigned long long int	__u64;
 typedef signed long long int	__s64;

-typedef off_t		xfs_off_t;
-typedef __int64_t	xfs_ino_t;
-typedef __int32_t	xfs_dev_t;
-typedef __int64_t	xfs_daddr_t;
-typedef __u32		xfs_nlink_t;
-
 #define xfs_flock64	flock64
 #define xfs_flock64_t	struct flock64

@@ -186,6 +184,8 @@ typedef struct xfs_efd_log_format_32 {
 #define inline		__inline
 #endif

+#define constpp		char * const *
+
 /*ARGSUSED*/
 static __inline__ int xfsctl(const char *path, int fd, int cmd, void *arg)
 {
@@ -427,8 +427,7 @@ struct fsxattr {
 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
 	__u32		fsx_nextents;	/* nextents field value (get)	*/
 	__u32		fsx_projid;	/* project identifier (get/set) */
-	__u32		fsx_cowextsize;	/* cow extsize field value (get/set) */
-	unsigned char	fsx_pad[8];
+	unsigned char	fsx_pad[12];
 };

 /*
@@ -456,9 +455,6 @@ struct fsxattr {

 #endif

-#ifndef FS_XFLAG_COWEXTSIZE
-#define FS_XFLAG_COWEXTSIZE	0x00010000	/* CoW extent size allocator hint */
-#endif

 /**
  * Abstraction of mountpoints.
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/kmem.h package_partclone/src/xfs/include/kmem.h
--- package_partclone_orig/src/xfs/include/kmem.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/kmem.h	2019-11-12 13:59:47.897149882 -0300
@@ -49,6 +49,6 @@ kmem_free(void *ptr) {
 	free(ptr);
 }

-extern void	*kmem_realloc(void *, size_t, int);
+extern void	*kmem_realloc(void *, size_t, size_t, int);

 #endif
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/libxfs.h package_partclone/src/xfs/include/libxfs.h
--- package_partclone_orig/src/xfs/include/libxfs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/libxfs.h	2019-11-12 13:59:47.898149882 -0300
@@ -60,7 +60,6 @@ extern uint32_t crc32c_le(uint32_t crc,
 #include "xfs_bit.h"
 #include "xfs_sb.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_da_format.h"
 #include "xfs_da_btree.h"
 #include "xfs_dir2.h"
@@ -77,10 +76,6 @@ extern uint32_t crc32c_le(uint32_t crc,
 #include "xfs_bmap.h"
 #include "xfs_trace.h"
 #include "xfs_trans.h"
-#include "xfs_rmap_btree.h"
-#include "xfs_rmap.h"
-#include "xfs_refcount_btree.h"
-#include "xfs_refcount.h"

 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
@@ -90,7 +85,7 @@ extern uint32_t crc32c_le(uint32_t crc,
 #define XFS_SUPER_MAGIC 0x58465342
 #endif

-#define xfs_isset(a,i)	((a)[(i)/(sizeof(*(a))*NBBY)] & (1ULL<<((i)%(sizeof(*(a))*NBBY))))
+#define xfs_isset(a,i)	((a)[(i)/(sizeof((a))*NBBY)] & (1<<((i)%(sizeof((a))*NBBY))))

 /*
  * Argument structure for libxfs_init().
@@ -169,7 +164,7 @@ extern unsigned int	libxfs_log2_roundup(
 extern int	libxfs_alloc_file_space (struct xfs_inode *, xfs_off_t,
 				xfs_off_t, int, int);

-extern void	libxfs_fs_repair_cmn_err(int, struct xfs_mount *, char *, ...);
+extern void 	libxfs_fs_repair_cmn_err(int, struct xfs_mount *, char *, ...);
 extern void	libxfs_fs_cmn_err(int, struct xfs_mount *, char *, ...);

 /* XXX: this is messy and needs fixing */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/linux.h package_partclone/src/xfs/include/linux.h
--- package_partclone_orig/src/xfs/include/linux.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/linux.h	2019-11-12 13:59:47.898149882 -0300
@@ -32,13 +32,7 @@
 #include <stdio.h>
 #include <asm/types.h>
 #include <mntent.h>
-#ifdef OVERRIDE_SYSTEM_FSXATTR
-# define fsxattr sys_fsxattr
-#endif
 #include <linux/fs.h> /* fsxattr defintion for new kernels */
-#ifdef OVERRIDE_SYSTEM_FSXATTR
-# undef fsxattr
-#endif

 static __inline__ int xfsctl(const char *path, int fd, int cmd, void *p)
 {
@@ -139,15 +133,20 @@ platform_discard_blocks(int fd, uint64_t
 	return 0;
 }

+#if (__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ <= 1))
+# define constpp	const char * const *
+#else
+# define constpp	char * const *
+#endif
+
 #define ENOATTR		ENODATA	/* Attribute not found */
 #define EFSCORRUPTED	EUCLEAN	/* Filesystem is corrupted */
 #define EFSBADCRC	EBADMSG	/* Bad CRC detected */

-typedef off_t		xfs_off_t;
+typedef loff_t		xfs_off_t;
 typedef __uint64_t	xfs_ino_t;
 typedef __uint32_t	xfs_dev_t;
 typedef __int64_t	xfs_daddr_t;
-typedef __u32		xfs_nlink_t;

 /**
  * Abstraction of mountpoints.
@@ -181,18 +180,15 @@ static inline void platform_mntent_close
  * are a copy of the definitions moved to linux/uapi/fs.h in the 4.5 kernel,
  * so this is purely for supporting builds against old kernel headers.
  */
-#if !defined FS_IOC_FSGETXATTR || defined OVERRIDE_SYSTEM_FSXATTR
+#ifndef FS_IOC_FSGETXATTR
 struct fsxattr {
 	__u32		fsx_xflags;	/* xflags field value (get/set) */
 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
 	__u32		fsx_nextents;	/* nextents field value (get)	*/
 	__u32		fsx_projid;	/* project identifier (get/set) */
-	__u32		fsx_cowextsize;	/* cow extsize field value (get/set) */
-	unsigned char	fsx_pad[8];
+	unsigned char	fsx_pad[12];
 };
-#endif

-#ifndef FS_IOC_FSGETXATTR
 /*
  * Flags for the fsx_xflags field
  */
@@ -218,8 +214,4 @@ struct fsxattr {

 #endif

-#ifndef FS_XFLAG_COWEXTSIZE
-#define FS_XFLAG_COWEXTSIZE	0x00010000	/* CoW extent size allocator hint */
-#endif
-
 #endif	/* __XFS_LINUX_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/list.h package_partclone/src/xfs/include/list.h
--- package_partclone_orig/src/xfs/include/list.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/list.h	2019-11-12 13:59:47.898149882 -0300
@@ -111,30 +111,30 @@ static inline int list_empty(const struc
 }

 static inline void __list_splice(struct list_head *list,
-				 struct list_head *prev,
-				 struct list_head *next)
+				 struct list_head *head)
 {
 	struct list_head *first = list->next;
 	struct list_head *last = list->prev;
+	struct list_head *at = head->next;

-	first->prev = prev;
-	prev->next = first;
+	first->prev = head;
+	head->next = first;

-	last->next = next;
-	next->prev = last;
+	last->next = at;
+	at->prev = last;
 }

 static inline void list_splice(struct list_head *list, struct list_head *head)
 {
 	if (!list_empty(list))
-		__list_splice(list, head, head->next);
+		__list_splice(list, head);
 }

 static inline void list_splice_init(struct list_head *list,
 				    struct list_head *head)
 {
 	if (!list_empty(list)) {
-		__list_splice(list, head, head->next);
+		__list_splice(list, head);
 		list_head_init(list);
 	}
 }
@@ -161,64 +161,4 @@ static inline void list_splice_init(stru
 	     &pos->member != (head); 					\
 	     pos = n, n = list_entry(n->member.next, typeof(*n), member))

-#define list_first_entry(ptr, type, member) \
-	list_entry((ptr)->next, type, member)
-
-#define container_of(ptr, type, member) ({			\
-	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-	(type *)( (char *)__mptr - offsetof(type,member) );})
-
-void list_sort(void *priv, struct list_head *head,
-	       int (*cmp)(void *priv, struct list_head *a,
-			  struct list_head *b));
-
-#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
-
-/**
- * list_splice_tail_init - join two lists and reinitialise the emptied list
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- *
- * Each of the lists is a queue.
- * The list at @list is reinitialised
- */
-static inline void list_splice_tail_init(struct list_head *list,
-					 struct list_head *head)
-{
-	if (!list_empty(list)) {
-		__list_splice(list, head->prev, head);
-		INIT_LIST_HEAD(list);
-	}
-}
-
-/**
- * list_last_entry - get the last element from a list
- * @ptr:	the list head to take the element from.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_head within the struct.
- *
- * Note, that list is expected to be not empty.
- */
-#define list_last_entry(ptr, type, member) \
-	list_entry((ptr)->prev, type, member)
-
-/**
- * list_prev_entry - get the prev element in list
- * @pos:	the type * to cursor
- * @member:	the name of the list_head within the struct.
- */
-#define list_prev_entry(pos, member) \
-	list_entry((pos)->member.prev, typeof(*(pos)), member)
-
-/**
- * list_for_each_entry_reverse - iterate backwards over list of given type.
- * @pos:	the type * to use as a loop cursor.
- * @head:	the head for your list.
- * @member:	the name of the list_head within the struct.
- */
-#define list_for_each_entry_reverse(pos, head, member)			\
-	for (pos = list_last_entry(head, typeof(*pos), member);		\
-	     &pos->member != (head); 					\
-	     pos = list_prev_entry(pos, member))
-
 #endif	/* __LIST_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/path.h package_partclone/src/xfs/include/path.h
--- package_partclone_orig/src/xfs/include/path.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/path.h	2019-11-12 13:59:47.899149883 -0300
@@ -29,7 +29,6 @@

 #define FS_MOUNT_POINT	(1<<0)
 #define FS_PROJECT_PATH	(1<<1)
-#define FS_FOREIGN	(1<<2)

 typedef struct fs_path {
 	char		*fs_name;	/* Data device for filesystem 	*/
@@ -44,7 +43,6 @@ typedef struct fs_path {
 } fs_path_t;

 extern int fs_count;		/* number of entries in fs table */
-extern int xfs_fs_count;	/* number of xfs entries in fs table */
 extern fs_path_t *fs_table;	/* array of entries in fs table  */
 extern fs_path_t *fs_path;	/* current entry in the fs table */
 extern char *mtab_file;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/linux.h package_partclone/src/xfs/include/xfs/linux.h
--- package_partclone_orig/src/xfs/include/xfs/linux.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/linux.h	2019-11-12 13:59:47.899149883 -0300
@@ -32,13 +32,7 @@
 #include <stdio.h>
 #include <asm/types.h>
 #include <mntent.h>
-#ifdef OVERRIDE_SYSTEM_FSXATTR
-# define fsxattr sys_fsxattr
-#endif
 #include <linux/fs.h> /* fsxattr defintion for new kernels */
-#ifdef OVERRIDE_SYSTEM_FSXATTR
-# undef fsxattr
-#endif

 static __inline__ int xfsctl(const char *path, int fd, int cmd, void *p)
 {
@@ -139,15 +133,20 @@ platform_discard_blocks(int fd, uint64_t
 	return 0;
 }

+#if (__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ <= 1))
+# define constpp	const char * const *
+#else
+# define constpp	char * const *
+#endif
+
 #define ENOATTR		ENODATA	/* Attribute not found */
 #define EFSCORRUPTED	EUCLEAN	/* Filesystem is corrupted */
 #define EFSBADCRC	EBADMSG	/* Bad CRC detected */

-typedef off_t		xfs_off_t;
+typedef loff_t		xfs_off_t;
 typedef __uint64_t	xfs_ino_t;
 typedef __uint32_t	xfs_dev_t;
 typedef __int64_t	xfs_daddr_t;
-typedef __u32		xfs_nlink_t;

 /**
  * Abstraction of mountpoints.
@@ -181,18 +180,15 @@ static inline void platform_mntent_close
  * are a copy of the definitions moved to linux/uapi/fs.h in the 4.5 kernel,
  * so this is purely for supporting builds against old kernel headers.
  */
-#if !defined FS_IOC_FSGETXATTR || defined OVERRIDE_SYSTEM_FSXATTR
+#ifndef FS_IOC_FSGETXATTR
 struct fsxattr {
 	__u32		fsx_xflags;	/* xflags field value (get/set) */
 	__u32		fsx_extsize;	/* extsize field value (get/set)*/
 	__u32		fsx_nextents;	/* nextents field value (get)	*/
 	__u32		fsx_projid;	/* project identifier (get/set) */
-	__u32		fsx_cowextsize;	/* cow extsize field value (get/set) */
-	unsigned char	fsx_pad[8];
+	unsigned char	fsx_pad[12];
 };
-#endif

-#ifndef FS_IOC_FSGETXATTR
 /*
  * Flags for the fsx_xflags field
  */
@@ -218,8 +214,4 @@ struct fsxattr {

 #endif

-#ifndef FS_XFLAG_COWEXTSIZE
-#define FS_XFLAG_COWEXTSIZE	0x00010000	/* CoW extent size allocator hint */
-#endif
-
 #endif	/* __XFS_LINUX_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/xfs_arch.h package_partclone/src/xfs/include/xfs/xfs_arch.h
--- package_partclone_orig/src/xfs/include/xfs/xfs_arch.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/xfs_arch.h	2019-11-12 13:59:47.899149883 -0300
@@ -278,4 +278,11 @@ static inline void put_unaligned_be64(__
 	put_unaligned_be32(val, p + 4);
 }

+/* ARM old ABI has some weird alignment/padding */
+#if defined(__arm__) && !defined(__ARM_EABI__)
+#define __arch_pack __attribute__((packed))
+#else
+#define __arch_pack
+#endif
+
 #endif	/* __XFS_ARCH_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/xfs_fs.h package_partclone/src/xfs/include/xfs/xfs_fs.h
--- package_partclone_orig/src/xfs/include/xfs/xfs_fs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/xfs_fs.h	2019-11-12 13:59:47.900149883 -0300
@@ -105,16 +105,14 @@ struct getbmapx {
 #define BMV_IF_PREALLOC		0x4	/* rtn status BMV_OF_PREALLOC if req */
 #define BMV_IF_DELALLOC		0x8	/* rtn status BMV_OF_DELALLOC if req */
 #define BMV_IF_NO_HOLES		0x10	/* Do not return holes */
-#define BMV_IF_COWFORK		0x20	/* return CoW fork rather than data */
 #define BMV_IF_VALID	\
 	(BMV_IF_ATTRFORK|BMV_IF_NO_DMAPI_READ|BMV_IF_PREALLOC|	\
-	 BMV_IF_DELALLOC|BMV_IF_NO_HOLES|BMV_IF_COWFORK)
+	 BMV_IF_DELALLOC|BMV_IF_NO_HOLES)

 /*	bmv_oflags values - returned for each non-header segment */
 #define BMV_OF_PREALLOC		0x1	/* segment = unwritten pre-allocation */
 #define BMV_OF_DELALLOC		0x2	/* segment = delayed allocation */
 #define BMV_OF_LAST		0x4	/* segment is the last in the file */
-#define BMV_OF_SHARED		0x8	/* segment shared with another file */

 /*
  * Structure for XFS_IOC_FSSETDM.
@@ -232,8 +230,6 @@ typedef struct xfs_fsop_resblks {
 #define XFS_FSOP_GEOM_FLAGS_FTYPE	0x10000	/* inode directory types */
 #define XFS_FSOP_GEOM_FLAGS_FINOBT	0x20000	/* free inode btree */
 #define XFS_FSOP_GEOM_FLAGS_SPINODES	0x40000	/* sparse inode chunks	*/
-#define XFS_FSOP_GEOM_FLAGS_RMAPBT	0x80000	/* reverse mapping btree */
-#define XFS_FSOP_GEOM_FLAGS_REFLINK	0x100000 /* files can share blocks */

 /*
  * Minimum and maximum sizes need for growth checks.
@@ -302,8 +298,7 @@ typedef struct xfs_bstat {
 #define	bs_projid	bs_projid_lo	/* (previously just bs_projid)	*/
 	__u16		bs_forkoff;	/* inode fork offset in bytes	*/
 	__u16		bs_projid_hi;	/* higher part of project id	*/
-	unsigned char	bs_pad[6];	/* pad space, unused		*/
-	__u32		bs_cowextsize;	/* cow extent size		*/
+	unsigned char	bs_pad[10];	/* pad space, unused		*/
 	__u32		bs_dmevmask;	/* DMIG event mask		*/
 	__u16		bs_dmstate;	/* DMIG state info		*/
 	__u16		bs_aextents;	/* attribute number of extents	*/
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/xfs.h package_partclone/src/xfs/include/xfs/xfs.h
--- package_partclone_orig/src/xfs/include/xfs/xfs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/xfs.h	2019-11-12 13:59:47.900149883 -0300
@@ -48,24 +48,12 @@
 #endif

 /*
- * make sure that any user of the xfs headers has a 64bit off_t type
- */
-extern int xfs_assert_largefile[sizeof(off_t)-8];
-
-/*
  * sparse kernel source annotations
  */
 #ifndef __user
 #define __user
 #endif

-/*
- * kernel struct packing shortcut
- */
-#ifndef __packed
-#define __packed __attribute__((packed))
-#endif
-
 #include <xfs/xfs_types.h>
 #include <xfs/xfs_fs.h>

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/xfs_types.h package_partclone/src/xfs/include/xfs/xfs_types.h
--- package_partclone_orig/src/xfs/include/xfs/xfs_types.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/xfs_types.h	2019-11-12 13:59:47.900149883 -0300
@@ -93,7 +93,6 @@ typedef __int64_t	xfs_sfiloff_t;	/* sign
  */
 #define	XFS_DATA_FORK	0
 #define	XFS_ATTR_FORK	1
-#define	XFS_COW_FORK	2

 /*
  * Min numbers of data/attr fork btree root pointers.
@@ -112,8 +111,8 @@ typedef enum {
 } xfs_lookup_t;

 typedef enum {
-	XFS_BTNUM_BNOi, XFS_BTNUM_CNTi, XFS_BTNUM_RMAPi, XFS_BTNUM_BMAPi,
-	XFS_BTNUM_INOi, XFS_BTNUM_FINOi, XFS_BTNUM_REFCi, XFS_BTNUM_MAX
+	XFS_BTNUM_BNOi, XFS_BTNUM_CNTi, XFS_BTNUM_BMAPi, XFS_BTNUM_INOi,
+	XFS_BTNUM_FINOi, XFS_BTNUM_MAX
 } xfs_btnum_t;

 struct xfs_name {
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs/xqm.h package_partclone/src/xfs/include/xfs/xqm.h
--- package_partclone_orig/src/xfs/include/xfs/xqm.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs/xqm.h	2019-11-12 13:59:47.901149882 -0300
@@ -32,7 +32,6 @@
 #define Q_XGETQSTAT	XQM_CMD(5)	/* get quota subsystem status */
 #define Q_XQUOTARM	XQM_CMD(6)	/* free disk space used by dquots */
 #define Q_XQUOTASYNC	XQM_CMD(7)	/* delalloc flush, updates dquots */
-#define Q_XGETQSTATV	XQM_CMD(8)	/* newer version of get quota */
 #define Q_XGETNEXTQUOTA	XQM_CMD(9)	/* get disk limits and usage */

 /*
@@ -150,35 +149,4 @@ typedef struct fs_quota_stat {
 	__u16		qs_iwarnlimit;	/* limit for num warnings */
 } fs_quota_stat_t;

-
-#ifndef FS_QSTATV_VERSION1
-#define FS_QSTATV_VERSION1	1	/* fs_quota_statv.qs_version */
-#endif
-
-/*
- * Some basic information about 'quota files' for Q_XGETQSTATV command
- */
-struct fs_qfilestatv {
-	__u64		qfs_ino;	/* inode number */
-	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
-	__u32		qfs_nextents;	/* number of extents */
-	__u32		qfs_pad;	/* pad for 8-byte alignment */
-};
-
-struct fs_quota_statv {
-	__s8			qs_version;	/* version for future changes */
-	__u8			qs_pad1;	/* pad for 16bit alignment */
-	__u16			qs_flags;	/* FS_QUOTA_.* flags */
-	__u32			qs_incoredqs;	/* number of dquots incore */
-	struct fs_qfilestatv	qs_uquota;	/* user quota information */
-	struct fs_qfilestatv	qs_gquota;	/* group quota information */
-	struct fs_qfilestatv	qs_pquota;	/* project quota information */
-	__s32			qs_btimelimit;	/* limit for blks timer */
-	__s32			qs_itimelimit;	/* limit for inodes timer */
-	__s32			qs_rtbtimelimit;/* limit for rt blks timer */
-	__u16			qs_bwarnlimit;	/* limit for num warnings */
-	__u16			qs_iwarnlimit;	/* limit for num warnings */
-	__u64			qs_pad2[8];	/* for future proofing */
-};
-
 #endif	/* __XQM_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs_arch.h package_partclone/src/xfs/include/xfs_arch.h
--- package_partclone_orig/src/xfs/include/xfs_arch.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs_arch.h	2019-11-12 13:59:47.901149882 -0300
@@ -278,4 +278,11 @@ static inline void put_unaligned_be64(__
 	put_unaligned_be32(val, p + 4);
 }

+/* ARM old ABI has some weird alignment/padding */
+#if defined(__arm__) && !defined(__ARM_EABI__)
+#define __arch_pack __attribute__((packed))
+#else
+#define __arch_pack
+#endif
+
 #endif	/* __XFS_ARCH_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs.h package_partclone/src/xfs/include/xfs.h
--- package_partclone_orig/src/xfs/include/xfs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs.h	2019-11-12 13:59:47.901149882 -0300
@@ -48,24 +48,12 @@
 #endif

 /*
- * make sure that any user of the xfs headers has a 64bit off_t type
- */
-extern int xfs_assert_largefile[sizeof(off_t)-8];
-
-/*
  * sparse kernel source annotations
  */
 #ifndef __user
 #define __user
 #endif

-/*
- * kernel struct packing shortcut
- */
-#ifndef __packed
-#define __packed __attribute__((packed))
-#endif
-
 #include <xfs/xfs_types.h>
 #include <xfs/xfs_fs.h>

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs_inode.h package_partclone/src/xfs/include/xfs_inode.h
--- package_partclone_orig/src/xfs/include/xfs_inode.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs_inode.h	2019-11-12 13:59:47.902149883 -0300
@@ -29,20 +29,8 @@ struct xfs_inode_log_item;
 struct xfs_dir_ops;

 /*
- * Inode interface. This fakes up a "VFS inode" to make the xfs_inode appear
- * similar to the kernel which now is used tohold certain parts of the on-disk
- * metadata.
+ * Inode interface
  */
-struct inode {
-	mode_t		i_mode;
-	uint32_t	i_nlink;
-	uint32_t	i_generation;
-	uint64_t	i_version;
-	struct timespec	i_atime;
-	struct timespec	i_mtime;
-	struct timespec	i_ctime;
-};
-
 typedef struct xfs_inode {
 	struct cache_node	i_node;
 	struct xfs_mount	*i_mount;	/* fs mount struct ptr */
@@ -50,39 +38,15 @@ typedef struct xfs_inode {
 	struct xfs_imap		i_imap;		/* location for xfs_imap() */
 	struct xfs_buftarg	i_dev;		/* dev for this inode */
 	struct xfs_ifork	*i_afp;		/* attribute fork pointer */
-	struct xfs_ifork	*i_cowfp;	/* copy on write extents */
 	struct xfs_ifork	i_df;		/* data fork */
 	struct xfs_trans	*i_transp;	/* ptr to owning transaction */
 	struct xfs_inode_log_item *i_itemp;	/* logging information */
 	unsigned int		i_delayed_blks;	/* count of delay alloc blks */
 	struct xfs_icdinode	i_d;		/* most of ondisk inode */
-
-	xfs_extnum_t		i_cnextents;	/* # of extents in cow fork */
-	unsigned int		i_cformat;	/* format of cow fork */
-
 	xfs_fsize_t		i_size;		/* in-memory size */
 	const struct xfs_dir_ops *d_ops;	/* directory ops vector */
-	struct inode		i_vnode;
 } xfs_inode_t;

-static inline struct inode *VFS_I(struct xfs_inode *ip)
-{
-	return &ip->i_vnode;
-}
-
-/*
- * wrappers around the mode checks to simplify code
- */
-static inline bool XFS_ISREG(struct xfs_inode *ip)
-{
-	return S_ISREG(VFS_I(ip)->i_mode);
-}
-
-static inline bool XFS_ISDIR(struct xfs_inode *ip)
-{
-	return S_ISDIR(VFS_I(ip)->i_mode);
-}
-
 /*
  * For regular files we only update the on-disk filesize when actually
  * writing data back to disk.  Until then only the copy in the VFS inode
@@ -90,22 +54,12 @@ static inline bool XFS_ISDIR(struct xfs_
  */
 static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)
 {
-	if (XFS_ISREG(ip))
+	if (S_ISREG(ip->i_d.di_mode))
 		return ip->i_size;
 	return ip->i_d.di_size;
 }
 #define XFS_IS_REALTIME_INODE(ip) ((ip)->i_d.di_flags & XFS_DIFLAG_REALTIME)

-/* inode link counts */
-static inline void set_nlink(struct inode *inode, uint32_t nlink)
-{
-	inode->i_nlink = nlink;
-}
-static inline void inc_nlink(struct inode *inode)
-{
-	inode->i_nlink++;
-}
-
 /*
  * Project quota id helpers (previously projid was 16bit only and using two
  * 16bit values to hold new 32bit projid was chosen to retain compatibility with
@@ -127,11 +81,6 @@ xfs_set_projid(struct xfs_icdinode *id,
 	id->di_projid_lo = (__uint16_t) (projid & 0xffff);
 }

-static inline bool xfs_is_reflink_inode(struct xfs_inode *ip)
-{
-	return ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK;
-}
-
 typedef struct cred {
 	uid_t	cr_uid;
 	gid_t	cr_gid;
@@ -149,7 +98,7 @@ extern int	libxfs_iflush_int (struct xfs

 /* Inode Cache Interfaces */
 extern int	libxfs_iget(struct xfs_mount *, struct xfs_trans *, xfs_ino_t,
-				uint, struct xfs_inode **);
+				uint, struct xfs_inode **, xfs_daddr_t);
 extern void	libxfs_iput(struct xfs_inode *);

 #define IRELE(ip) libxfs_iput(ip)
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs_mount.h package_partclone/src/xfs/include/xfs_mount.h
--- package_partclone_orig/src/xfs/include/xfs_mount.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs_mount.h	2019-11-12 13:59:47.902149883 -0300
@@ -64,18 +64,9 @@ typedef struct xfs_mount {
 	uint			m_bmap_dmnr[2];	/* XFS_BMAP_BLOCK_DMINRECS */
 	uint			m_inobt_mxr[2];	/* XFS_INOBT_BLOCK_MAXRECS */
 	uint			m_inobt_mnr[2];	/* XFS_INOBT_BLOCK_MINRECS */
-	uint			m_rmap_mxr[2];	/* max rmap btree records */
-	uint			m_rmap_mnr[2];	/* min rmap btree records */
-	uint			m_refc_mxr[2];	/* max refc btree records */
-	uint			m_refc_mnr[2];	/* min refc btree records */
 	uint			m_ag_maxlevels;	/* XFS_AG_MAXLEVELS */
 	uint			m_bm_maxlevels[2]; /* XFS_BM_MAXLEVELS */
 	uint			m_in_maxlevels;	/* XFS_IN_MAXLEVELS */
-	uint			m_rmap_maxlevels; /* max rmap btree levels */
-	uint			m_refc_maxlevels; /* max refc btree levels */
-	xfs_extlen_t		m_ag_prealloc_blocks; /* reserved ag blocks */
-	uint			m_alloc_set_aside; /* space we can't use */
-	uint			m_ag_max_usable; /* max space per AG */
 	struct radix_tree_root	m_perag_tree;
 	uint			m_flags;	/* global mount flags */
 	uint			m_qflags;	/* quota status flags */
@@ -115,22 +106,6 @@ typedef struct xfs_mount {
 	struct xlog		*m_log;
 } xfs_mount_t;

-/* per-AG block reservation data structures*/
-enum xfs_ag_resv_type {
-	XFS_AG_RESV_NONE = 0,
-	XFS_AG_RESV_METADATA,
-	XFS_AG_RESV_AGFL,
-};
-
-struct xfs_ag_resv {
-	/* number of blocks originally reserved here */
-	xfs_extlen_t	ar_orig_reserved;
-	/* number of blocks reserved here */
-	xfs_extlen_t	ar_reserved;
-	/* number of blocks originally asked for */
-	xfs_extlen_t	ar_asked;
-};
-
 /*
  * Per-ag incore structure, copies of information in agf and agi,
  * to improve the performance of allocation group selection.
@@ -161,31 +136,8 @@ typedef struct xfs_perag {
 	xfs_agino_t	pagl_leftrec;
 	xfs_agino_t	pagl_rightrec;
 	int		pagb_count;	/* pagb slots in use */
-
-	/* Blocks reserved for all kinds of metadata. */
-	struct xfs_ag_resv	pag_meta_resv;
-	/* Blocks reserved for just AGFL-based metadata. */
-	struct xfs_ag_resv	pag_agfl_resv;
-
-	/* reference count */
-	__uint8_t	pagf_refcount_level;
 } xfs_perag_t;

-static inline struct xfs_ag_resv *
-xfs_perag_resv(
-	struct xfs_perag	*pag,
-	enum xfs_ag_resv_type	type)
-{
-	switch (type) {
-	case XFS_AG_RESV_METADATA:
-		return &pag->pag_meta_resv;
-	case XFS_AG_RESV_AGFL:
-		return &pag->pag_agfl_resv;
-	default:
-		return NULL;
-	}
-}
-
 #define LIBXFS_MOUNT_DEBUGGER		0x0001
 #define LIBXFS_MOUNT_32BITINODES	0x0002
 #define LIBXFS_MOUNT_32BITINOOPT	0x0004
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs_trace.h package_partclone/src/xfs/include/xfs_trace.h
--- package_partclone_orig/src/xfs/include/xfs_trace.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs_trace.h	2019-11-12 13:59:47.902149883 -0300
@@ -49,10 +49,8 @@
 #define trace_xfs_log_recover_item_add_cont(a,b,c,d)	((void) 0)
 #define trace_xfs_log_recover_item_add(a,b,c,d)	((void) 0)

-#define trace_xfs_da_btree_corrupt(a,b)		((void) 0)
 #define trace_xfs_btree_corrupt(a,b)		((void) 0)
-#define trace_xfs_btree_updkeys(a,b,c)		((void) 0)
-#define trace_xfs_btree_overlapped_query_range(a,b,c)	((void) 0)
+#define trace_xfs_da_btree_corrupt(a,b)		((void) 0)

 #define trace_xfs_free_extent(a,b,c,d,e,f,g)	((void) 0)
 #define trace_xfs_agf(a,b,c,d)			((void) 0)
@@ -173,130 +171,4 @@
 #define trace_xfs_perag_get_tag(a,b,c,d) ((c) = (c))
 #define trace_xfs_perag_put(a,b,c,d)	((c) = (c))

-#define trace_xfs_defer_init(a,b)		((void) 0)
-#define trace_xfs_defer_cancel(a,b)		((void) 0)
-#define trace_xfs_defer_intake_work(a,b)	((void) 0)
-#define trace_xfs_defer_intake_cancel(a,b)	((void) 0)
-#define trace_xfs_defer_pending_commit(a,b)	((void) 0)
-#define trace_xfs_defer_pending_abort(a,b)	((void) 0)
-#define trace_xfs_defer_pending_cancel(a,b)	((void) 0)
-#define trace_xfs_defer_pending_finish(a,b)	((void) 0)
-#define trace_xfs_defer_trans_abort(a,b)	((void) 0)
-#define trace_xfs_defer_trans_roll(a,b)		((void) 0)
-#define trace_xfs_defer_trans_roll_error(a,b,c)	((void) 0)
-#define trace_xfs_defer_finish(a,b)		((void) 0)
-#define trace_xfs_defer_finish_error(a,b,c)	((void) 0)
-#define trace_xfs_defer_finish_done(a,b)	((void) 0)
-
-#define trace_xfs_bmap_free_defer(...)		((void) 0)
-#define trace_xfs_bmap_free_deferred(...)	((void) 0)
-
-#define trace_xfs_rmap_map(...)			((void) 0)
-#define trace_xfs_rmap_map_error(...)		((void) 0)
-#define trace_xfs_rmap_map_done(...)		((void) 0)
-#define trace_xfs_rmap_unmap(...)		((void) 0)
-#define trace_xfs_rmap_unmap_error(...)		((void) 0)
-#define trace_xfs_rmap_unmap_done(...)		((void) 0)
-#define trace_xfs_rmap_insert(...)		((void) 0)
-#define trace_xfs_rmap_insert_error(...)	((void) 0)
-#define trace_xfs_rmap_delete(...)		((void) 0)
-#define trace_xfs_rmap_convert(...)		((void) 0)
-#define trace_xfs_rmap_convert_state(...)	((void) 0)
-#define trace_xfs_rmap_convert_done(...)	((void) 0)
-#define trace_xfs_rmap_convert_error(...)	((void) 0)
-#define trace_xfs_rmap_update(...)		((void) 0)
-#define trace_xfs_rmap_update_error(...)	((void) 0)
-#define trace_xfs_rmap_defer(...)		((void) 0)
-#define trace_xfs_rmap_deferred(...)		((void) 0)
-#define trace_xfs_rmap_find_right_neighbor_result(...)	((void) 0)
-#define trace_xfs_rmap_find_left_neighbor_result(...)	((void) 0)
-#define trace_xfs_rmap_lookup_le_range_result(...)	((void) 0)
-
-#define trace_xfs_rmapbt_free_block(...)	((void) 0)
-#define trace_xfs_rmapbt_alloc_block(...)	((void) 0)
-
-#define trace_xfs_ag_resv_critical(...)		((void) 0)
-#define trace_xfs_ag_resv_needed(...)		((void) 0)
-#define trace_xfs_ag_resv_free(...)		((void) 0)
-#define trace_xfs_ag_resv_free_error(...)	((void) 0)
-#define trace_xfs_ag_resv_init(...)		((void) 0)
-#define trace_xfs_ag_resv_init_error(...)	((void) 0)
-#define trace_xfs_ag_resv_alloc_extent(...)	((void) 0)
-#define trace_xfs_ag_resv_free_extent(...)	((void) 0)
-
-#define trace_xfs_refcount_lookup(...)		((void) 0)
-#define trace_xfs_refcount_get(...)		((void) 0)
-#define trace_xfs_refcount_update(...)		((void) 0)
-#define trace_xfs_refcount_update_error(...)	((void) 0)
-#define trace_xfs_refcount_insert(...)		((void) 0)
-#define trace_xfs_refcount_insert_error(...)	((void) 0)
-#define trace_xfs_refcount_delete(...)		((void) 0)
-#define trace_xfs_refcount_delete_error(...)	((void) 0)
-#define trace_xfs_refcountbt_free_block(...)	((void) 0)
-#define trace_xfs_refcountbt_alloc_block(...)	((void) 0)
-#define trace_xfs_refcount_rec_order_error(...)	((void) 0)
-
-#define trace_xfs_refcount_lookup(...)		((void) 0)
-#define trace_xfs_refcount_get(...)		((void) 0)
-#define trace_xfs_refcount_update(...)		((void) 0)
-#define trace_xfs_refcount_update_error(...)	((void) 0)
-#define trace_xfs_refcount_insert(...)		((void) 0)
-#define trace_xfs_refcount_insert_error(...)	((void) 0)
-#define trace_xfs_refcount_delete(...)		((void) 0)
-#define trace_xfs_refcount_delete_error(...)	((void) 0)
-#define trace_xfs_refcountbt_free_block(...)	((void) 0)
-#define trace_xfs_refcountbt_alloc_block(...)	((void) 0)
-#define trace_xfs_refcount_rec_order_error(...)	((void) 0)
-#define trace_xfs_refcount_split_extent(...)	((void) 0)
-#define trace_xfs_refcount_split_extent_error(...)		((void) 0)
-#define trace_xfs_refcount_merge_center_extents_error(...)	((void) 0)
-#define trace_xfs_refcount_merge_left_extent_error(...)		((void) 0)
-#define trace_xfs_refcount_merge_right_extent_error(...)	((void) 0)
-#define trace_xfs_refcount_find_left_extent(...)	((void) 0)
-#define trace_xfs_refcount_find_left_extent_error(...)	((void) 0)
-#define trace_xfs_refcount_find_right_extent(...)	((void) 0)
-#define trace_xfs_refcount_find_right_extent_error(...)	((void) 0)
-#define trace_xfs_refcount_merge_center_extents(...)	((void) 0)
-#define trace_xfs_refcount_merge_left_extent(...)	((void) 0)
-#define trace_xfs_refcount_merge_right_extent(...)	((void) 0)
-#define trace_xfs_refcount_modify_extent(...)		((void) 0)
-#define trace_xfs_refcount_modify_extent_error(...)	((void) 0)
-#define trace_xfs_refcount_adjust_error(...)		((void) 0)
-#define trace_xfs_refcount_increase(...)		((void) 0)
-#define trace_xfs_refcount_decrease(...)		((void) 0)
-#define trace_xfs_refcount_deferred(...)		((void) 0)
-#define trace_xfs_refcount_defer(...)			((void) 0)
-#define trace_xfs_refcount_finish_one_leftover(...)	((void) 0)
-#define trace_xfs_refcount_find_shared(...)		((void) 0)
-#define trace_xfs_refcount_find_shared_result(...)	((void) 0)
-#define trace_xfs_refcount_find_shared_error(...)	((void) 0)
-
-#define trace_xfs_bmap_remap_alloc(...)		((void) 0)
-#define trace_xfs_bmap_remap_alloc_error(...)	((void) 0)
-#define trace_xfs_bmap_deferred(...)		((void) 0)
-#define trace_xfs_bmap_defer(...)		((void) 0)
-
-#define trace_xfs_refcount_adjust_cow_error(...)	((void) 0)
-#define trace_xfs_refcount_cow_increase(...)	((void) 0)
-#define trace_xfs_refcount_cow_decrease(...)	((void) 0)
-#define trace_xfs_refcount_recover_extent(...)	((void) 0)
-
-#define trace_xfs_rmap_find_left_neighbor_candidate(...)	((void) 0)
-#define trace_xfs_rmap_find_left_neighbor_query(...)	((void) 0)
-#define trace_xfs_rmap_find_left_neighbor_result(...)	((void) 0)
-#define trace_xfs_rmap_lookup_le_range_candidate(...)	((void) 0)
-#define trace_xfs_rmap_lookup_le_range(...)	((void) 0)
-#define trace_xfs_rmap_unmap(...)		((void) 0)
-#define trace_xfs_rmap_unmap_done(...)		((void) 0)
-#define trace_xfs_rmap_unmap_error(...)		((void) 0)
-#define trace_xfs_rmap_map(...)			((void) 0)
-#define trace_xfs_rmap_map_done(...)		((void) 0)
-#define trace_xfs_rmap_map_error(...)		((void) 0)
-#define trace_xfs_rmap_delete_error(...)	((void) 0)
-
-/* set c = c to avoid unused var warnings */
-#define trace_xfs_perag_get(a,b,c,d)		((c) = (c))
-#define trace_xfs_perag_get_tag(a,b,c,d)	((c) = (c))
-#define trace_xfs_perag_put(a,b,c,d)		((c) = (c))
-
 #endif /* __TRACE_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xfs_trans.h package_partclone/src/xfs/include/xfs_trans.h
--- package_partclone_orig/src/xfs/include/xfs_trans.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xfs_trans.h	2019-11-12 13:59:47.903149883 -0300
@@ -74,7 +74,6 @@ typedef struct xfs_trans {
 	unsigned int	t_type;			/* transaction type */
 	unsigned int	t_log_res;		/* amt of log space resvd */
 	unsigned int	t_log_count;		/* count for perm log res */
-	unsigned int	t_blk_res;		/* # of blocks resvd */
 	struct xfs_mount *t_mountp;		/* ptr to fs mount struct */
 	unsigned int	t_flags;		/* misc flags */
 	long		t_icount_delta;		/* superblock icount change */
@@ -87,9 +86,9 @@ typedef struct xfs_trans {
 void	xfs_trans_init(struct xfs_mount *);
 int	xfs_trans_roll(struct xfs_trans **, struct xfs_inode *);

-int	libxfs_trans_alloc(struct xfs_mount *mp, struct xfs_trans_res *resp,
-			   uint blocks, uint rtextents, uint flags,
-			   struct xfs_trans **tpp);
+xfs_trans_t	*libxfs_trans_alloc(struct xfs_mount *, int);
+int	libxfs_trans_reserve(struct xfs_trans *, struct xfs_trans_res *,
+				     uint, uint);
 int	libxfs_trans_commit(struct xfs_trans *);
 void	libxfs_trans_cancel(struct xfs_trans *);
 struct xfs_buf *libxfs_trans_getsb(struct xfs_trans *, struct xfs_mount *, int);
@@ -145,9 +144,4 @@ libxfs_trans_read_buf(
 	return libxfs_trans_read_buf_map(mp, tp, btp, &map, 1, flags, bpp, ops);
 }

-void xfs_extent_free_init_defer_op(void);
-void xfs_rmap_update_init_defer_op(void);
-void xfs_refcount_update_init_defer_op(void);
-void xfs_bmap_update_init_defer_op(void);
-
 #endif	/* __XFS_TRANS_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/include/xqm.h package_partclone/src/xfs/include/xqm.h
--- package_partclone_orig/src/xfs/include/xqm.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/include/xqm.h	2019-11-12 13:59:47.903149883 -0300
@@ -32,7 +32,6 @@
 #define Q_XGETQSTAT	XQM_CMD(5)	/* get quota subsystem status */
 #define Q_XQUOTARM	XQM_CMD(6)	/* free disk space used by dquots */
 #define Q_XQUOTASYNC	XQM_CMD(7)	/* delalloc flush, updates dquots */
-#define Q_XGETQSTATV	XQM_CMD(8)	/* newer version of get quota */
 #define Q_XGETNEXTQUOTA	XQM_CMD(9)	/* get disk limits and usage */

 /*
@@ -150,35 +149,4 @@ typedef struct fs_quota_stat {
 	__u16		qs_iwarnlimit;	/* limit for num warnings */
 } fs_quota_stat_t;

-
-#ifndef FS_QSTATV_VERSION1
-#define FS_QSTATV_VERSION1	1	/* fs_quota_statv.qs_version */
-#endif
-
-/*
- * Some basic information about 'quota files' for Q_XGETQSTATV command
- */
-struct fs_qfilestatv {
-	__u64		qfs_ino;	/* inode number */
-	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
-	__u32		qfs_nextents;	/* number of extents */
-	__u32		qfs_pad;	/* pad for 8-byte alignment */
-};
-
-struct fs_quota_statv {
-	__s8			qs_version;	/* version for future changes */
-	__u8			qs_pad1;	/* pad for 16bit alignment */
-	__u16			qs_flags;	/* FS_QUOTA_.* flags */
-	__u32			qs_incoredqs;	/* number of dquots incore */
-	struct fs_qfilestatv	qs_uquota;	/* user quota information */
-	struct fs_qfilestatv	qs_gquota;	/* group quota information */
-	struct fs_qfilestatv	qs_pquota;	/* project quota information */
-	__s32			qs_btimelimit;	/* limit for blks timer */
-	__s32			qs_itimelimit;	/* limit for inodes timer */
-	__s32			qs_rtbtimelimit;/* limit for rt blks timer */
-	__u16			qs_bwarnlimit;	/* limit for num warnings */
-	__u16			qs_iwarnlimit;	/* limit for num warnings */
-	__u64			qs_pad2[8];	/* for future proofing */
-};
-
 #endif	/* __XQM_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/darwin.c package_partclone/src/xfs/libxfs/darwin.c
--- package_partclone_orig/src/xfs/libxfs/darwin.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/darwin.c	2019-11-12 13:59:47.903149883 -0300
@@ -27,13 +27,13 @@ int platform_has_uuid = 1;
 extern char *progname;

 int
-platform_check_ismounted(char *name, char *block, struct stat *s, int verbose)
+platform_check_ismounted(char *name, char *block, struct stat64 *s, int verbose)
 {
 	return 0;
 }

 int
-platform_check_iswritable(char *name, char *block, struct stat *s)
+platform_check_iswritable(char *name, char *block, struct stat64 *s, int fatal)
 {
 	int	fd, writable;

@@ -69,9 +69,9 @@ void
 platform_findsizes(char *path, int fd, long long *sz, int *bsz)
 {
 	__uint64_t	size;
-	struct stat	st;
+	struct stat64	st;

-	if (fstat(fd, &st) < 0) {
+	if (fstat64(fd, &st) < 0) {
 		fprintf(stderr,
 			_("%s: cannot stat the device file \"%s\": %s\n"),
 			progname, path, strerror(errno));
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/freebsd.c package_partclone/src/xfs/libxfs/freebsd.c
--- package_partclone_orig/src/xfs/libxfs/freebsd.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/freebsd.c	2019-11-12 13:59:47.904149883 -0300
@@ -27,14 +27,14 @@ int platform_has_uuid = 1;
 extern char *progname;

 int
-platform_check_ismounted(char *name, char *block, struct stat *s, int verbose)
+platform_check_ismounted(char *name, char *block, struct stat64 *s, int verbose)
 {
-	struct stat	st;
+	struct stat64	st;
         int cnt, i;
         struct statfs *fsinfo;

 	if (!s) {
-		if (stat(block, &st) < 0)
+		if (stat64(block, &st) < 0)
 			return 0;
 		s = &st;
 	}
@@ -66,7 +66,7 @@ platform_check_ismounted(char *name, cha
 }

 int
-platform_check_iswritable(char *name, char *block, struct stat *s)
+platform_check_iswritable(char *name, char *block, struct stat64 *s, int fatal)
 {
         int cnt, i;
         struct statfs *fsinfo;
@@ -74,7 +74,7 @@ platform_check_iswritable(char *name, ch
         if ((cnt = getmntinfo(&fsinfo, MNT_NOWAIT)) == 0) {
 		fprintf(stderr, _("%s: %s contains a possibly writable, "
 				"mounted filesystem\n"), progname, name);
-			return 1;
+			return fatal;
 	}

         for (i = 0; i < cnt; i++) {
@@ -88,7 +88,7 @@ platform_check_iswritable(char *name, ch
         if (i == cnt) {
 		fprintf(stderr, _("%s: %s contains a mounted and writable "
 				"filesystem\n"), progname, name);
-		return 1;
+		return fatal;
 	}
 	return 0;
 }
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/init.c package_partclone/src/xfs/libxfs/init.c
--- package_partclone_orig/src/xfs/libxfs/init.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/init.c	2019-11-12 13:59:47.904149883 -0300
@@ -26,13 +26,10 @@
 #include "xfs_log_format.h"
 #include "xfs_trans_resv.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode_buf.h"
 #include "xfs_inode_fork.h"
 #include "xfs_inode.h"
 #include "xfs_trans.h"
-#include "xfs_rmap_btree.h"
-#include "xfs_refcount_btree.h"

 #include "libxfs.h"		/* for now */

@@ -68,17 +65,15 @@ static struct dev_to_fd {
 static int
 check_isactive(char *name, char *block, int fatal)
 {
-	struct stat	st;
+	struct stat64	st;

-	if (stat(block, &st) < 0)
+	if (stat64(block, &st) < 0)
 		return 0;
 	if ((st.st_mode & S_IFMT) != S_IFBLK)
 		return 0;
 	if (platform_check_ismounted(name, block, &st, 0) == 0)
 		return 0;
-	if (platform_check_iswritable(name, block, &st))
-		return fatal ? 1 : 0;
-	return 0;
+	return platform_check_iswritable(name, block, &st, fatal);
 }

 /* libxfs_device_to_fd:
@@ -109,7 +104,7 @@ libxfs_device_open(char *path, int creat
 	dev_t		dev;
 	int		fd, d, flags;
 	int		readonly, dio, excl;
-	struct stat	statb;
+	struct stat64	statb;

 	readonly = (xflags & LIBXFS_ISREADONLY);
 	excl = (xflags & LIBXFS_EXCLUSIVELY) && !creat;
@@ -129,7 +124,7 @@ retry:
 		exit(1);
 	}

-	if (fstat(fd, &statb) < 0) {
+	if (fstat64(fd, &statb) < 0) {
 		fprintf(stderr, _("%s: cannot stat %s: %s\n"),
 			progname, path, strerror(errno));
 		exit(1);
@@ -204,9 +199,9 @@ check_open(char *path, int flags, char *
 	int readonly = (flags & LIBXFS_ISREADONLY);
 	int inactive = (flags & LIBXFS_ISINACTIVE);
 	int dangerously = (flags & LIBXFS_DANGEROUSLY);
-	struct stat	stbuf;
+	struct stat64	stbuf;

-	if (stat(path, &stbuf) < 0) {
+	if (stat64(path, &stbuf) < 0) {
 		perror(path);
 		return 0;
 	}
@@ -258,19 +253,14 @@ libxfs_init(libxfs_init_t *a)
 	rtname = a->rtname;
 	a->dfd = a->logfd = a->rtfd = -1;
 	a->ddev = a->logdev = a->rtdev = 0;
-	a->dsize = a->lbsize = a->rtbsize = 0;
-	a->dbsize = a->logBBsize = a->logBBstart = a->rtsize = 0;
+	a->dbsize = a->lbsize = a->rtbsize = 0;
+	a->dsize = a->logBBsize = a->logBBstart = a->rtsize = 0;

 	(void)getcwd(curdir,MAXPATHLEN);
 	needcd = 0;
 	fd = -1;
 	flags = (a->isreadonly | a->isdirect);

-	xfs_extent_free_init_defer_op();
-	xfs_rmap_update_init_defer_op();
-	xfs_refcount_update_init_defer_op();
-	xfs_bmap_update_init_defer_op();
-
 	radix_tree_init();

 	if (a->volname) {
@@ -288,8 +278,6 @@ libxfs_init(libxfs_init_t *a)
 			a->ddev= libxfs_device_open(dname, a->dcreat, flags,
 						    a->setblksize);
 			a->dfd = libxfs_device_to_fd(a->ddev);
-			platform_findsizes(dname, a->dfd, &a->dsize,
-					   &a->dbsize);
 		} else {
 			if (!check_open(dname, flags, &rawfile, &blockfile))
 				goto done;
@@ -297,7 +285,7 @@ libxfs_init(libxfs_init_t *a)
 					a->dcreat, flags, a->setblksize);
 			a->dfd = libxfs_device_to_fd(a->ddev);
 			platform_findsizes(rawfile, a->dfd,
-					   &a->dsize, &a->dbsize);
+						&a->dsize, &a->dbsize);
 		}
 		needcd = 1;
 	} else
@@ -309,8 +297,6 @@ libxfs_init(libxfs_init_t *a)
 			a->logdev = libxfs_device_open(logname,
 					a->lcreat, flags, a->setblksize);
 			a->logfd = libxfs_device_to_fd(a->logdev);
-			platform_findsizes(dname, a->logfd, &a->logBBsize,
-					   &a->lbsize);
 		} else {
 			if (!check_open(logname, flags, &rawfile, &blockfile))
 				goto done;
@@ -318,7 +304,7 @@ libxfs_init(libxfs_init_t *a)
 					a->lcreat, flags, a->setblksize);
 			a->logfd = libxfs_device_to_fd(a->logdev);
 			platform_findsizes(rawfile, a->logfd,
-					   &a->logBBsize, &a->lbsize);
+						&a->logBBsize, &a->lbsize);
 		}
 		needcd = 1;
 	} else
@@ -330,8 +316,6 @@ libxfs_init(libxfs_init_t *a)
 			a->rtdev = libxfs_device_open(rtname,
 					a->rcreat, flags, a->setblksize);
 			a->rtfd = libxfs_device_to_fd(a->rtdev);
-			platform_findsizes(dname, a->rtfd, &a->rtsize,
-					   &a->rtbsize);
 		} else {
 			if (!check_open(rtname, flags, &rawfile, &blockfile))
 				goto done;
@@ -339,7 +323,7 @@ libxfs_init(libxfs_init_t *a)
 					a->rcreat, flags, a->setblksize);
 			a->rtfd = libxfs_device_to_fd(a->rtdev);
 			platform_findsizes(rawfile, a->rtfd,
-					   &a->rtsize, &a->rtbsize);
+						&a->rtsize, &a->rtbsize);
 		}
 		needcd = 1;
 	} else
@@ -427,8 +411,7 @@ manage_zones(int release)
 	xfs_btree_cur_zone = kmem_zone_init(
 			sizeof(xfs_btree_cur_t), "xfs_btree_cur");
 	xfs_bmap_free_item_zone = kmem_zone_init(
-			sizeof(struct xfs_extent_free_item),
-			"xfs_bmap_free_item");
+			sizeof(xfs_bmap_free_item_t), "xfs_bmap_free_item");
 	xfs_log_item_desc_zone = kmem_zone_init(
 			sizeof(struct xfs_log_item_desc), "xfs_log_item_desc");
 	xfs_dir_startup();
@@ -580,8 +563,6 @@ libxfs_initialize_perag(

 	if (maxagi)
 		*maxagi = index;
-
-	mp->m_ag_prealloc_blocks = xfs_prealloc_blocks(mp);
 	return 0;

 out_unwind:
@@ -691,8 +672,6 @@ libxfs_mount(
 	xfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);
 	xfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);
 	xfs_ialloc_compute_maxlevels(mp);
-	xfs_rmapbt_compute_maxlevels(mp);
-	xfs_refcountbt_compute_maxlevels(mp);

 	if (sbp->sb_imax_pct) {
 		/* Make sure the maximum inode count is a multiple of the
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/init.h package_partclone/src/xfs/libxfs/init.h
--- package_partclone_orig/src/xfs/libxfs/init.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/init.h	2019-11-12 13:59:47.905149883 -0300
@@ -18,11 +18,12 @@
 #ifndef LIBXFS_INIT_H
 #define LIBXFS_INIT_H

-struct stat;
+struct stat64;

 extern int platform_check_ismounted (char *path, char *block,
-					struct stat *sptr, int verbose);
-extern int platform_check_iswritable (char *path, char *block, struct stat *sptr);
+					struct stat64 *sptr, int verbose);
+extern int platform_check_iswritable (char *path, char *block,
+					struct stat64 *sptr, int fatal);
 extern int platform_set_blocksize (int fd, char *path, dev_t device, int bsz, int fatal);
 extern void platform_flush_device (int fd, dev_t device);
 extern char *platform_findrawpath(char *path);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/irix.c package_partclone/src/xfs/libxfs/irix.c
--- package_partclone_orig/src/xfs/libxfs/irix.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/irix.c	2019-11-12 13:59:47.905149883 -0300
@@ -25,13 +25,13 @@ extern char *progname;
 extern __int64_t findsize(char *);

 int
-platform_check_ismounted(char *name, char *block, struct stat *s, int verbose)
+platform_check_ismounted(char *name, char *block, struct stat64 *s, int verbose)
 {
 	return 0;
 }

 int
-platform_check_iswritable(char *name, char *block, struct stat *s)
+platform_check_iswritable(char *name, char *block, struct stat64 *s, int fatal)
 {
 	return 1;
 }
@@ -51,9 +51,9 @@ platform_flush_device(int fd, dev_t devi
 void
 platform_findsizes(char *path, int fd, long long *sz, int *bsz)
 {
-	struct stat		st;
+	struct stat64		st;

-	if (fstat(fd, &st) < 0) {
+	if (fstat64(fd, &st) < 0) {
 		fprintf(stderr,
 			_("%s: cannot stat the device file \"%s\": %s\n"),
 			progname, path, strerror(errno));
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/kmem.c package_partclone/src/xfs/libxfs/kmem.c
--- package_partclone_orig/src/xfs/libxfs/kmem.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/kmem.c	2019-11-12 13:59:47.905149883 -0300
@@ -70,7 +70,7 @@ kmem_zalloc(size_t size, int flags)
 }

 void *
-kmem_realloc(void *ptr, size_t new_size, int flags)
+kmem_realloc(void *ptr, size_t new_size, size_t old_size, int flags)
 {
 	ptr = realloc(ptr, new_size);
 	if (ptr == NULL) {
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/libxfs_api_defs.h package_partclone/src/xfs/libxfs/libxfs_api_defs.h
--- package_partclone_orig/src/xfs/libxfs/libxfs_api_defs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/libxfs_api_defs.h	2019-11-12 13:59:47.905149883 -0300
@@ -55,6 +55,7 @@
 #define xfs_trans_read_buf_map		libxfs_trans_read_buf_map
 #define xfs_trans_roll			libxfs_trans_roll
 #define xfs_trans_get_buf_map		libxfs_trans_get_buf_map
+#define xfs_trans_reserve		libxfs_trans_reserve
 #define xfs_trans_resv_calc		libxfs_trans_resv_calc

 #define xfs_attr_get			libxfs_attr_get
@@ -63,10 +64,10 @@
 #define xfs_attr_leaf_newentsize	libxfs_attr_leaf_newentsize

 #define xfs_alloc_fix_freelist		libxfs_alloc_fix_freelist
-#define xfs_alloc_min_freelist		libxfs_alloc_min_freelist
-#define xfs_alloc_read_agf		libxfs_alloc_read_agf
+#define xfs_bmap_cancel			libxfs_bmap_cancel
 #define xfs_bmap_last_offset		libxfs_bmap_last_offset
 #define xfs_bmap_search_extents		libxfs_bmap_search_extents
+#define xfs_bmap_finish			libxfs_bmap_finish
 #define xfs_bmapi_write			libxfs_bmapi_write
 #define xfs_bmapi_read			libxfs_bmapi_read
 #define xfs_bunmapi			libxfs_bunmapi
@@ -74,10 +75,6 @@
 #define xfs_rtfree_extent		libxfs_rtfree_extent
 #define xfs_zero_extent			libxfs_zero_extent

-#define xfs_defer_init			libxfs_defer_init
-#define xfs_defer_finish		libxfs_defer_finish
-#define xfs_defer_cancel		libxfs_defer_cancel
-
 #define xfs_da_brelse			libxfs_da_brelse
 #define xfs_da_hashname			libxfs_da_hashname
 #define xfs_da_shrink_inode		libxfs_da_shrink_inode
@@ -95,23 +92,12 @@
 #define xfs_dir2_data_use_free		libxfs_dir2_data_use_free
 #define xfs_dir2_shrink_inode		libxfs_dir2_shrink_inode

-#define xfs_inode_from_disk		libxfs_inode_from_disk
-#define xfs_inode_to_disk		libxfs_inode_to_disk
+#define xfs_dinode_from_disk		libxfs_dinode_from_disk
+#define xfs_dinode_to_disk		libxfs_dinode_to_disk
 #define xfs_dinode_calc_crc		libxfs_dinode_calc_crc
 #define xfs_idata_realloc		libxfs_idata_realloc
 #define xfs_idestroy_fork		libxfs_idestroy_fork

-#define xfs_rmap_ag_owner		libxfs_rmap_ag_owner
-#define xfs_rmap_alloc			libxfs_rmap_alloc
-#define xfs_rmap_query_range		libxfs_rmap_query_range
-#define xfs_rmap_lookup_le		libxfs_rmap_lookup_le
-#define xfs_rmap_get_rec		libxfs_rmap_get_rec
-#define xfs_rmap_irec_offset_pack	libxfs_rmap_irec_offset_pack
-#define xfs_rmap_irec_offset_unpack	libxfs_rmap_irec_offset_unpack
-#define xfs_rmapbt_init_cursor		libxfs_rmapbt_init_cursor
-#define xfs_btree_del_cursor		libxfs_btree_del_cursor
-
-
 #define xfs_log_sb			libxfs_log_sb
 #define xfs_sb_from_disk		libxfs_sb_from_disk
 #define xfs_sb_quota_from_disk		libxfs_sb_quota_from_disk
@@ -122,26 +108,4 @@

 #define xfs_verify_cksum		libxfs_verify_cksum

-#define xfs_alloc_ag_max_usable		libxfs_alloc_ag_max_usable
-#define xfs_allocbt_maxrecs		libxfs_allocbt_maxrecs
-#define xfs_bmbt_maxrecs		libxfs_bmbt_maxrecs
-#define xfs_bmdr_maxrecs		libxfs_bmdr_maxrecs
-#define xfs_btree_init_block		libxfs_btree_init_block
-#define xfs_dir_ino_validate		libxfs_dir_ino_validate
-#define xfs_initialize_perag_data	libxfs_initialize_perag_data
-#define xfs_inobt_maxrecs		libxfs_inobt_maxrecs
-#define xfs_iread_extents		libxfs_iread_extents
-#define xfs_log_calc_minimum_size	libxfs_log_calc_minimum_size
-#define xfs_perag_get			libxfs_perag_get
-#define xfs_perag_put			libxfs_perag_put
-#define xfs_prealloc_blocks		libxfs_prealloc_blocks
-#define xfs_dinode_good_version		libxfs_dinode_good_version
-#define xfs_free_extent			libxfs_free_extent
-
-#define xfs_refcountbt_init_cursor	libxfs_refcountbt_init_cursor
-#define xfs_refcount_lookup_le		libxfs_refcount_lookup_le
-#define xfs_refcount_get_rec		libxfs_refcount_get_rec
-#define xfs_rmap_lookup_le_range	libxfs_rmap_lookup_le_range
-#define xfs_refc_block			libxfs_refc_block
-
 #endif /* __LIBXFS_API_DEFS_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/libxfs_io.h package_partclone/src/xfs/libxfs/libxfs_io.h
--- package_partclone_orig/src/xfs/libxfs/libxfs_io.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/libxfs_io.h	2019-11-12 13:59:47.906149883 -0300
@@ -75,7 +75,7 @@ typedef struct xfs_buf {
 	int			b_error;
 	const struct xfs_buf_ops *b_ops;
 	struct xfs_perag	*b_pag;
-	struct xfs_buf_map	*b_maps;
+	struct xfs_buf_map	*b_map;
 	int			b_nmaps;
 #ifdef XFS_BUF_TRACING
 	struct list_head	b_lock_list;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/libxfs_priv.h package_partclone/src/xfs/libxfs/libxfs_priv.h
--- package_partclone_orig/src/xfs/libxfs/libxfs_priv.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/libxfs_priv.h	2019-11-12 13:59:47.906149883 -0300
@@ -140,9 +140,9 @@ enum ce { CE_DEBUG, CE_CONT, CE_NOTE, CE
 #define XFS_ERRLEVEL_LOW		1
 #define XFS_FORCED_SHUTDOWN(mp)		0
 #define XFS_ILOCK_EXCL			0
-#define XFS_STATS_INC(mp, count)	do { (mp) = (mp); } while (0)
-#define XFS_STATS_DEC(mp, count, x)	do { (mp) = (mp); } while (0)
-#define XFS_STATS_ADD(mp, count, x)	do { (mp) = (mp); } while (0)
+#define XFS_STATS_INC(mp, count)	do { } while (0)
+#define XFS_STATS_DEC(mp, count, x)	do { } while (0)
+#define XFS_STATS_ADD(mp, count, x)	do { } while (0)
 #define XFS_TRANS_MOD_DQUOT_BYINO(mp,tp,ip,field,delta)	do { } while (0)
 #define XFS_TRANS_RESERVE_QUOTA_NBLKS(mp,tp,ip,nblks,ninos,fl)	0
 #define XFS_TRANS_UNRESERVE_QUOTA_NBLKS(mp,tp,ip,nblks,ninos,fl)	0
@@ -195,7 +195,7 @@ enum ce { CE_DEBUG, CE_CONT, CE_NOTE, CE
  */
 #define prandom_u32()		0

-#define PAGE_SIZE		getpagesize()
+#define PAGE_CACHE_SIZE		getpagesize()

 static inline int __do_div(unsigned long long *n, unsigned base)
 {
@@ -361,6 +361,7 @@ roundup_64(__uint64_t x, __uint32_t y)
 #define XFS_MOUNT_RDONLY		0	/* ignored in userspace */


+#define _xfs_trans_alloc(mp, type, f)	libxfs_trans_alloc(mp, type)
 #define xfs_trans_get_block_res(tp)	1
 #define xfs_trans_set_sync(tp)		((void) 0)
 #define xfs_trans_ordered_buf(tp, bp)	((void) 0)
@@ -370,7 +371,6 @@ roundup_64(__uint64_t x, __uint32_t y)
 #define xfs_trans_buf_set_type(tp, bp, t)	({	\
 	int __t = (t);					\
 	__t = __t; /* no set-but-unused warning */	\
-	tp = tp;  /* no set-but-unused warning */	\
 })

 #define xfs_trans_buf_copy_type(dbp, sbp)
@@ -434,7 +434,6 @@ do { \
 #define xfs_rotorstep				1
 #define xfs_bmap_rtalloc(a)			(-ENOSYS)
 #define xfs_get_extsz_hint(ip)			(0)
-#define xfs_get_cowextsz_hint(ip)		(0)
 #define xfs_inode_is_filestream(ip)		(0)
 #define xfs_filestream_lookup_ag(ip)		(0)
 #define xfs_filestream_new_ag(ip,ag)		(0)
@@ -475,7 +474,8 @@ struct xfs_buftarg;
 int xfs_attr_rmtval_get(struct xfs_da_args *);

 /* xfs_bmap.c */
-void xfs_bmap_del_free(struct xfs_bmap_free *, struct xfs_bmap_free_item *);
+void xfs_bmap_del_free(struct xfs_bmap_free *, struct xfs_bmap_free_item *,
+			struct xfs_bmap_free_item *);

 /* xfs_mount.c */
 int xfs_initialize_perag_data(struct xfs_mount *, xfs_agnumber_t);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/linux.c package_partclone/src/xfs/libxfs/linux.c
--- package_partclone_orig/src/xfs/libxfs/linux.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/linux.c	2019-11-12 13:59:47.907149883 -0300
@@ -45,24 +45,16 @@ static int max_block_alignment;

 #define PROC_MOUNTED	"/proc/mounts"

-/*
- * Check if the filesystem is mounted.  Be verbose if asked, and
- * optionally restrict check to /writable/ mounts (i.e. RO is OK)
- */
-#define	CHECK_MOUNT_VERBOSE	0x1
-#define	CHECK_MOUNT_WRITABLE	0x2
-
-static int
-platform_check_mount(char *name, char *block, struct stat *s, int flags)
+int
+platform_check_ismounted(char *name, char *block, struct stat64 *s, int verbose)
 {
 	FILE		*f;
-	struct stat	st, mst;
+	struct stat64	st, mst;
 	struct mntent	*mnt;
 	char		mounts[MAXPATHLEN];

 	if (!s) {
-		/* If either fails we are not mounted */
-		if (stat(block, &st) < 0)
+		if (stat64(block, &st) < 0)
 			return 0;
 		if ((st.st_mode & S_IFMT) != S_IFBLK)
 			return 0;
@@ -71,60 +63,78 @@ platform_check_mount(char *name, char *b

 	strcpy(mounts, (!access(PROC_MOUNTED, R_OK)) ? PROC_MOUNTED : MOUNTED);
 	if ((f = setmntent(mounts, "r")) == NULL) {
-		/* Unexpected failure, warn unconditionally */
 		fprintf(stderr,
 		    _("%s: %s possibly contains a mounted filesystem\n"),
 		    progname, name);
 		return 1;
 	}
+	/*
+	 * This whole business is to work out if our block device is mounted
+	 * after we lost ustat(2), see:
+	 *      4e7a824 libxfs/linux.c: Replace use of ustat by stat
+	 * We don't really want to stat every single mounted directory,
+	 * as that may include tmpfs, cgroups, procfs or - worst - hung nfs
+	 * servers.  So first, a simple check: does the "dev" start with "/" ?
+	 */
 	while ((mnt = getmntent(f)) != NULL) {
-		if (stat(mnt->mnt_dir, &mst) < 0)
+		if (mnt->mnt_fsname[0] != '/')
 			continue;
-		if (mst.st_dev != s->st_rdev)
+		if (stat64(mnt->mnt_dir, &mst) < 0)
 			continue;
-		/* Found our device, is RO OK? */
-		if ((flags & CHECK_MOUNT_WRITABLE) && hasmntopt(mnt, MNTOPT_RO))
+		if (mst.st_dev != s->st_rdev)
 			continue;
-		else
-			break;
-	}
-	endmntent(f);
-
-	/* No mounts contained the condition we were looking for */
-	if (mnt == NULL)
-		return 0;

-	if (flags & CHECK_MOUNT_VERBOSE) {
-		if (flags & CHECK_MOUNT_WRITABLE) {
+		if (verbose)
 			fprintf(stderr,
-_("%s: %s contains a mounted and writable filesystem\n"),
+				_("%s: %s contains a mounted filesystem\n"),
 				progname, name);
-		} else {
-			fprintf(stderr,
-_("%s: %s contains a mounted filesystem\n"),
-				progname, name);
-		}
+		break;
 	}
-	return 1;
-}
-
-int
-platform_check_ismounted(char *name, char *block, struct stat *s, int verbose)
-{
-	int flags;
-
-	flags = verbose ? CHECK_MOUNT_VERBOSE : 0;
-	return platform_check_mount(name, block, s, flags);
+	endmntent(f);
+	return mnt != NULL;
 }

 int
-platform_check_iswritable(char *name, char *block, struct stat *s)
+platform_check_iswritable(char *name, char *block, struct stat64 *s, int fatal)
 {
-	int flags;
+	int		sts = 0;
+	FILE		*f;
+	struct stat64	mst;
+	struct mntent	*mnt;
+	char		mounts[MAXPATHLEN];

-	/* Writable checks are always verbose */
-	flags = CHECK_MOUNT_WRITABLE | CHECK_MOUNT_VERBOSE;
-	return platform_check_mount(name, block, s, flags);
+	strcpy(mounts, (!access(PROC_MOUNTED, R_OK)) ? PROC_MOUNTED : MOUNTED);
+	if ((f = setmntent(mounts, "r")) == NULL) {
+		fprintf(stderr, _("%s: %s contains a possibly writable, "
+				"mounted filesystem\n"), progname, name);
+			return fatal;
+	}
+	/*
+	 * This whole business is to work out if our block device is mounted
+	 * after we lost ustat(2), see:
+	 *      4e7a824 libxfs/linux.c: Replace use of ustat by stat
+	 * We don't really want to stat every single mounted directory,
+	 * as that may include tmpfs, cgroups, procfs or - worst - hung nfs
+	 * servers.  So first, a simple check: does the "dev" start with "/" ?
+	 */
+	while ((mnt = getmntent(f)) != NULL) {
+		if (mnt->mnt_fsname[0] != '/')
+			continue;
+		if (stat64(mnt->mnt_fsname, &mst) < 0)
+			continue;
+		if ((mst.st_mode & S_IFMT) != S_IFBLK)
+			continue;
+		if (mst.st_rdev == s->st_rdev
+		    && hasmntopt(mnt, MNTOPT_RO) != NULL)
+			break;
+	}
+	if (mnt == NULL) {
+		fprintf(stderr, _("%s: %s contains a mounted and writable "
+				"filesystem\n"), progname, name);
+		sts = fatal;
+	}
+	endmntent(f);
+	return sts;
 }

 int
@@ -146,27 +156,18 @@ platform_set_blocksize(int fd, char *pat
 void
 platform_flush_device(int fd, dev_t device)
 {
-	struct stat	st;
-	if (major(device) == RAMDISK_MAJOR)
-		return;
-
-	if (fstat(fd, &st) < 0)
-		return;
-
-	if (S_ISREG(st.st_mode))
-		fsync(fd);
-	else
+	if (major(device) != RAMDISK_MAJOR)
 		ioctl(fd, BLKFLSBUF, 0);
 }

 void
 platform_findsizes(char *path, int fd, long long *sz, int *bsz)
 {
-	struct stat	st;
+	struct stat64	st;
 	__uint64_t	size;
 	int		error;

-	if (fstat(fd, &st) < 0) {
+	if (fstat64(fd, &st) < 0) {
 		fprintf(stderr, _("%s: "
 			"cannot stat the device file \"%s\": %s\n"),
 			progname, path, strerror(errno));
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/rdwr.c package_partclone/src/xfs/libxfs/rdwr.c
--- package_partclone_orig/src/xfs/libxfs/rdwr.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/rdwr.c	2019-11-12 13:59:47.907149883 -0300
@@ -88,7 +88,7 @@ libxfs_device_zero(struct xfs_buftarg *b
 	fd = libxfs_device_to_fd(btp->dev);
 	start_offset = LIBXFS_BBTOOFF64(start);

-	if ((lseek(fd, start_offset, SEEK_SET)) < 0) {
+	if ((lseek64(fd, start_offset, SEEK_SET)) < 0) {
 		fprintf(stderr, _("%s: %s seek to offset %llu failed: %s\n"),
 			progname, __FUNCTION__,
 			(unsigned long long)start_offset, strerror(errno));
@@ -608,8 +608,8 @@ libxfs_initbuf_map(xfs_buf_t *bp, struct
 	int i;

 	bytes = sizeof(struct xfs_buf_map) * nmaps;
-	bp->b_maps = malloc(bytes);
-	if (!bp->b_maps) {
+	bp->b_map = malloc(bytes);
+	if (!bp->b_map) {
 		fprintf(stderr,
 			_("%s: %s can't malloc %u bytes: %s\n"),
 			progname, __FUNCTION__, bytes,
@@ -620,8 +620,8 @@ libxfs_initbuf_map(xfs_buf_t *bp, struct

 	bytes = 0;
 	for ( i = 0; i < nmaps; i++) {
-		bp->b_maps[i].bm_bn = map[i].bm_bn;
-		bp->b_maps[i].bm_len = map[i].bm_len;
+		bp->b_map[i].bm_bn = map[i].bm_bn;
+		bp->b_map[i].bm_len = map[i].bm_len;
 		bytes += BBTOB(map[i].bm_len);
 	}

@@ -654,8 +654,8 @@ __libxfs_getbufr(int blen)
 			list_del_init(&bp->b_node.cn_mru);
 			free(bp->b_addr);
 			bp->b_addr = NULL;
-			free(bp->b_maps);
-			bp->b_maps = NULL;
+			free(bp->b_map);
+			bp->b_map = NULL;
 		}
 	} else
 		bp = kmem_zone_zalloc(xfs_buf_zone, 0);
@@ -915,7 +915,7 @@ __read_buf(int fd, void *buf, int len, o
 {
 	int	sts;

-	sts = pread(fd, buf, len, offset);
+	sts = pread64(fd, buf, len, offset);
 	if (sts < 0) {
 		int error = errno;
 		fprintf(stderr, _("%s: read failed: %s\n"),
@@ -1024,8 +1024,8 @@ libxfs_readbufr_map(struct xfs_buftarg *
 	fd = libxfs_device_to_fd(btp->dev);
 	buf = bp->b_addr;
 	for (i = 0; i < bp->b_nmaps; i++) {
-		off64_t	offset = LIBXFS_BBTOOFF64(bp->b_maps[i].bm_bn);
-		int len = BBTOB(bp->b_maps[i].bm_len);
+		off64_t	offset = LIBXFS_BBTOOFF64(bp->b_map[i].bm_bn);
+		int len = BBTOB(bp->b_map[i].bm_len);

 		error = __read_buf(fd, buf, len, offset, flags);
 		if (error) {
@@ -1038,9 +1038,9 @@ libxfs_readbufr_map(struct xfs_buftarg *
 	if (!error)
 		bp->b_flags |= LIBXFS_B_UPTODATE;
 #ifdef IO_DEBUG
-	printf("%lx: %s: read %lu bytes, error %d, blkno=%llu(%llu), %p\n",
-		pthread_self(), __FUNCTION__, buf - (char *)bp->b_addr, error,
-		(long long)LIBXFS_BBTOOFF64(bp->b_bn), (long long)bp->b_bn, bp);
+	printf("%lx: %s: read %u bytes, error %d, blkno=0x%llx(0x%llx), %p\n",
+		pthread_self(), __FUNCTION__, , error,
+		(long long)LIBXFS_BBTOOFF64(blkno), (long long)blkno, bp);
 #endif
 	return error;
 }
@@ -1070,7 +1070,7 @@ libxfs_readbuf_map(struct xfs_buftarg *b
 	if (!error)
 		libxfs_readbuf_verify(bp, ops);

-#ifdef IO_DEBUGX
+#ifdef IO_DEBUG
 	printf("%lx: %s: read %lu bytes, error %d, blkno=%llu(%llu), %p\n",
 		pthread_self(), __FUNCTION__, buf - (char *)bp->b_addr, error,
 		(long long)LIBXFS_BBTOOFF64(bp->b_bn), (long long)bp->b_bn, bp);
@@ -1083,16 +1083,16 @@ __write_buf(int fd, void *buf, int len,
 {
 	int	sts;

-	sts = pwrite(fd, buf, len, offset);
+	sts = pwrite64(fd, buf, len, offset);
 	if (sts < 0) {
 		int error = errno;
-		fprintf(stderr, _("%s: pwrite failed: %s\n"),
+		fprintf(stderr, _("%s: pwrite64 failed: %s\n"),
 			progname, strerror(error));
 		if (flags & LIBXFS_B_EXIT)
 			exit(1);
 		return -error;
 	} else if (sts != len) {
-		fprintf(stderr, _("%s: error - pwrite only %d of %d bytes\n"),
+		fprintf(stderr, _("%s: error - pwrite64 only %d of %d bytes\n"),
 			progname, sts, len);
 		if (flags & LIBXFS_B_EXIT)
 			exit(1);
@@ -1142,8 +1142,8 @@ libxfs_writebufr(xfs_buf_t *bp)
 		char	*buf = bp->b_addr;

 		for (i = 0; i < bp->b_nmaps; i++) {
-			off64_t	offset = LIBXFS_BBTOOFF64(bp->b_maps[i].bm_bn);
-			int len = BBTOB(bp->b_maps[i].bm_len);
+			off64_t	offset = LIBXFS_BBTOOFF64(bp->b_map[i].bm_bn);
+			int len = BBTOB(bp->b_map[i].bm_len);

 			bp->b_error = __write_buf(fd, buf, len, offset,
 						  bp->b_flags);
@@ -1260,7 +1260,7 @@ libxfs_bulkrelse(
 	}

 	pthread_mutex_lock(&xfs_buf_freelist.cm_mutex);
-	list_splice(list, &xfs_buf_freelist.cm_list);
+	__list_splice(list, &xfs_buf_freelist.cm_list);
 	pthread_mutex_unlock(&xfs_buf_freelist.cm_mutex);

 	return count;
@@ -1330,7 +1330,7 @@ extern kmem_zone_t	*xfs_inode_zone;

 int
 libxfs_iget(xfs_mount_t *mp, xfs_trans_t *tp, xfs_ino_t ino, uint lock_flags,
-		xfs_inode_t **ipp)
+		xfs_inode_t **ipp, xfs_daddr_t bno)
 {
 	xfs_inode_t	*ip;
 	int		error = 0;
@@ -1341,7 +1341,7 @@ libxfs_iget(xfs_mount_t *mp, xfs_trans_t

 	ip->i_ino = ino;
 	ip->i_mount = mp;
-	error = xfs_iread(mp, tp, ip, 0);
+	error = xfs_iread(mp, tp, ip, bno);
 	if (error) {
 		kmem_zone_free(xfs_inode_zone, ip);
 		*ipp = NULL;
@@ -1351,7 +1351,7 @@ libxfs_iget(xfs_mount_t *mp, xfs_trans_t
 	/*
 	 * set up the inode ops structure that the libxfs code relies on
 	 */
-	if (XFS_ISDIR(ip))
+	if (S_ISDIR(ip->i_d.di_mode))
 		ip->d_ops = mp->m_dir_inode_ops;
 	else
 		ip->d_ops = mp->m_nondir_inode_ops;
@@ -1363,7 +1363,7 @@ libxfs_iget(xfs_mount_t *mp, xfs_trans_t
 static void
 libxfs_idestroy(xfs_inode_t *ip)
 {
-	switch (VFS_I(ip)->i_mode & S_IFMT) {
+	switch (ip->i_d.di_mode & S_IFMT) {
 		case S_IFREG:
 		case S_IFDIR:
 		case S_IFLNK:
@@ -1372,8 +1372,6 @@ libxfs_idestroy(xfs_inode_t *ip)
 	}
 	if (ip->i_afp)
 		libxfs_idestroy_fork(ip, XFS_ATTR_FORK);
-	if (ip->i_cowfp)
-		xfs_idestroy_fork(ip, XFS_COW_FORK);
 }

 void
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/trans.c package_partclone/src/xfs/libxfs/trans.c
--- package_partclone_orig/src/xfs/libxfs/trans.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/trans.c	2019-11-12 13:59:47.908149883 -0300
@@ -103,7 +103,6 @@ libxfs_trans_roll(
 	struct xfs_trans	**tpp,
 	struct xfs_inode	*dp)
 {
-	struct xfs_mount	*mp;
 	struct xfs_trans	*trans;
 	struct xfs_trans_res	tres;
 	int			error;
@@ -118,9 +117,9 @@ libxfs_trans_roll(
 	/*
 	 * Copy the critical parameters from one trans to the next.
 	 */
-	mp = trans->t_mountp;
 	tres.tr_logres = trans->t_log_res;
 	tres.tr_logcount = trans->t_log_count;
+	*tpp = libxfs_trans_alloc(trans->t_mountp, trans->t_type);

 	/*
 	 * Commit the current transaction.
@@ -133,6 +132,7 @@ libxfs_trans_roll(
 	if (error)
 		return error;

+	trans = *tpp;

 	/*
 	 * Reserve space in the log for th next transaction.
@@ -143,8 +143,7 @@ libxfs_trans_roll(
 	 * the prior and the next transactions.
 	 */
 	tres.tr_logflags = XFS_TRANS_PERM_LOG_RES;
-	error = libxfs_trans_alloc(mp, &tres, 0, 0, 0, tpp);
-	trans = *tpp;
+	error = xfs_trans_reserve(trans, &tres, 0, 0);
 	/*
 	 *  Ensure that the inode is in the new transaction and locked.
 	 */
@@ -156,28 +155,12 @@ libxfs_trans_roll(
 	return 0;
 }

-int
+xfs_trans_t *
 libxfs_trans_alloc(
-	struct xfs_mount	*mp,
-	struct xfs_trans_res	*resp,
-	unsigned int		blocks,
-	unsigned int		rtextents,
-	unsigned int		flags,
-	struct xfs_trans	**tpp)
-
+	xfs_mount_t	*mp,
+	int		type)
 {
-	struct xfs_sb	*sb = &mp->m_sb;
-	struct xfs_trans *ptr;
-
-	/*
-	 * Attempt to reserve the needed disk blocks by decrementing
-	 * the number needed from the number available.	 This will
-	 * fail if the count would go below zero.
-	 */
-	if (blocks > 0) {
-		if (sb->sb_fdblocks < blocks)
-			return -ENOSPC;
-	}
+	xfs_trans_t	*ptr;

 	if ((ptr = calloc(sizeof(xfs_trans_t), 1)) == NULL) {
 		fprintf(stderr, _("%s: xact calloc failed (%d bytes): %s\n"),
@@ -185,11 +168,33 @@ libxfs_trans_alloc(
 		exit(1);
 	}
 	ptr->t_mountp = mp;
+	ptr->t_type = type;
 	INIT_LIST_HEAD(&ptr->t_items);
 #ifdef XACT_DEBUG
 	fprintf(stderr, "allocated new transaction %p\n", ptr);
 #endif
-	*tpp = ptr;
+	return ptr;
+}
+
+int
+libxfs_trans_reserve(
+	struct xfs_trans	*tp,
+	struct xfs_trans_res	*resp,
+	uint			blocks,
+	uint			rtextents)
+{
+	xfs_sb_t	*mpsb = &tp->t_mountp->m_sb;
+
+	/*
+	 * Attempt to reserve the needed disk blocks by decrementing
+	 * the number needed from the number available.	 This will
+	 * fail if the count would go below zero.
+	 */
+	if (blocks > 0) {
+		if (mpsb->sb_fdblocks < blocks)
+			return -ENOSPC;
+	}
+	/* user space, don't need log/RT stuff (preserve the API though) */
 	return 0;
 }

@@ -224,9 +229,9 @@ libxfs_trans_iget(
 	xfs_inode_log_item_t	*iip;

 	if (tp == NULL)
-		return libxfs_iget(mp, tp, ino, lock_flags, ipp);
+		return libxfs_iget(mp, tp, ino, lock_flags, ipp, 0);

-	error = libxfs_iget(mp, tp, ino, lock_flags, &ip);
+	error = libxfs_iget(mp, tp, ino, lock_flags, &ip, 0);
 	if (error)
 		return error;
 	ASSERT(ip != NULL);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/util.c package_partclone/src/xfs/libxfs/util.c
--- package_partclone_orig/src/xfs/libxfs/util.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/util.c	2019-11-12 13:59:47.908149883 -0300
@@ -16,6 +16,7 @@
  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */

+#include <config.h>
 #include "libxfs_priv.h"
 #include "libxfs_io.h"
 #include "init.h"
@@ -25,7 +26,6 @@
 #include "xfs_log_format.h"
 #include "xfs_trans_resv.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode_buf.h"
 #include "xfs_inode_fork.h"
 #include "xfs_inode.h"
@@ -36,7 +36,6 @@
 #include "xfs_ialloc.h"
 #include "xfs_alloc.h"
 #include "xfs_bit.h"
-#define VERSION "4.9.0"

 /*
  * Calculate the worst case log unit reservation for a given superblock
@@ -163,10 +162,14 @@ libxfs_trans_ichgtime(
 	gettimeofday(&stv, (struct timezone *)0);
 	tv.tv_sec = stv.tv_sec;
 	tv.tv_nsec = stv.tv_usec * 1000;
-	if (flags & XFS_ICHGTIME_MOD)
-		VFS_I(ip)->i_mtime = tv;
-	if (flags & XFS_ICHGTIME_CHG)
-		VFS_I(ip)->i_ctime = tv;
+	if (flags & XFS_ICHGTIME_MOD) {
+		ip->i_d.di_mtime.t_sec = (__int32_t)tv.tv_sec;
+		ip->i_d.di_mtime.t_nsec = (__int32_t)tv.tv_nsec;
+	}
+	if (flags & XFS_ICHGTIME_CHG) {
+		ip->i_d.di_ctime.t_sec = (__int32_t)tv.tv_sec;
+		ip->i_d.di_ctime.t_nsec = (__int32_t)tv.tv_nsec;
+	}
 	if (flags & XFS_ICHGTIME_CREATE) {
 		ip->i_d.di_crtime.t_sec = (__int32_t)tv.tv_sec;
 		ip->i_d.di_crtime.t_nsec = (__int32_t)tv.tv_nsec;
@@ -219,11 +222,14 @@ libxfs_ialloc(
 		return error;
 	ASSERT(ip != NULL);

-	VFS_I(ip)->i_mode = mode;
-	set_nlink(VFS_I(ip), nlink);
+	ip->i_d.di_mode = (__uint16_t)mode;
+	ip->i_d.di_onlink = 0;
+	ip->i_d.di_nlink = nlink;
+	ASSERT(ip->i_d.di_nlink == nlink);
 	ip->i_d.di_uid = cr->cr_uid;
 	ip->i_d.di_gid = cr->cr_gid;
 	xfs_set_projid(&ip->i_d, pip ? 0 : fsx->fsx_projid);
+	memset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));
 	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG | XFS_ICHGTIME_MOD);

 	/*
@@ -240,15 +246,18 @@ libxfs_ialloc(
 		 */
 	}

-	if (pip && (VFS_I(pip)->i_mode & S_ISGID)) {
+	if (pip && (pip->i_d.di_mode & S_ISGID)) {
 		ip->i_d.di_gid = pip->i_d.di_gid;
-		if ((VFS_I(pip)->i_mode & S_ISGID) && (mode & S_IFMT) == S_IFDIR)
-			VFS_I(ip)->i_mode |= S_ISGID;
+		if ((pip->i_d.di_mode & S_ISGID) && (mode & S_IFMT) == S_IFDIR)
+			ip->i_d.di_mode |= S_ISGID;
 	}

 	ip->i_d.di_size = 0;
 	ip->i_d.di_nextents = 0;
 	ASSERT(ip->i_d.di_nblocks == 0);
+	/*
+	 * di_gen will have been taken care of in xfs_iread.
+	 */
 	ip->i_d.di_extsize = pip ? 0 : fsx->fsx_extsize;
 	ip->i_d.di_dmevmask = 0;
 	ip->i_d.di_dmstate = 0;
@@ -257,10 +266,12 @@ libxfs_ialloc(
 	if (ip->i_d.di_version == 3) {
 		ASSERT(ip->i_d.di_ino == ino);
 		ASSERT(uuid_equal(&ip->i_d.di_uuid, &mp->m_sb.sb_meta_uuid));
-		VFS_I(ip)->i_version = 1;
+		ip->i_d.di_crc = 0;
+		ip->i_d.di_changecount = 1;
+		ip->i_d.di_lsn = 0;
 		ip->i_d.di_flags2 = 0;
-		ip->i_d.di_crtime.t_sec = (__int32_t)VFS_I(ip)->i_mtime.tv_sec;
-		ip->i_d.di_crtime.t_nsec = (__int32_t)VFS_I(ip)->i_mtime.tv_nsec;
+		memset(&(ip->i_d.di_pad2[0]), 0, sizeof(ip->i_d.di_pad2));
+		ip->i_d.di_crtime = ip->i_d.di_mtime;
 	}

 	flags = XFS_ILOG_CORE;
@@ -318,7 +329,7 @@ libxfs_ialloc(
 	/*
 	 * set up the inode ops structure that the libxfs code relies on
 	 */
-	if (XFS_ISDIR(ip))
+	if (S_ISDIR(ip->i_d.di_mode))
 		ip->d_ops = ip->i_mount->m_dir_inode_ops;
 	else
 		ip->d_ops = ip->i_mount->m_nondir_inode_ops;
@@ -335,7 +346,7 @@ void
 libxfs_iprint(
 	xfs_inode_t		*ip)
 {
-	struct xfs_icdinode	*dip;
+	xfs_icdinode_t		*dip;
 	xfs_bmbt_rec_host_t	*ep;
 	xfs_extnum_t		i;
 	xfs_extnum_t		nextents;
@@ -369,7 +380,8 @@ libxfs_iprint(

 	dip = &ip->i_d;
 	printf("\nOn disk portion\n");
-	printf("    di_mode %o\n", VFS_I(ip)->i_mode);
+	printf("    di_magic %x\n", dip->di_magic);
+	printf("    di_mode %o\n", dip->di_mode);
 	printf("    di_version %x\n", (uint)dip->di_version);
 	switch (ip->i_d.di_format) {
 	case XFS_DINODE_FMT_LOCAL:
@@ -385,12 +397,12 @@ libxfs_iprint(
 		printf("    Other inode\n");
 		break;
 	}
-	printf("   di_nlink %x\n", VFS_I(ip)->i_nlink);
+	printf("   di_nlink %x\n", dip->di_nlink);
 	printf("   di_uid %d\n", dip->di_uid);
 	printf("   di_gid %d\n", dip->di_gid);
 	printf("   di_nextents %d\n", dip->di_nextents);
 	printf("   di_size %llu\n", (unsigned long long)dip->di_size);
-	printf("   di_gen %x\n", VFS_I(ip)->i_generation);
+	printf("   di_gen %x\n", dip->di_gen);
 	printf("   di_extsize %d\n", dip->di_extsize);
 	printf("   di_flags %x\n", dip->di_flags);
 	printf("   di_nblocks %llu\n", (unsigned long long)dip->di_nblocks);
@@ -419,10 +431,11 @@ libxfs_iflush_int(xfs_inode_t *ip, xfs_b
 	dip = xfs_buf_offset(bp, ip->i_imap.im_boffset);

 	ASSERT(ip->i_d.di_magic == XFS_DINODE_MAGIC);
-	if (XFS_ISREG(ip)) {
+	if ((ip->i_d.di_mode & S_IFMT) == S_IFREG) {
 		ASSERT( (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS) ||
 			(ip->i_d.di_format == XFS_DINODE_FMT_BTREE) );
-	} else if (XFS_ISDIR(ip)) {
+	}
+	else if ((ip->i_d.di_mode & S_IFMT) == S_IFDIR) {
 		ASSERT( (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS) ||
 			(ip->i_d.di_format == XFS_DINODE_FMT_BTREE)   ||
 			(ip->i_d.di_format == XFS_DINODE_FMT_LOCAL) );
@@ -432,7 +445,7 @@ libxfs_iflush_int(xfs_inode_t *ip, xfs_b

 	/* bump the change count on v3 inodes */
 	if (ip->i_d.di_version == 3)
-		VFS_I(ip)->i_version++;
+		ip->i_d.di_changecount++;

 	/*
 	 * Copy the dirty parts of the inode into the on-disk
@@ -440,12 +453,16 @@ libxfs_iflush_int(xfs_inode_t *ip, xfs_b
 	 * because if the inode is dirty at all the core must
 	 * be.
 	 */
-	xfs_inode_to_disk(ip, dip, iip->ili_item.li_lsn);
+	xfs_dinode_to_disk(dip, &ip->i_d);

 	xfs_iflush_fork(ip, dip, iip, XFS_DATA_FORK);
 	if (XFS_IFORK_Q(ip))
 		xfs_iflush_fork(ip, dip, iip, XFS_ATTR_FORK);

+	/* update the lsn in the on disk inode if required */
+	if (ip->i_d.di_version == 3)
+		dip->di_lsn = cpu_to_be64(iip->ili_item.li_lsn);
+
 	/* generate the checksum. */
 	xfs_dinode_calc_crc(mp, dip);

@@ -475,6 +492,30 @@ libxfs_mod_incore_sb(
 	}
 }

+int
+libxfs_bmap_finish(
+	struct xfs_trans	**tp,
+	struct xfs_bmap_free	*flist,
+	struct xfs_inode	*ip)
+{
+	xfs_bmap_free_item_t	*free;	/* free extent list item */
+	xfs_bmap_free_item_t	*next;	/* next item on free list */
+	int			error;
+
+	if (flist->xbf_count == 0)
+		return 0;
+
+	for (free = flist->xbf_first; free != NULL; free = next) {
+		next = free->xbfi_next;
+		error = xfs_free_extent(*tp, free->xbfi_startblock,
+					free->xbfi_blockcount);
+		if (error)
+			return error;
+		xfs_bmap_del_free(flist, NULL, free);
+	}
+	return 0;
+}
+
 /*
  * This routine allocates disk space for the given file.
  * Originally derived from xfs_alloc_file_space().
@@ -493,7 +534,7 @@ libxfs_alloc_file_space(
 	xfs_filblks_t	allocated_fsb;
 	xfs_filblks_t	allocatesize_fsb;
 	xfs_fsblock_t	firstfsb;
-	struct xfs_defer_ops free_list;
+	xfs_bmap_free_t free_list;
 	xfs_bmbt_irec_t *imapp;
 	xfs_bmbt_irec_t imaps[1];
 	int		reccount;
@@ -519,19 +560,24 @@ libxfs_alloc_file_space(
 	while (allocatesize_fsb && !error) {
 		datablocks = allocatesize_fsb;

+		tp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);
 		resblks = (uint)XFS_DIOSTRAT_SPACE_RES(mp, datablocks);
-		error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks,
-					0, 0, &tp);
+		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,
+					  resblks, 0);
 		/*
 		 * Check for running out of space
 		 */
 		if (error) {
+			/*
+			 * Free the transaction structure.
+			 */
 			ASSERT(error == -ENOSPC);
+			xfs_trans_cancel(tp);
 			break;
 		}
 		xfs_trans_ijoin(tp, ip, 0);

-		xfs_defer_init(&free_list, &firstfsb);
+		xfs_bmap_init(&free_list, &firstfsb);
 		error = xfs_bmapi_write(tp, ip, startoffset_fsb, allocatesize_fsb,
 				xfs_bmapi_flags, &firstfsb, 0, imapp,
 				&reccount, &free_list);
@@ -540,7 +586,7 @@ libxfs_alloc_file_space(
 			goto error0;

 		/* complete the transaction */
-		error = xfs_defer_finish(&tp, &free_list, ip);
+		error = xfs_bmap_finish(&tp, &free_list, ip);
 		if (error)
 			goto error0;

@@ -558,7 +604,7 @@ libxfs_alloc_file_space(
 	return error;

 error0:	/* Cancel bmap, cancel trans */
-	xfs_defer_cancel(&free_list);
+	xfs_bmap_cancel(&free_list);
 	xfs_trans_cancel(tp);
 	return error;
 }
@@ -644,9 +690,8 @@ libxfs_fs_repair_cmn_err(int level, xfs_
 	vfprintf(stderr, fmt, ap);
 	fprintf(stderr, "  This is a bug.\n");
 	fprintf(stderr, "%s version %s\n", progname, VERSION);
-	fprintf(stderr,
-		"Please capture the filesystem metadata with xfs_metadump and\n"
-		"report it to linux-xfs@vger.kernel.org\n");
+	fprintf(stderr, "Please capture the filesystem metadata with "
+			"xfs_metadump and\nreport it to linux-xfs@vger.kernel.org.\n");
 	va_end(ap);
 }

@@ -756,4 +801,3 @@ libxfs_zero_extent(

 	return libxfs_device_zero(xfs_find_bdev_for_inode(ip), sector, size);
 }
-
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_alloc_btree.c package_partclone/src/xfs/libxfs/xfs_alloc_btree.c
--- package_partclone_orig/src/xfs/libxfs/xfs_alloc_btree.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_alloc_btree.c	2019-11-12 13:59:47.909149883 -0300
@@ -116,6 +116,8 @@ xfs_allocbt_free_block(
 	xfs_extent_busy_insert(cur->bc_tp, be32_to_cpu(agf->agf_seqno), bno, 1,
 			      XFS_EXTENT_BUSY_SKIP_DISCARD);
 	xfs_trans_agbtree_delta(cur->bc_tp, -1);
+
+	xfs_trans_binval(cur->bc_tp, bp);
 	return 0;
 }

@@ -210,6 +212,17 @@ xfs_allocbt_init_key_from_rec(
 }

 STATIC void
+xfs_allocbt_init_rec_from_key(
+	union xfs_btree_key	*key,
+	union xfs_btree_rec	*rec)
+{
+	ASSERT(key->alloc.ar_startblock != 0);
+
+	rec->alloc.ar_startblock = key->alloc.ar_startblock;
+	rec->alloc.ar_blockcount = key->alloc.ar_blockcount;
+}
+
+STATIC void
 xfs_allocbt_init_rec_from_cur(
 	struct xfs_btree_cur	*cur,
 	union xfs_btree_rec	*rec)
@@ -397,6 +410,7 @@ static const struct xfs_btree_ops xfs_al
 	.get_minrecs		= xfs_allocbt_get_minrecs,
 	.get_maxrecs		= xfs_allocbt_get_maxrecs,
 	.init_key_from_rec	= xfs_allocbt_init_key_from_rec,
+	.init_rec_from_key	= xfs_allocbt_init_rec_from_key,
 	.init_rec_from_cur	= xfs_allocbt_init_rec_from_cur,
 	.init_ptr_from_cur	= xfs_allocbt_init_ptr_from_cur,
 	.key_diff		= xfs_allocbt_key_diff,
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_alloc.c package_partclone/src/xfs/libxfs/xfs_alloc.c
--- package_partclone_orig/src/xfs/libxfs/xfs_alloc.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_alloc.c	2019-11-12 13:59:47.910149883 -0300
@@ -24,16 +24,13 @@
 #include "xfs_bit.h"
 #include "xfs_sb.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_btree.h"
-#include "xfs_rmap.h"
 #include "xfs_alloc_btree.h"
 #include "xfs_alloc.h"
 #include "xfs_cksum.h"
 #include "xfs_trace.h"
 #include "xfs_trans.h"
-#include "xfs_ag_resv.h"

 struct workqueue_struct *xfs_alloc_wq;

@@ -48,88 +45,6 @@ STATIC int xfs_alloc_ag_vextent_size(xfs
 STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,
 		xfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);

-unsigned int
-xfs_refc_block(
-	struct xfs_mount	*mp)
-{
-	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
-		return XFS_RMAP_BLOCK(mp) + 1;
-	if (xfs_sb_version_hasfinobt(&mp->m_sb))
-		return XFS_FIBT_BLOCK(mp) + 1;
-	return XFS_IBT_BLOCK(mp) + 1;
-}
-
-xfs_extlen_t
-xfs_prealloc_blocks(
-	struct xfs_mount	*mp)
-{
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		return xfs_refc_block(mp) + 1;
-	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
-		return XFS_RMAP_BLOCK(mp) + 1;
-	if (xfs_sb_version_hasfinobt(&mp->m_sb))
-		return XFS_FIBT_BLOCK(mp) + 1;
-	return XFS_IBT_BLOCK(mp) + 1;
-}
-
-/*
- * In order to avoid ENOSPC-related deadlock caused by out-of-order locking of
- * AGF buffer (PV 947395), we place constraints on the relationship among
- * actual allocations for data blocks, freelist blocks, and potential file data
- * bmap btree blocks. However, these restrictions may result in no actual space
- * allocated for a delayed extent, for example, a data block in a certain AG is
- * allocated but there is no additional block for the additional bmap btree
- * block due to a split of the bmap btree of the file. The result of this may
- * lead to an infinite loop when the file gets flushed to disk and all delayed
- * extents need to be actually allocated. To get around this, we explicitly set
- * aside a few blocks which will not be reserved in delayed allocation.
- *
- * We need to reserve 4 fsbs _per AG_ for the freelist and 4 more to handle a
- * potential split of the file's bmap btree.
- */
-unsigned int
-xfs_alloc_set_aside(
-	struct xfs_mount	*mp)
-{
-	unsigned int		blocks;
-
-	blocks = 4 + (mp->m_sb.sb_agcount * XFS_ALLOC_AGFL_RESERVE);
-	return blocks;
-}
-
-/*
- * When deciding how much space to allocate out of an AG, we limit the
- * allocation maximum size to the size the AG. However, we cannot use all the
- * blocks in the AG - some are permanently used by metadata. These
- * blocks are generally:
- *	- the AG superblock, AGF, AGI and AGFL
- *	- the AGF (bno and cnt) and AGI btree root blocks, and optionally
- *	  the AGI free inode and rmap btree root blocks.
- *	- blocks on the AGFL according to xfs_alloc_set_aside() limits
- *	- the rmapbt root block
- *
- * The AG headers are sector sized, so the amount of space they take up is
- * dependent on filesystem geometry. The others are all single blocks.
- */
-unsigned int
-xfs_alloc_ag_max_usable(
-	struct xfs_mount	*mp)
-{
-	unsigned int		blocks;
-
-	blocks = XFS_BB_TO_FSB(mp, XFS_FSS_TO_BB(mp, 4)); /* ag headers */
-	blocks += XFS_ALLOC_AGFL_RESERVE;
-	blocks += 3;			/* AGF, AGI btree root blocks */
-	if (xfs_sb_version_hasfinobt(&mp->m_sb))
-		blocks++;		/* finobt root block */
-	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
-		blocks++; 		/* rmap root block */
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		blocks++;		/* refcount root block */
-
-	return mp->m_sb.sb_agblocks - blocks;
-}
-
 /*
  * Lookup the record equal to [bno, len] in the btree given by cur.
  */
@@ -165,7 +80,7 @@ xfs_alloc_lookup_ge(
  * Lookup the first record less than or equal to [bno, len]
  * in the btree given by cur.
  */
-static int				/* error */
+int					/* error */
 xfs_alloc_lookup_le(
 	struct xfs_btree_cur	*cur,	/* btree cursor */
 	xfs_agblock_t		bno,	/* starting block of extent */
@@ -269,7 +184,7 @@ xfs_alloc_compute_diff(
 	xfs_agblock_t	wantbno,	/* target starting block */
 	xfs_extlen_t	wantlen,	/* target length */
 	xfs_extlen_t	alignment,	/* target alignment */
-	int		datatype,	/* are we allocating data? */
+	char		userdata,	/* are we allocating data? */
 	xfs_agblock_t	freebno,	/* freespace's starting block */
 	xfs_extlen_t	freelen,	/* freespace's length */
 	xfs_agblock_t	*newbnop)	/* result: best start block from free */
@@ -280,7 +195,6 @@ xfs_alloc_compute_diff(
 	xfs_extlen_t	newlen1=0;	/* length with newbno1 */
 	xfs_extlen_t	newlen2=0;	/* length with newbno2 */
 	xfs_agblock_t	wantend;	/* end of target extent */
-	bool		userdata = xfs_alloc_is_userdata(datatype);

 	ASSERT(freelen >= wantlen);
 	freeend = freebno + freelen;
@@ -685,29 +599,12 @@ xfs_alloc_ag_vextent(
 	xfs_alloc_arg_t	*args)	/* argument structure for allocation */
 {
 	int		error=0;
-	xfs_extlen_t	reservation;
-	xfs_extlen_t	oldmax;

 	ASSERT(args->minlen > 0);
 	ASSERT(args->maxlen > 0);
 	ASSERT(args->minlen <= args->maxlen);
 	ASSERT(args->mod < args->prod);
 	ASSERT(args->alignment > 0);
-
-	/*
-	 * Clamp maxlen to the amount of free space minus any reservations
-	 * that have been made.
-	 */
-	oldmax = args->maxlen;
-	reservation = xfs_ag_resv_needed(args->pag, args->resv);
-	if (args->maxlen > args->pag->pagf_freeblks - reservation)
-		args->maxlen = args->pag->pagf_freeblks - reservation;
-	if (args->maxlen == 0) {
-		args->agbno = NULLAGBLOCK;
-		args->maxlen = oldmax;
-		return 0;
-	}
-
 	/*
 	 * Branch to correct routine based on the type.
 	 */
@@ -727,24 +624,14 @@ xfs_alloc_ag_vextent(
 		/* NOTREACHED */
 	}

-	args->maxlen = oldmax;
-
 	if (error || args->agbno == NULLAGBLOCK)
 		return error;

 	ASSERT(args->len >= args->minlen);
 	ASSERT(args->len <= args->maxlen);
-	ASSERT(!args->wasfromfl || args->resv != XFS_AG_RESV_AGFL);
+	ASSERT(!args->wasfromfl || !args->isfl);
 	ASSERT(args->agbno % args->alignment == 0);

-	/* if not file data, insert new block into the reverse map btree */
-	if (args->oinfo.oi_owner != XFS_RMAP_OWN_UNKNOWN) {
-		error = xfs_rmap_alloc(args->tp, args->agbp, args->agno,
-				       args->agbno, args->len, &args->oinfo);
-		if (error)
-			return error;
-	}
-
 	if (!args->wasfromfl) {
 		error = xfs_alloc_update_counters(args->tp, args->pag,
 						  args->agbp,
@@ -756,7 +643,12 @@ xfs_alloc_ag_vextent(
 					      args->agbno, args->len));
 	}

-	xfs_ag_resv_alloc_extent(args->pag, args->resv, args);
+	if (!args->isfl) {
+		xfs_trans_mod_sb(args->tp, args->wasdel ?
+				 XFS_TRANS_SB_RES_FDBLOCKS :
+				 XFS_TRANS_SB_FDBLOCKS,
+				 -((long)(args->len)));
+	}

 	XFS_STATS_INC(args->mp, xs_allocx);
 	XFS_STATS_ADD(args->mp, xs_allocb, args->len);
@@ -936,7 +828,7 @@ xfs_alloc_find_best_extent(

 			sdiff = xfs_alloc_compute_diff(args->agbno, args->len,
 						       args->alignment,
-						       args->datatype, *sbnoa,
+						       args->userdata, *sbnoa,
 						       *slena, &new);

 			/*
@@ -1120,7 +1012,7 @@ restart:
 			if (args->len < blen)
 				continue;
 			ltdiff = xfs_alloc_compute_diff(args->agbno, args->len,
-				args->alignment, args->datatype, ltbnoa,
+				args->alignment, args->userdata, ltbnoa,
 				ltlena, &ltnew);
 			if (ltnew != NULLAGBLOCK &&
 			    (args->len > blen || ltdiff < bdiff)) {
@@ -1273,7 +1165,7 @@ restart:
 			args->len = XFS_EXTLEN_MIN(ltlena, args->maxlen);
 			xfs_alloc_fix_len(args);
 			ltdiff = xfs_alloc_compute_diff(args->agbno, args->len,
-				args->alignment, args->datatype, ltbnoa,
+				args->alignment, args->userdata, ltbnoa,
 				ltlena, &ltnew);

 			error = xfs_alloc_find_best_extent(args,
@@ -1290,7 +1182,7 @@ restart:
 			args->len = XFS_EXTLEN_MIN(gtlena, args->maxlen);
 			xfs_alloc_fix_len(args);
 			gtdiff = xfs_alloc_compute_diff(args->agbno, args->len,
-				args->alignment, args->datatype, gtbnoa,
+				args->alignment, args->userdata, gtbnoa,
 				gtlena, &gtnew);

 			error = xfs_alloc_find_best_extent(args,
@@ -1350,7 +1242,7 @@ restart:
 	}
 	rlen = args->len;
 	(void)xfs_alloc_compute_diff(args->agbno, rlen, args->alignment,
-				     args->datatype, ltbnoa, ltlena, &ltnew);
+				     args->userdata, ltbnoa, ltlena, &ltnew);
 	ASSERT(ltnew >= ltbno);
 	ASSERT(ltnew + rlen <= ltbnoa + ltlena);
 	ASSERT(ltnew + rlen <= be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_length));
@@ -1601,8 +1493,6 @@ xfs_alloc_ag_vextent_small(
 	xfs_extlen_t	*flenp,	/* result length */
 	int		*stat)	/* status: 0-freelist, 1-normal/none */
 {
-	struct xfs_owner_info	oinfo;
-	struct xfs_perag	*pag;
 	int		error;
 	xfs_agblock_t	fbno;
 	xfs_extlen_t	flen;
@@ -1620,8 +1510,7 @@ xfs_alloc_ag_vextent_small(
 	 * to respect minleft even when pulling from the
 	 * freelist.
 	 */
-	else if (args->minlen == 1 && args->alignment == 1 &&
-		 args->resv != XFS_AG_RESV_AGFL &&
+	else if (args->minlen == 1 && args->alignment == 1 && !args->isfl &&
 		 (be32_to_cpu(XFS_BUF_TO_AGF(args->agbp)->agf_flcount)
 		  > args->minleft)) {
 		error = xfs_alloc_get_freelist(args->tp, args->agbp, &fbno, 0);
@@ -1629,9 +1518,9 @@ xfs_alloc_ag_vextent_small(
 			goto error0;
 		if (fbno != NULLAGBLOCK) {
 			xfs_extent_busy_reuse(args->mp, args->agno, fbno, 1,
-			      xfs_alloc_allow_busy_reuse(args->datatype));
+					     args->userdata);

-			if (xfs_alloc_is_userdata(args->datatype)) {
+			if (args->userdata) {
 				xfs_buf_t	*bp;

 				bp = xfs_btree_get_bufs(args->mp, args->tp,
@@ -1646,23 +1535,6 @@ xfs_alloc_ag_vextent_small(
 				error0);
 			args->wasfromfl = 1;
 			trace_xfs_alloc_small_freelist(args);
-
-			/*
-			 * If we're feeding an AGFL block to something that
-			 * doesn't live in the free space, we need to clear
-			 * out the OWN_AG rmap and add the block back to
-			 * the AGFL per-AG reservation.
-			 */
-			xfs_rmap_ag_owner(&oinfo, XFS_RMAP_OWN_AG);
-			error = xfs_rmap_free(args->tp, args->agbp, args->agno,
-					fbno, 1, &oinfo);
-			if (error)
-				goto error0;
-			pag = xfs_perag_get(args->mp, args->agno);
-			xfs_ag_resv_free_extent(pag, XFS_AG_RESV_AGFL,
-					args->tp, 1);
-			xfs_perag_put(pag);
-
 			*stat = 0;
 			return 0;
 		}
@@ -1701,15 +1573,14 @@ error0:
 /*
  * Free the extent starting at agno/bno for length.
  */
-STATIC int
+STATIC int			/* error */
 xfs_free_ag_extent(
-	xfs_trans_t		*tp,
-	xfs_buf_t		*agbp,
-	xfs_agnumber_t		agno,
-	xfs_agblock_t		bno,
-	xfs_extlen_t		len,
-	struct xfs_owner_info	*oinfo,
-	enum xfs_ag_resv_type	type)
+	xfs_trans_t	*tp,	/* transaction pointer */
+	xfs_buf_t	*agbp,	/* buffer for a.g. freelist header */
+	xfs_agnumber_t	agno,	/* allocation group number */
+	xfs_agblock_t	bno,	/* starting block number */
+	xfs_extlen_t	len,	/* length of extent */
+	int		isfl)	/* set if is freelist blocks - no sb acctg */
 {
 	xfs_btree_cur_t	*bno_cur;	/* cursor for by-block btree */
 	xfs_btree_cur_t	*cnt_cur;	/* cursor for by-size btree */
@@ -1726,19 +1597,12 @@ xfs_free_ag_extent(
 	xfs_extlen_t	nlen;		/* new length of freespace */
 	xfs_perag_t	*pag;		/* per allocation group data */

-	bno_cur = cnt_cur = NULL;
 	mp = tp->t_mountp;
-
-	if (oinfo->oi_owner != XFS_RMAP_OWN_UNKNOWN) {
-		error = xfs_rmap_free(tp, agbp, agno, bno, len, oinfo);
-		if (error)
-			goto error0;
-	}
-
 	/*
 	 * Allocate and initialize a cursor for the by-block btree.
 	 */
 	bno_cur = xfs_allocbt_init_cursor(mp, tp, agbp, agno, XFS_BTNUM_BNO);
+	cnt_cur = NULL;
 	/*
 	 * Look for a neighboring block on the left (lower block numbers)
 	 * that is contiguous with this space.
@@ -1937,22 +1801,21 @@ xfs_free_ag_extent(
 	 */
 	pag = xfs_perag_get(mp, agno);
 	error = xfs_alloc_update_counters(tp, pag, agbp, len);
-	xfs_ag_resv_free_extent(pag, type, tp, len);
 	xfs_perag_put(pag);
 	if (error)
 		goto error0;

+	if (!isfl)
+		xfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, (long)len);
 	XFS_STATS_INC(mp, xs_freex);
 	XFS_STATS_ADD(mp, xs_freeb, len);

-	trace_xfs_free_extent(mp, agno, bno, len, type == XFS_AG_RESV_AGFL,
-			haveleft, haveright);
+	trace_xfs_free_extent(mp, agno, bno, len, isfl, haveleft, haveright);

 	return 0;

  error0:
-	trace_xfs_free_extent(mp, agno, bno, len, type == XFS_AG_RESV_AGFL,
-			-1, -1);
+	trace_xfs_free_extent(mp, agno, bno, len, isfl, -1, -1);
 	if (bno_cur)
 		xfs_btree_del_cursor(bno_cur, XFS_BTREE_ERROR);
 	if (cnt_cur)
@@ -1972,48 +1835,37 @@ void
 xfs_alloc_compute_maxlevels(
 	xfs_mount_t	*mp)	/* file system mount structure */
 {
-	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp, mp->m_alloc_mnr,
-			(mp->m_sb.sb_agblocks + 1) / 2);
+	int		level;
+	uint		maxblocks;
+	uint		maxleafents;
+	int		minleafrecs;
+	int		minnoderecs;
+
+	maxleafents = (mp->m_sb.sb_agblocks + 1) / 2;
+	minleafrecs = mp->m_alloc_mnr[0];
+	minnoderecs = mp->m_alloc_mnr[1];
+	maxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;
+	for (level = 1; maxblocks > 1; level++)
+		maxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;
+	mp->m_ag_maxlevels = level;
 }

 /*
- * Find the length of the longest extent in an AG.  The 'need' parameter
- * specifies how much space we're going to need for the AGFL and the
- * 'reserved' parameter tells us how many blocks in this AG are reserved for
- * other callers.
+ * Find the length of the longest extent in an AG.
  */
 xfs_extlen_t
 xfs_alloc_longest_free_extent(
 	struct xfs_mount	*mp,
 	struct xfs_perag	*pag,
-	xfs_extlen_t		need,
-	xfs_extlen_t		reserved)
+	xfs_extlen_t		need)
 {
 	xfs_extlen_t		delta = 0;

-	/*
-	 * If the AGFL needs a recharge, we'll have to subtract that from the
-	 * longest extent.
-	 */
 	if (need > pag->pagf_flcount)
 		delta = need - pag->pagf_flcount;

-	/*
-	 * If we cannot maintain others' reservations with space from the
-	 * not-longest freesp extents, we'll have to subtract /that/ from
-	 * the longest extent too.
-	 */
-	if (pag->pagf_freeblks - pag->pagf_longest < reserved)
-		delta += reserved - (pag->pagf_freeblks - pag->pagf_longest);
-
-	/*
-	 * If the longest extent is long enough to satisfy all the
-	 * reservations and AGFL rules in place, we can return this extent.
-	 */
 	if (pag->pagf_longest > delta)
 		return pag->pagf_longest - delta;
-
-	/* Otherwise, let the caller try for 1 block if there's space. */
 	return pag->pagf_flcount > 0 || pag->pagf_longest > 0;
 }

@@ -2030,11 +1882,6 @@ xfs_alloc_min_freelist(
 	/* space needed by-size freespace btree */
 	min_free += min_t(unsigned int, pag->pagf_levels[XFS_BTNUM_CNTi] + 1,
 				       mp->m_ag_maxlevels);
-	/* space needed reverse mapping used space btree */
-	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
-		min_free += min_t(unsigned int,
-				  pag->pagf_levels[XFS_BTNUM_RMAPi] + 1,
-				  mp->m_rmap_maxlevels);

 	return min_free;
 }
@@ -2053,24 +1900,20 @@ xfs_alloc_space_available(
 {
 	struct xfs_perag	*pag = args->pag;
 	xfs_extlen_t		longest;
-	xfs_extlen_t		reservation; /* blocks that are still reserved */
 	int			available;

 	if (flags & XFS_ALLOC_FLAG_FREEING)
 		return true;

-	reservation = xfs_ag_resv_needed(pag, args->resv);
-
 	/* do we have enough contiguous free space for the allocation? */
-	longest = xfs_alloc_longest_free_extent(args->mp, pag, min_free,
-			reservation);
+	longest = xfs_alloc_longest_free_extent(args->mp, pag, min_free);
 	if ((args->minlen + args->alignment + args->minalignslop - 1) > longest)
 		return false;

-	/* do we have enough free space remaining for the allocation? */
+	/* do have enough free space remaining for the allocation? */
 	available = (int)(pag->pagf_freeblks + pag->pagf_flcount -
-			  reservation - min_free - args->total);
-	if (available < (int)args->minleft || available <= 0)
+			  min_free - args->total);
+	if (available < (int)args->minleft)
 		return false;

 	return true;
@@ -2111,7 +1954,7 @@ xfs_alloc_fix_freelist(
 	 * somewhere else if we are not being asked to try harder at this
 	 * point
 	 */
-	if (pag->pagf_metadata && xfs_alloc_is_userdata(args->datatype) &&
+	if (pag->pagf_metadata && args->userdata &&
 	    (flags & XFS_ALLOC_FLAG_TRYLOCK)) {
 		ASSERT(!(flags & XFS_ALLOC_FLAG_FREEING));
 		goto out_agbp_relse;
@@ -2156,39 +1999,26 @@ xfs_alloc_fix_freelist(
 	 * anything other than extra overhead when we need to put more blocks
 	 * back on the free list? Maybe we should only do this when space is
 	 * getting low or the AGFL is more than half full?
-	 *
-	 * The NOSHRINK flag prevents the AGFL from being shrunk if it's too
-	 * big; the NORMAP flag prevents AGFL expand/shrink operations from
-	 * updating the rmapbt.  Both flags are used in xfs_repair while we're
-	 * rebuilding the rmapbt, and neither are used by the kernel.  They're
-	 * both required to ensure that rmaps are correctly recorded for the
-	 * regenerated AGFL, bnobt, and cntbt.  See repair/phase5.c and
-	 * repair/rmap.c in xfsprogs for details.
 	 */
-	memset(&targs, 0, sizeof(targs));
-	if (flags & XFS_ALLOC_FLAG_NORMAP)
-		xfs_rmap_skip_owner_update(&targs.oinfo);
-	else
-		xfs_rmap_ag_owner(&targs.oinfo, XFS_RMAP_OWN_AG);
-	while (!(flags & XFS_ALLOC_FLAG_NOSHRINK) && pag->pagf_flcount > need) {
+	while (pag->pagf_flcount > need) {
 		struct xfs_buf	*bp;

 		error = xfs_alloc_get_freelist(tp, agbp, &bno, 0);
 		if (error)
 			goto out_agbp_relse;
-		error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1,
-					   &targs.oinfo, XFS_AG_RESV_AGFL);
+		error = xfs_free_ag_extent(tp, agbp, args->agno, bno, 1, 1);
 		if (error)
 			goto out_agbp_relse;
 		bp = xfs_btree_get_bufs(mp, tp, args->agno, bno, 0);
 		xfs_trans_binval(tp, bp);
 	}

+	memset(&targs, 0, sizeof(targs));
 	targs.tp = tp;
 	targs.mp = mp;
 	targs.agbp = agbp;
 	targs.agno = args->agno;
-	targs.alignment = targs.minlen = targs.prod = 1;
+	targs.alignment = targs.minlen = targs.prod = targs.isfl = 1;
 	targs.type = XFS_ALLOCTYPE_THIS_AG;
 	targs.pag = pag;
 	error = xfs_alloc_read_agfl(mp, tp, targs.agno, &agflbp);
@@ -2199,7 +2029,6 @@ xfs_alloc_fix_freelist(
 	while (pag->pagf_flcount < need) {
 		targs.agbno = 0;
 		targs.maxlen = need - pag->pagf_flcount;
-		targs.resv = XFS_AG_RESV_AGFL;

 		/* Allocate as many blocks as possible at once. */
 		error = xfs_alloc_ag_vextent(&targs);
@@ -2331,12 +2160,6 @@ xfs_alloc_log_agf(
 		offsetof(xfs_agf_t, agf_longest),
 		offsetof(xfs_agf_t, agf_btreeblks),
 		offsetof(xfs_agf_t, agf_uuid),
-		offsetof(xfs_agf_t, agf_rmap_blocks),
-		offsetof(xfs_agf_t, agf_refcount_blocks),
-		offsetof(xfs_agf_t, agf_refcount_root),
-		offsetof(xfs_agf_t, agf_refcount_level),
-		/* needed so that we don't log the whole rest of the structure: */
-		offsetof(xfs_agf_t, agf_spare64),
 		sizeof(xfs_agf_t)
 	};

@@ -2455,10 +2278,6 @@ xfs_agf_verify(
 	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)
 		return false;

-	if (xfs_sb_version_hasrmapbt(&mp->m_sb) &&
-	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS)
-		return false;
-
 	/*
 	 * during growfs operations, the perag is not fully initialised,
 	 * so we can't use it for any useful checking. growfs ensures we can't
@@ -2472,10 +2291,6 @@ xfs_agf_verify(
 	    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))
 		return false;

-	if (xfs_sb_version_hasreflink(&mp->m_sb) &&
-	    be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS)
-		return false;
-
 	return true;;

 }
@@ -2594,9 +2409,6 @@ xfs_alloc_read_agf(
 			be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNOi]);
 		pag->pagf_levels[XFS_BTNUM_CNTi] =
 			be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNTi]);
-		pag->pagf_levels[XFS_BTNUM_RMAPi] =
-			be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAPi]);
-		pag->pagf_refcount_level = be32_to_cpu(agf->agf_refcount_level);
 		spin_lock_init(&pag->pagb_lock);
 		pag->pagb_count = 0;
 		/* XXX: pagb_tree doesn't exist in userspace */
@@ -2696,7 +2508,7 @@ xfs_alloc_vextent(
 		 * Try near allocation first, then anywhere-in-ag after
 		 * the first a.g. fails.
 		 */
-		if ((args->datatype & XFS_ALLOC_INITIAL_USER_DATA) &&
+		if ((args->userdata & XFS_ALLOC_INITIAL_USER_DATA) &&
 		    (mp->m_flags & XFS_MOUNT_32BITINODES)) {
 			args->fsbno = XFS_AGB_TO_FSB(mp,
 					((mp->m_agfrotor / rotorstep) %
@@ -2829,7 +2641,7 @@ xfs_alloc_vextent(
 #endif

 		/* Zero the extent if we were asked to do so */
-		if (args->datatype & XFS_ALLOC_USERDATA_ZERO) {
+		if (args->userdata & XFS_ALLOC_USERDATA_ZERO) {
 			error = xfs_zero_extent(args->ip, args->fsbno, args->len);
 			if (error)
 				goto error0;
@@ -2843,87 +2655,55 @@ error0:
 	return error;
 }

-/* Ensure that the freelist is at full capacity. */
-int
-xfs_free_extent_fix_freelist(
-	struct xfs_trans	*tp,
-	xfs_agnumber_t		agno,
-	struct xfs_buf		**agbp)
+/*
+ * Free an extent.
+ * Just break up the extent address and hand off to xfs_free_ag_extent
+ * after fixing up the freelist.
+ */
+int				/* error */
+xfs_free_extent(
+	xfs_trans_t	*tp,	/* transaction pointer */
+	xfs_fsblock_t	bno,	/* starting block number of extent */
+	xfs_extlen_t	len)	/* length of extent */
 {
-	struct xfs_alloc_arg	args;
-	int			error;
+	xfs_alloc_arg_t	args;
+	int		error;

-	memset(&args, 0, sizeof(struct xfs_alloc_arg));
+	ASSERT(len != 0);
+	memset(&args, 0, sizeof(xfs_alloc_arg_t));
 	args.tp = tp;
 	args.mp = tp->t_mountp;
-	args.agno = agno;

 	/*
 	 * validate that the block number is legal - the enables us to detect
 	 * and handle a silent filesystem corruption rather than crashing.
 	 */
+	args.agno = XFS_FSB_TO_AGNO(args.mp, bno);
 	if (args.agno >= args.mp->m_sb.sb_agcount)
 		return -EFSCORRUPTED;

+	args.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);
+	if (args.agbno >= args.mp->m_sb.sb_agblocks)
+		return -EFSCORRUPTED;
+
 	args.pag = xfs_perag_get(args.mp, args.agno);
 	ASSERT(args.pag);

 	error = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);
 	if (error)
-		goto out;
-
-	*agbp = args.agbp;
-out:
-	xfs_perag_put(args.pag);
-	return error;
-}
-
-/*
- * Free an extent.
- * Just break up the extent address and hand off to xfs_free_ag_extent
- * after fixing up the freelist.
- */
-int				/* error */
-xfs_free_extent(
-	struct xfs_trans	*tp,	/* transaction pointer */
-	xfs_fsblock_t		bno,	/* starting block number of extent */
-	xfs_extlen_t		len,	/* length of extent */
-	struct xfs_owner_info	*oinfo,	/* extent owner */
-	enum xfs_ag_resv_type	type)	/* block reservation type */
-{
-	struct xfs_mount	*mp = tp->t_mountp;
-	struct xfs_buf		*agbp;
-	xfs_agnumber_t		agno = XFS_FSB_TO_AGNO(mp, bno);
-	xfs_agblock_t		agbno = XFS_FSB_TO_AGBNO(mp, bno);
-	int			error;
-
-	ASSERT(len != 0);
-	ASSERT(type != XFS_AG_RESV_AGFL);
-
-	if (XFS_TEST_ERROR(false, mp,
-			XFS_ERRTAG_FREE_EXTENT,
-			XFS_RANDOM_FREE_EXTENT))
-		return -EIO;
-
-	error = xfs_free_extent_fix_freelist(tp, agno, &agbp);
-	if (error)
-		return error;
-
-	XFS_WANT_CORRUPTED_GOTO(mp, agbno < mp->m_sb.sb_agblocks, err);
+		goto error0;

 	/* validate the extent size is legal now we have the agf locked */
-	XFS_WANT_CORRUPTED_GOTO(mp,
-		agbno + len <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_length),
-				err);
-
-	error = xfs_free_ag_extent(tp, agbp, agno, agbno, len, oinfo, type);
-	if (error)
-		goto err;
-
-	xfs_extent_busy_insert(tp, agno, agbno, len, 0);
-	return 0;
+	if (args.agbno + len >
+			be32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {
+		error = -EFSCORRUPTED;
+		goto error0;
+	}

-err:
-	xfs_trans_brelse(tp, agbp);
+	error = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);
+	if (!error)
+		xfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);
+error0:
+	xfs_perag_put(args.pag);
 	return error;
 }
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_alloc.h package_partclone/src/xfs/libxfs/xfs_alloc.h
--- package_partclone_orig/src/xfs/libxfs/xfs_alloc.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_alloc.h	2019-11-12 13:59:47.910149883 -0300
@@ -54,8 +54,41 @@ typedef unsigned int xfs_alloctype_t;
  */
 #define	XFS_ALLOC_FLAG_TRYLOCK	0x00000001  /* use trylock for buffer locking */
 #define	XFS_ALLOC_FLAG_FREEING	0x00000002  /* indicate caller is freeing extents*/
-#define	XFS_ALLOC_FLAG_NORMAP	0x00000004  /* don't modify the rmapbt */
-#define	XFS_ALLOC_FLAG_NOSHRINK	0x00000008  /* don't shrink the freelist */
+
+/*
+ * In order to avoid ENOSPC-related deadlock caused by
+ * out-of-order locking of AGF buffer (PV 947395), we place
+ * constraints on the relationship among actual allocations for
+ * data blocks, freelist blocks, and potential file data bmap
+ * btree blocks. However, these restrictions may result in no
+ * actual space allocated for a delayed extent, for example, a data
+ * block in a certain AG is allocated but there is no additional
+ * block for the additional bmap btree block due to a split of the
+ * bmap btree of the file. The result of this may lead to an
+ * infinite loop in xfssyncd when the file gets flushed to disk and
+ * all delayed extents need to be actually allocated. To get around
+ * this, we explicitly set aside a few blocks which will not be
+ * reserved in delayed allocation. Considering the minimum number of
+ * needed freelist blocks is 4 fsbs _per AG_, a potential split of file's bmap
+ * btree requires 1 fsb, so we set the number of set-aside blocks
+ * to 4 + 4*agcount.
+ */
+#define XFS_ALLOC_SET_ASIDE(mp)  (4 + ((mp)->m_sb.sb_agcount * 4))
+
+/*
+ * When deciding how much space to allocate out of an AG, we limit the
+ * allocation maximum size to the size the AG. However, we cannot use all the
+ * blocks in the AG - some are permanently used by metadata. These
+ * blocks are generally:
+ *	- the AG superblock, AGF, AGI and AGFL
+ *	- the AGF (bno and cnt) and AGI btree root blocks
+ *	- 4 blocks on the AGFL according to XFS_ALLOC_SET_ASIDE() limits
+ *
+ * The AG headers are sector sized, so the amount of space they take up is
+ * dependent on filesystem geometry. The others are all single blocks.
+ */
+#define XFS_ALLOC_AG_MAX_USABLE(mp)	\
+	((mp)->m_sb.sb_agblocks - XFS_BB_TO_FSB(mp, XFS_FSS_TO_BB(mp, 4)) - 7)


 /*
@@ -85,42 +118,22 @@ typedef struct xfs_alloc_arg {
 	xfs_extlen_t	len;		/* output: actual size of extent */
 	xfs_alloctype_t	type;		/* allocation type XFS_ALLOCTYPE_... */
 	xfs_alloctype_t	otype;		/* original allocation type */
-	int		datatype;	/* mask defining data type treatment */
 	char		wasdel;		/* set if allocation was prev delayed */
 	char		wasfromfl;	/* set if allocation is from freelist */
+	char		isfl;		/* set if is freelist blocks - !acctg */
+	char		userdata;	/* mask defining userdata treatment */
 	xfs_fsblock_t	firstblock;	/* io first block allocated */
-	struct xfs_owner_info	oinfo;	/* owner of blocks being allocated */
-	enum xfs_ag_resv_type	resv;	/* block reservation to use */
 } xfs_alloc_arg_t;

 /*
- * Defines for datatype
+ * Defines for userdata
  */
 #define XFS_ALLOC_USERDATA		(1 << 0)/* allocation is for user data*/
 #define XFS_ALLOC_INITIAL_USER_DATA	(1 << 1)/* special case start of file */
 #define XFS_ALLOC_USERDATA_ZERO		(1 << 2)/* zero extent on allocation */
-#define XFS_ALLOC_NOBUSY		(1 << 3)/* Busy extents not allowed */
-
-static inline bool
-xfs_alloc_is_userdata(int datatype)
-{
-	return (datatype & ~XFS_ALLOC_NOBUSY) != 0;
-}
-
-static inline bool
-xfs_alloc_allow_busy_reuse(int datatype)
-{
-	return (datatype & XFS_ALLOC_NOBUSY) == 0;
-}
-
-/* freespace limit calculations */
-#define XFS_ALLOC_AGFL_RESERVE	4
-unsigned int xfs_alloc_set_aside(struct xfs_mount *mp);
-unsigned int xfs_alloc_ag_max_usable(struct xfs_mount *mp);

 xfs_extlen_t xfs_alloc_longest_free_extent(struct xfs_mount *mp,
-		struct xfs_perag *pag, xfs_extlen_t need,
-		xfs_extlen_t reserved);
+		struct xfs_perag *pag, xfs_extlen_t need);
 unsigned int xfs_alloc_min_freelist(struct xfs_mount *mp,
 		struct xfs_perag *pag);

@@ -195,11 +208,16 @@ xfs_alloc_vextent(
  */
 int				/* error */
 xfs_free_extent(
-	struct xfs_trans	*tp,	/* transaction pointer */
-	xfs_fsblock_t		bno,	/* starting block number of extent */
+	struct xfs_trans *tp,	/* transaction pointer */
+	xfs_fsblock_t	bno,	/* starting block number of extent */
+	xfs_extlen_t	len);	/* length of extent */
+
+int					/* error */
+xfs_alloc_lookup_le(
+	struct xfs_btree_cur	*cur,	/* btree cursor */
+	xfs_agblock_t		bno,	/* starting block of extent */
 	xfs_extlen_t		len,	/* length of extent */
-	struct xfs_owner_info	*oinfo,	/* extent owner */
-	enum xfs_ag_resv_type	type);	/* block reservation type */
+	int			*stat);	/* success/failure */

 int				/* error */
 xfs_alloc_lookup_ge(
@@ -218,9 +236,5 @@ xfs_alloc_get_rec(
 int xfs_read_agf(struct xfs_mount *mp, struct xfs_trans *tp,
 			xfs_agnumber_t agno, int flags, struct xfs_buf **bpp);
 int xfs_alloc_fix_freelist(struct xfs_alloc_arg *args, int flags);
-int xfs_free_extent_fix_freelist(struct xfs_trans *tp, xfs_agnumber_t agno,
-		struct xfs_buf **agbp);
-
-xfs_extlen_t xfs_prealloc_blocks(struct xfs_mount *mp);

 #endif	/* __XFS_ALLOC_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_attr.c package_partclone/src/xfs/libxfs/xfs_attr.c
--- package_partclone_orig/src/xfs/libxfs/xfs_attr.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_attr.c	2019-11-12 13:59:47.911149883 -0300
@@ -23,7 +23,6 @@
 #include "xfs_trans_resv.h"
 #include "xfs_bit.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_da_format.h"
 #include "xfs_da_btree.h"
 #include "xfs_attr_sf.h"
@@ -197,7 +196,7 @@ xfs_attr_set(
 {
 	struct xfs_mount	*mp = dp->i_mount;
 	struct xfs_da_args	args;
-	struct xfs_defer_ops	dfops;
+	struct xfs_bmap_free	flist;
 	struct xfs_trans_res	tres;
 	xfs_fsblock_t		firstblock;
 	int			rsvd = (flags & ATTR_ROOT) != 0;
@@ -215,7 +214,7 @@ xfs_attr_set(
 	args.value = value;
 	args.valuelen = valuelen;
 	args.firstblock = &firstblock;
-	args.dfops = &dfops;
+	args.flist = &flist;
 	args.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;
 	args.total = xfs_attr_calc_size(&args, &local);

@@ -236,21 +235,37 @@ xfs_attr_set(
 			return error;
 	}

-	tres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +
-			 M_RES(mp)->tr_attrsetrt.tr_logres * args.total;
-	tres.tr_logcount = XFS_ATTRSET_LOG_COUNT;
-	tres.tr_logflags = XFS_TRANS_PERM_LOG_RES;
+	/*
+	 * Start our first transaction of the day.
+	 *
+	 * All future transactions during this code must be "chained" off
+	 * this one via the trans_dup() call.  All transactions will contain
+	 * the inode, and the inode will always be marked with trans_ihold().
+	 * Since the inode will be locked in all transactions, we must log
+	 * the inode in every transaction to let it float upward through
+	 * the log.
+	 */
+	args.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);

 	/*
 	 * Root fork attributes can use reserved data blocks for this
 	 * operation if necessary
 	 */
-	error = xfs_trans_alloc(mp, &tres, args.total, 0,
-			rsvd ? XFS_TRANS_RESERVE : 0, &args.trans);
-	if (error)
-		return error;

+	if (rsvd)
+		args.trans->t_flags |= XFS_TRANS_RESERVE;
+
+	tres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +
+			 M_RES(mp)->tr_attrsetrt.tr_logres * args.total;
+	tres.tr_logcount = XFS_ATTRSET_LOG_COUNT;
+	tres.tr_logflags = XFS_TRANS_PERM_LOG_RES;
+	error = xfs_trans_reserve(args.trans, &tres, args.total, 0);
+	if (error) {
+		xfs_trans_cancel(args.trans);
+		return error;
+	}
 	xfs_ilock(dp, XFS_ILOCK_EXCL);
+
 	error = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,
 				rsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :
 				       XFS_QMOPT_RES_REGBLKS);
@@ -310,13 +325,13 @@ xfs_attr_set(
 		 * It won't fit in the shortform, transform to a leaf block.
 		 * GROT: another possible req'mt for a double-split btree op.
 		 */
-		xfs_defer_init(args.dfops, args.firstblock);
+		xfs_bmap_init(args.flist, args.firstblock);
 		error = xfs_attr_shortform_to_leaf(&args);
 		if (!error)
-			error = xfs_defer_finish(&args.trans, args.dfops, dp);
+			error = xfs_bmap_finish(&args.trans, args.flist, dp);
 		if (error) {
 			args.trans = NULL;
-			xfs_defer_cancel(&dfops);
+			xfs_bmap_cancel(&flist);
 			goto out;
 		}

@@ -376,7 +391,7 @@ xfs_attr_remove(
 {
 	struct xfs_mount	*mp = dp->i_mount;
 	struct xfs_da_args	args;
-	struct xfs_defer_ops	dfops;
+	struct xfs_bmap_free	flist;
 	xfs_fsblock_t		firstblock;
 	int			error;

@@ -393,7 +408,7 @@ xfs_attr_remove(
 		return error;

 	args.firstblock = &firstblock;
-	args.dfops = &dfops;
+	args.flist = &flist;

 	/*
 	 * we have no control over the attribute names that userspace passes us
@@ -407,15 +422,31 @@ xfs_attr_remove(
 		return error;

 	/*
+	 * Start our first transaction of the day.
+	 *
+	 * All future transactions during this code must be "chained" off
+	 * this one via the trans_dup() call.  All transactions will contain
+	 * the inode, and the inode will always be marked with trans_ihold().
+	 * Since the inode will be locked in all transactions, we must log
+	 * the inode in every transaction to let it float upward through
+	 * the log.
+	 */
+	args.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);
+
+	/*
 	 * Root fork attributes can use reserved data blocks for this
 	 * operation if necessary
 	 */
-	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_attrrm,
-			XFS_ATTRRM_SPACE_RES(mp), 0,
-			(flags & ATTR_ROOT) ? XFS_TRANS_RESERVE : 0,
-			&args.trans);
-	if (error)
+
+	if (flags & ATTR_ROOT)
+		args.trans->t_flags |= XFS_TRANS_RESERVE;
+
+	error = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,
+				  XFS_ATTRRM_SPACE_RES(mp), 0);
+	if (error) {
+		xfs_trans_cancel(args.trans);
 		return error;
+	}

 	xfs_ilock(dp, XFS_ILOCK_EXCL);
 	/*
@@ -578,13 +609,13 @@ xfs_attr_leaf_addname(xfs_da_args_t *arg
 		 * Commit that transaction so that the node_addname() call
 		 * can manage its own transactions.
 		 */
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_attr3_leaf_to_node(args);
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			return error;
 		}

@@ -668,15 +699,15 @@ xfs_attr_leaf_addname(xfs_da_args_t *arg
 		 * If the result is small enough, shrink it all into the inode.
 		 */
 		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
-			xfs_defer_init(args->dfops, args->firstblock);
+			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 			/* bp is gone due to xfs_da_shrink_inode */
 			if (!error)
-				error = xfs_defer_finish(&args->trans,
-							args->dfops, dp);
+				error = xfs_bmap_finish(&args->trans,
+							args->flist, dp);
 			if (error) {
 				args->trans = NULL;
-				xfs_defer_cancel(args->dfops);
+				xfs_bmap_cancel(args->flist);
 				return error;
 			}
 		}
@@ -731,14 +762,14 @@ xfs_attr_leaf_removename(xfs_da_args_t *
 	 * If the result is small enough, shrink it all into the inode.
 	 */
 	if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 		/* bp is gone due to xfs_da_shrink_inode */
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			return error;
 		}
 	}
@@ -857,14 +888,14 @@ restart:
 			 */
 			xfs_da_state_free(state);
 			state = NULL;
-			xfs_defer_init(args->dfops, args->firstblock);
+			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_node(args);
 			if (!error)
-				error = xfs_defer_finish(&args->trans,
-							args->dfops, dp);
+				error = xfs_bmap_finish(&args->trans,
+							args->flist, dp);
 			if (error) {
 				args->trans = NULL;
-				xfs_defer_cancel(args->dfops);
+				xfs_bmap_cancel(args->flist);
 				goto out;
 			}

@@ -885,13 +916,13 @@ restart:
 		 * in the index/blkno/rmtblkno/rmtblkcnt fields and
 		 * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.
 		 */
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_da3_split(state);
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			goto out;
 		}
 	} else {
@@ -984,14 +1015,14 @@ restart:
 		 * Check to see if the tree needs to be collapsed.
 		 */
 		if (retval && (state->path.active > 1)) {
-			xfs_defer_init(args->dfops, args->firstblock);
+			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_da3_join(state);
 			if (!error)
-				error = xfs_defer_finish(&args->trans,
-							args->dfops, dp);
+				error = xfs_bmap_finish(&args->trans,
+							args->flist, dp);
 			if (error) {
 				args->trans = NULL;
-				xfs_defer_cancel(args->dfops);
+				xfs_bmap_cancel(args->flist);
 				goto out;
 			}
 		}
@@ -1107,13 +1138,13 @@ xfs_attr_node_removename(xfs_da_args_t *
 	 * Check to see if the tree needs to be collapsed.
 	 */
 	if (retval && (state->path.active > 1)) {
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_da3_join(state);
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			goto out;
 		}
 		/*
@@ -1140,15 +1171,15 @@ xfs_attr_node_removename(xfs_da_args_t *
 			goto out;

 		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
-			xfs_defer_init(args->dfops, args->firstblock);
+			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 			/* bp is gone due to xfs_da_shrink_inode */
 			if (!error)
-				error = xfs_defer_finish(&args->trans,
-							args->dfops, dp);
+				error = xfs_bmap_finish(&args->trans,
+							args->flist, dp);
 			if (error) {
 				args->trans = NULL;
-				xfs_defer_cancel(args->dfops);
+				xfs_bmap_cancel(args->flist);
 				goto out;
 			}
 		} else
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_attr_leaf.c package_partclone/src/xfs/libxfs/xfs_attr_leaf.c
--- package_partclone_orig/src/xfs/libxfs/xfs_attr_leaf.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_attr_leaf.c	2019-11-12 13:59:47.912149883 -0300
@@ -787,7 +787,7 @@ xfs_attr_shortform_to_leaf(xfs_da_args_t
 	nargs.dp = dp;
 	nargs.geo = args->geo;
 	nargs.firstblock = args->firstblock;
-	nargs.dfops = args->dfops;
+	nargs.flist = args->flist;
 	nargs.total = args->total;
 	nargs.whichfork = XFS_ATTR_FORK;
 	nargs.trans = args->trans;
@@ -917,7 +917,7 @@ xfs_attr3_leaf_to_shortform(
 	nargs.geo = args->geo;
 	nargs.dp = dp;
 	nargs.firstblock = args->firstblock;
-	nargs.dfops = args->dfops;
+	nargs.flist = args->flist;
 	nargs.total = args->total;
 	nargs.whichfork = XFS_ATTR_FORK;
 	nargs.trans = args->trans;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_attr_leaf.h package_partclone/src/xfs/libxfs/xfs_attr_leaf.h
--- package_partclone_orig/src/xfs/libxfs/xfs_attr_leaf.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_attr_leaf.h	2019-11-12 13:59:47.912149883 -0300
@@ -50,6 +50,7 @@ int	xfs_attr_shortform_lookup(struct xfs
 int	xfs_attr_shortform_getvalue(struct xfs_da_args *args);
 int	xfs_attr_shortform_to_leaf(struct xfs_da_args *args);
 int	xfs_attr_shortform_remove(struct xfs_da_args *args);
+int	xfs_attr_shortform_list(struct xfs_attr_list_context *context);
 int	xfs_attr_shortform_allfit(struct xfs_buf *bp, struct xfs_inode *dp);
 int	xfs_attr_shortform_bytesfit(struct xfs_inode *dp, int bytes);
 void	xfs_attr_fork_remove(struct xfs_inode *ip, struct xfs_trans *tp);
@@ -87,6 +88,8 @@ int	xfs_attr3_leaf_toosmall(struct xfs_d
 void	xfs_attr3_leaf_unbalance(struct xfs_da_state *state,
 				       struct xfs_da_state_blk *drop_blk,
 				       struct xfs_da_state_blk *save_blk);
+int	xfs_attr3_root_inactive(struct xfs_trans **trans, struct xfs_inode *dp);
+
 /*
  * Utility routines.
  */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_attr_remote.c package_partclone/src/xfs/libxfs/xfs_attr_remote.c
--- package_partclone_orig/src/xfs/libxfs/xfs_attr_remote.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_attr_remote.c	2019-11-12 13:59:47.913149883 -0300
@@ -24,7 +24,6 @@
 #include "xfs_trans_resv.h"
 #include "xfs_bit.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_da_format.h"
 #include "xfs_da_btree.h"
 #include "xfs_inode.h"
@@ -456,16 +455,16 @@ xfs_attr_rmtval_set(
 		 * extent and then crash then the block may not contain the
 		 * correct metadata after log recovery occurs.
 		 */
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		nmap = 1;
 		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
 				  blkcnt, XFS_BMAPI_ATTRFORK, args->firstblock,
-				  args->total, &map, &nmap, args->dfops);
+				  args->total, &map, &nmap, args->flist);
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops, dp);
+			error = xfs_bmap_finish(&args->trans, args->flist, dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			return error;
 		}

@@ -499,7 +498,7 @@ xfs_attr_rmtval_set(

 		ASSERT(blkcnt > 0);

-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		nmap = 1;
 		error = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,
 				       blkcnt, &map, &nmap,
@@ -599,16 +598,16 @@ xfs_attr_rmtval_remove(
 	blkcnt = args->rmtblkcnt;
 	done = 0;
 	while (!done) {
-		xfs_defer_init(args->dfops, args->firstblock);
+		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,
 				    XFS_BMAPI_ATTRFORK, 1, args->firstblock,
-				    args->dfops, &done);
+				    args->flist, &done);
 		if (!error)
-			error = xfs_defer_finish(&args->trans, args->dfops,
+			error = xfs_bmap_finish(&args->trans, args->flist,
 						args->dp);
 		if (error) {
 			args->trans = NULL;
-			xfs_defer_cancel(args->dfops);
+			xfs_bmap_cancel(args->flist);
 			return error;
 		}

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_bmap_btree.c package_partclone/src/xfs/libxfs/xfs_bmap_btree.c
--- package_partclone_orig/src/xfs/libxfs/xfs_bmap_btree.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_bmap_btree.c	2019-11-12 13:59:47.913149883 -0300
@@ -23,7 +23,6 @@
 #include "xfs_trans_resv.h"
 #include "xfs_bit.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_trans.h"
 #include "xfs_alloc.h"
@@ -32,7 +31,6 @@
 #include "xfs_bmap.h"
 #include "xfs_trace.h"
 #include "xfs_cksum.h"
-#include "xfs_rmap.h"

 /*
  * Determine the extent state.
@@ -405,11 +403,11 @@ xfs_bmbt_dup_cursor(
 			cur->bc_private.b.ip, cur->bc_private.b.whichfork);

 	/*
-	 * Copy the firstblock, dfops, and flags values,
+	 * Copy the firstblock, flist, and flags values,
 	 * since init cursor doesn't get them.
 	 */
 	new->bc_private.b.firstblock = cur->bc_private.b.firstblock;
-	new->bc_private.b.dfops = cur->bc_private.b.dfops;
+	new->bc_private.b.flist = cur->bc_private.b.flist;
 	new->bc_private.b.flags = cur->bc_private.b.flags;

 	return new;
@@ -422,7 +420,7 @@ xfs_bmbt_update_cursor(
 {
 	ASSERT((dst->bc_private.b.firstblock != NULLFSBLOCK) ||
 	       (dst->bc_private.b.ip->i_d.di_flags & XFS_DIFLAG_REALTIME));
-	ASSERT(dst->bc_private.b.dfops == src->bc_private.b.dfops);
+	ASSERT(dst->bc_private.b.flist == src->bc_private.b.flist);

 	dst->bc_private.b.allocated += src->bc_private.b.allocated;
 	dst->bc_private.b.firstblock = src->bc_private.b.firstblock;
@@ -445,12 +443,9 @@ xfs_bmbt_alloc_block(
 	args.mp = cur->bc_mp;
 	args.fsbno = cur->bc_private.b.firstblock;
 	args.firstblock = args.fsbno;
-	xfs_rmap_ino_bmbt_owner(&args.oinfo, cur->bc_private.b.ip->i_ino,
-			cur->bc_private.b.whichfork);

 	if (args.fsbno == NULLFSBLOCK) {
 		args.fsbno = be64_to_cpu(start->l);
-try_another_ag:
 		args.type = XFS_ALLOCTYPE_START_BNO;
 		/*
 		 * Make sure there is sufficient room left in the AG to
@@ -463,8 +458,8 @@ try_another_ag:
 		 * reservation amount is insufficient then we may fail a
 		 * block allocation here and corrupt the filesystem.
 		 */
-		args.minleft = args.tp->t_blk_res;
-	} else if (cur->bc_private.b.dfops->dop_low) {
+		args.minleft = xfs_trans_get_block_res(args.tp);
+	} else if (cur->bc_private.b.flist->xbf_low) {
 		args.type = XFS_ALLOCTYPE_START_BNO;
 	} else {
 		args.type = XFS_ALLOCTYPE_NEAR_BNO;
@@ -472,7 +467,7 @@ try_another_ag:

 	args.minlen = args.maxlen = args.prod = 1;
 	args.wasdel = cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL;
-	if (!args.wasdel && args.tp->t_blk_res == 0) {
+	if (!args.wasdel && xfs_trans_get_block_res(args.tp) == 0) {
 		error = -ENOSPC;
 		goto error0;
 	}
@@ -480,22 +475,6 @@ try_another_ag:
 	if (error)
 		goto error0;

-	/*
-	 * During a CoW operation, the allocation and bmbt updates occur in
-	 * different transactions.  The mapping code tries to put new bmbt
-	 * blocks near extents being mapped, but the only way to guarantee this
-	 * is if the alloc and the mapping happen in a single transaction that
-	 * has a block reservation.  That isn't the case here, so if we run out
-	 * of space we'll try again with another AG.
-	 */
-	if (xfs_sb_version_hasreflink(&cur->bc_mp->m_sb) &&
-	    args.fsbno == NULLFSBLOCK &&
-	    args.type == XFS_ALLOCTYPE_NEAR_BNO) {
-		cur->bc_private.b.dfops->dop_low = true;
-		args.fsbno = cur->bc_private.b.firstblock;
-		goto try_another_ag;
-	}
-
 	if (args.fsbno == NULLFSBLOCK && args.minleft) {
 		/*
 		 * Could not find an AG with enough free space to satisfy
@@ -508,7 +487,7 @@ try_another_ag:
 		error = xfs_alloc_vextent(&args);
 		if (error)
 			goto error0;
-		cur->bc_private.b.dfops->dop_low = true;
+		cur->bc_private.b.flist->xbf_low = 1;
 	}
 	if (args.fsbno == NULLFSBLOCK) {
 		XFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);
@@ -543,14 +522,13 @@ xfs_bmbt_free_block(
 	struct xfs_inode	*ip = cur->bc_private.b.ip;
 	struct xfs_trans	*tp = cur->bc_tp;
 	xfs_fsblock_t		fsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));
-	struct xfs_owner_info	oinfo;

-	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, cur->bc_private.b.whichfork);
-	xfs_bmap_add_free(mp, cur->bc_private.b.dfops, fsbno, 1, &oinfo);
+	xfs_bmap_add_free(mp, cur->bc_private.b.flist, fsbno, 1);
 	ip->i_d.di_nblocks--;

 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
+	xfs_trans_binval(tp, bp);
 	return 0;
 }

@@ -620,6 +598,17 @@ xfs_bmbt_init_key_from_rec(
 }

 STATIC void
+xfs_bmbt_init_rec_from_key(
+	union xfs_btree_key	*key,
+	union xfs_btree_rec	*rec)
+{
+	ASSERT(key->bmbt.br_startoff != 0);
+
+	xfs_bmbt_disk_set_allf(&rec->bmbt, be64_to_cpu(key->bmbt.br_startoff),
+			       0, 0, XFS_EXT_NORM);
+}
+
+STATIC void
 xfs_bmbt_init_rec_from_cur(
 	struct xfs_btree_cur	*cur,
 	union xfs_btree_rec	*rec)
@@ -769,6 +758,7 @@ static const struct xfs_btree_ops xfs_bm
 	.get_minrecs		= xfs_bmbt_get_minrecs,
 	.get_dmaxrecs		= xfs_bmbt_get_dmaxrecs,
 	.init_key_from_rec	= xfs_bmbt_init_key_from_rec,
+	.init_rec_from_key	= xfs_bmbt_init_rec_from_key,
 	.init_rec_from_cur	= xfs_bmbt_init_rec_from_cur,
 	.init_ptr_from_cur	= xfs_bmbt_init_ptr_from_cur,
 	.key_diff		= xfs_bmbt_key_diff,
@@ -791,7 +781,6 @@ xfs_bmbt_init_cursor(
 {
 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
 	struct xfs_btree_cur	*cur;
-	ASSERT(whichfork != XFS_COW_FORK);

 	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);

@@ -809,7 +798,7 @@ xfs_bmbt_init_cursor(
 	cur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);
 	cur->bc_private.b.ip = ip;
 	cur->bc_private.b.firstblock = NULLFSBLOCK;
-	cur->bc_private.b.dfops = NULL;
+	cur->bc_private.b.flist = NULL;
 	cur->bc_private.b.allocated = 0;
 	cur->bc_private.b.flags = 0;
 	cur->bc_private.b.whichfork = whichfork;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_bmap.c package_partclone/src/xfs/libxfs/xfs_bmap.c
--- package_partclone_orig/src/xfs/libxfs/xfs_bmap.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_bmap.c	2019-11-12 13:59:47.916149884 -0300
@@ -24,7 +24,6 @@
 #include "xfs_bit.h"
 #include "xfs_sb.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_da_format.h"
 #include "xfs_da_btree.h"
 #include "xfs_dir2.h"
@@ -38,9 +37,6 @@
 #include "xfs_trace.h"
 #include "xfs_attr_leaf.h"
 #include "xfs_quota_defs.h"
-#include "xfs_rmap.h"
-#include "xfs_ag_resv.h"
-#include "xfs_refcount.h"


 kmem_zone_t		*xfs_bmap_free_item_zone;
@@ -133,8 +129,7 @@ xfs_bmbt_lookup_ge(
  */
 static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)
 {
-	return whichfork != XFS_COW_FORK &&
-		XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
+	return XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
 		XFS_IFORK_NEXTENTS(ip, whichfork) >
 			XFS_IFORK_MAXEXT(ip, whichfork);
 }
@@ -144,8 +139,7 @@ static inline bool xfs_bmap_needs_btree(
  */
 static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)
 {
-	return whichfork != XFS_COW_FORK &&
-		XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&
+	return XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&
 		XFS_IFORK_NEXTENTS(ip, whichfork) <=
 			XFS_IFORK_MAXEXT(ip, whichfork);
 }
@@ -475,7 +469,10 @@ xfs_bmap_check_leaf_extents(
 		}
 		block = XFS_BUF_TO_BLOCK(bp);
 	}
-
+	if (bp_release) {
+		bp_release = 0;
+		xfs_trans_brelse(NULL, bp);
+	}
 	return;

 error0:
@@ -568,13 +565,14 @@ xfs_bmap_validate_ret(
  */
 void
 xfs_bmap_add_free(
-	struct xfs_mount		*mp,
-	struct xfs_defer_ops		*dfops,
-	xfs_fsblock_t			bno,
-	xfs_filblks_t			len,
-	struct xfs_owner_info		*oinfo)
-{
-	struct xfs_extent_free_item	*new;		/* new element */
+	struct xfs_mount	*mp,		/* mount point structure */
+	struct xfs_bmap_free	*flist,		/* list of extents */
+	xfs_fsblock_t		bno,		/* fs block number of extent */
+	xfs_filblks_t		len)		/* length of extent */
+{
+	xfs_bmap_free_item_t	*cur;		/* current (next) element */
+	xfs_bmap_free_item_t	*new;		/* new element */
+	xfs_bmap_free_item_t	*prev;		/* previous element */
 #ifdef DEBUG
 	xfs_agnumber_t		agno;
 	xfs_agblock_t		agbno;
@@ -591,17 +589,59 @@ xfs_bmap_add_free(
 	ASSERT(agbno + len <= mp->m_sb.sb_agblocks);
 #endif
 	ASSERT(xfs_bmap_free_item_zone != NULL);
-
 	new = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);
-	new->xefi_startblock = bno;
-	new->xefi_blockcount = (xfs_extlen_t)len;
-	if (oinfo)
-		new->xefi_oinfo = *oinfo;
+	new->xbfi_startblock = bno;
+	new->xbfi_blockcount = (xfs_extlen_t)len;
+	for (prev = NULL, cur = flist->xbf_first;
+	     cur != NULL;
+	     prev = cur, cur = cur->xbfi_next) {
+		if (cur->xbfi_startblock >= bno)
+			break;
+	}
+	if (prev)
+		prev->xbfi_next = new;
+	else
+		flist->xbf_first = new;
+	new->xbfi_next = cur;
+	flist->xbf_count++;
+}
+
+/*
+ * Remove the entry "free" from the free item list.  Prev points to the
+ * previous entry, unless "free" is the head of the list.
+ */
+void
+xfs_bmap_del_free(
+	xfs_bmap_free_t		*flist,	/* free item list header */
+	xfs_bmap_free_item_t	*prev,	/* previous item on list, if any */
+	xfs_bmap_free_item_t	*free)	/* list item to be freed */
+{
+	if (prev)
+		prev->xbfi_next = free->xbfi_next;
 	else
-		xfs_rmap_skip_owner_update(&new->xefi_oinfo);
-	trace_xfs_bmap_free_defer(mp, XFS_FSB_TO_AGNO(mp, bno), 0,
-			XFS_FSB_TO_AGBNO(mp, bno), len);
-	xfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_FREE, &new->xefi_list);
+		flist->xbf_first = free->xbfi_next;
+	flist->xbf_count--;
+	kmem_zone_free(xfs_bmap_free_item_zone, free);
+}
+
+/*
+ * Free up any items left in the list.
+ */
+void
+xfs_bmap_cancel(
+	xfs_bmap_free_t		*flist)	/* list of bmap_free_items */
+{
+	xfs_bmap_free_item_t	*free;	/* free list item */
+	xfs_bmap_free_item_t	*next;
+
+	if (flist->xbf_count == 0)
+		return;
+	ASSERT(flist->xbf_first != NULL);
+	for (free = flist->xbf_first; free; free = next) {
+		next = free->xbfi_next;
+		xfs_bmap_del_free(flist, NULL, free);
+	}
+	ASSERT(flist->xbf_count == 0);
 }

 /*
@@ -631,11 +671,9 @@ xfs_bmap_btree_to_extents(
 	xfs_mount_t		*mp;	/* mount point structure */
 	__be64			*pp;	/* ptr to block address */
 	struct xfs_btree_block	*rblock;/* root btree block */
-	struct xfs_owner_info	oinfo;

 	mp = ip->i_mount;
 	ifp = XFS_IFORK_PTR(ip, whichfork);
-	ASSERT(whichfork != XFS_COW_FORK);
 	ASSERT(ifp->if_flags & XFS_IFEXTENTS);
 	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);
 	rblock = ifp->if_broot;
@@ -656,8 +694,7 @@ xfs_bmap_btree_to_extents(
 	cblock = XFS_BUF_TO_BLOCK(cbp);
 	if ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))
 		return error;
-	xfs_rmap_ino_bmbt_owner(&oinfo, ip->i_ino, whichfork);
-	xfs_bmap_add_free(mp, cur->bc_private.b.dfops, cbno, 1, &oinfo);
+	xfs_bmap_add_free(mp, cur->bc_private.b.flist, cbno, 1);
 	ip->i_d.di_nblocks--;
 	xfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);
 	xfs_trans_binval(tp, cbp);
@@ -680,7 +717,7 @@ xfs_bmap_extents_to_btree(
 	xfs_trans_t		*tp,		/* transaction pointer */
 	xfs_inode_t		*ip,		/* incore inode pointer */
 	xfs_fsblock_t		*firstblock,	/* first-block-allocated */
-	struct xfs_defer_ops	*dfops,		/* blocks freed in xaction */
+	xfs_bmap_free_t		*flist,		/* blocks freed in xaction */
 	xfs_btree_cur_t		**curp,		/* cursor returned to caller */
 	int			wasdel,		/* converting a delayed alloc */
 	int			*logflagsp,	/* inode logging flags */
@@ -702,7 +739,6 @@ xfs_bmap_extents_to_btree(
 	xfs_bmbt_ptr_t		*pp;		/* root block address pointer */

 	mp = ip->i_mount;
-	ASSERT(whichfork != XFS_COW_FORK);
 	ifp = XFS_IFORK_PTR(ip, whichfork);
 	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);

@@ -730,7 +766,7 @@ xfs_bmap_extents_to_btree(
 	 */
 	cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
 	cur->bc_private.b.firstblock = *firstblock;
-	cur->bc_private.b.dfops = dfops;
+	cur->bc_private.b.flist = flist;
 	cur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;
 	/*
 	 * Convert to a btree with two levels, one record in root.
@@ -739,13 +775,11 @@ xfs_bmap_extents_to_btree(
 	memset(&args, 0, sizeof(args));
 	args.tp = tp;
 	args.mp = mp;
-	xfs_rmap_ino_bmbt_owner(&args.oinfo, ip->i_ino, whichfork);
 	args.firstblock = *firstblock;
 	if (*firstblock == NULLFSBLOCK) {
 		args.type = XFS_ALLOCTYPE_START_BNO;
 		args.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);
-	} else if (dfops->dop_low) {
-try_another_ag:
+	} else if (flist->xbf_low) {
 		args.type = XFS_ALLOCTYPE_START_BNO;
 		args.fsbno = *firstblock;
 	} else {
@@ -760,28 +794,13 @@ try_another_ag:
 		xfs_btree_del_cursor(cur, XFS_BTREE_ERROR);
 		return error;
 	}
-
-	/*
-	 * During a CoW operation, the allocation and bmbt updates occur in
-	 * different transactions.  The mapping code tries to put new bmbt
-	 * blocks near extents being mapped, but the only way to guarantee this
-	 * is if the alloc and the mapping happen in a single transaction that
-	 * has a block reservation.  That isn't the case here, so if we run out
-	 * of space we'll try again with another AG.
-	 */
-	if (xfs_sb_version_hasreflink(&cur->bc_mp->m_sb) &&
-	    args.fsbno == NULLFSBLOCK &&
-	    args.type == XFS_ALLOCTYPE_NEAR_BNO) {
-		dfops->dop_low = true;
-		goto try_another_ag;
-	}
 	/*
 	 * Allocation can't fail, the space was reserved.
 	 */
 	ASSERT(args.fsbno != NULLFSBLOCK);
 	ASSERT(*firstblock == NULLFSBLOCK ||
 	       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||
-	       (dfops->dop_low &&
+	       (flist->xbf_low &&
 		args.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));
 	*firstblock = cur->bc_private.b.firstblock = args.fsbno;
 	cur->bc_private.b.allocated++;
@@ -850,7 +869,6 @@ xfs_bmap_local_to_extents_empty(
 {
 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);

-	ASSERT(whichfork != XFS_COW_FORK);
 	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);
 	ASSERT(ifp->if_bytes == 0);
 	ASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);
@@ -886,7 +904,7 @@ xfs_bmap_local_to_extents(
 	 * We don't want to deal with the case of keeping inode data inline yet.
 	 * So sending the data fork of a regular inode is invalid.
 	 */
-	ASSERT(!(S_ISREG(VFS_I(ip)->i_mode) && whichfork == XFS_DATA_FORK));
+	ASSERT(!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK));
 	ifp = XFS_IFORK_PTR(ip, whichfork);
 	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);

@@ -903,14 +921,12 @@ xfs_bmap_local_to_extents(
 	memset(&args, 0, sizeof(args));
 	args.tp = tp;
 	args.mp = ip->i_mount;
-	xfs_rmap_ino_owner(&args.oinfo, ip->i_ino, whichfork, 0);
 	args.firstblock = *firstblock;
 	/*
 	 * Allocate a block.  We know we need only one, since the
 	 * file currently fits in an inode.
 	 */
 	if (*firstblock == NULLFSBLOCK) {
-try_another_ag:
 		args.fsbno = XFS_INO_TO_FSB(args.mp, ip->i_ino);
 		args.type = XFS_ALLOCTYPE_START_BNO;
 	} else {
@@ -923,19 +939,6 @@ try_another_ag:
 	if (error)
 		goto done;

-	/*
-	 * During a CoW operation, the allocation and bmbt updates occur in
-	 * different transactions.  The mapping code tries to put new bmbt
-	 * blocks near extents being mapped, but the only way to guarantee this
-	 * is if the alloc and the mapping happen in a single transaction that
-	 * has a block reservation.  That isn't the case here, so if we run out
-	 * of space we'll try again with another AG.
-	 */
-	if (xfs_sb_version_hasreflink(&ip->i_mount->m_sb) &&
-	    args.fsbno == NULLFSBLOCK &&
-	    args.type == XFS_ALLOCTYPE_NEAR_BNO) {
-		goto try_another_ag;
-	}
 	/* Can't fail, the space was reserved. */
 	ASSERT(args.fsbno != NULLFSBLOCK);
 	ASSERT(args.len == 1);
@@ -982,7 +985,7 @@ xfs_bmap_add_attrfork_btree(
 	xfs_trans_t		*tp,		/* transaction pointer */
 	xfs_inode_t		*ip,		/* incore inode pointer */
 	xfs_fsblock_t		*firstblock,	/* first block allocated */
-	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
+	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
 	int			*flags)		/* inode logging flags */
 {
 	xfs_btree_cur_t		*cur;		/* btree cursor */
@@ -995,7 +998,7 @@ xfs_bmap_add_attrfork_btree(
 		*flags |= XFS_ILOG_DBROOT;
 	else {
 		cur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);
-		cur->bc_private.b.dfops = dfops;
+		cur->bc_private.b.flist = flist;
 		cur->bc_private.b.firstblock = *firstblock;
 		if ((error = xfs_bmbt_lookup_ge(cur, 0, 0, 0, &stat)))
 			goto error0;
@@ -1025,7 +1028,7 @@ xfs_bmap_add_attrfork_extents(
 	xfs_trans_t		*tp,		/* transaction pointer */
 	xfs_inode_t		*ip,		/* incore inode pointer */
 	xfs_fsblock_t		*firstblock,	/* first block allocated */
-	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
+	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
 	int			*flags)		/* inode logging flags */
 {
 	xfs_btree_cur_t		*cur;		/* bmap btree cursor */
@@ -1034,7 +1037,7 @@ xfs_bmap_add_attrfork_extents(
 	if (ip->i_d.di_nextents * sizeof(xfs_bmbt_rec_t) <= XFS_IFORK_DSIZE(ip))
 		return 0;
 	cur = NULL;
-	error = xfs_bmap_extents_to_btree(tp, ip, firstblock, dfops, &cur, 0,
+	error = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist, &cur, 0,
 		flags, XFS_DATA_FORK);
 	if (cur) {
 		cur->bc_private.b.allocated = 0;
@@ -1060,7 +1063,7 @@ xfs_bmap_add_attrfork_local(
 	xfs_trans_t		*tp,		/* transaction pointer */
 	xfs_inode_t		*ip,		/* incore inode pointer */
 	xfs_fsblock_t		*firstblock,	/* first block allocated */
-	struct xfs_defer_ops	*dfops,		/* blocks to free at commit */
+	xfs_bmap_free_t		*flist,		/* blocks to free at commit */
 	int			*flags)		/* inode logging flags */
 {
 	xfs_da_args_t		dargs;		/* args for dir/attr code */
@@ -1068,19 +1071,19 @@ xfs_bmap_add_attrfork_local(
 	if (ip->i_df.if_bytes <= XFS_IFORK_DSIZE(ip))
 		return 0;

-	if (S_ISDIR(VFS_I(ip)->i_mode)) {
+	if (S_ISDIR(ip->i_d.di_mode)) {
 		memset(&dargs, 0, sizeof(dargs));
 		dargs.geo = ip->i_mount->m_dir_geo;
 		dargs.dp = ip;
 		dargs.firstblock = firstblock;
-		dargs.dfops = dfops;
+		dargs.flist = flist;
 		dargs.total = dargs.geo->fsbcount;
 		dargs.whichfork = XFS_DATA_FORK;
 		dargs.trans = tp;
 		return xfs_dir2_sf_to_block(&dargs);
 	}

-	if (S_ISLNK(VFS_I(ip)->i_mode))
+	if (S_ISLNK(ip->i_d.di_mode))
 		return xfs_bmap_local_to_extents(tp, ip, firstblock, 1,
 						 flags, XFS_DATA_FORK,
 						 xfs_symlink_local_to_remote);
@@ -1101,7 +1104,7 @@ xfs_bmap_add_attrfork(
 	int			rsvd)		/* xact may use reserved blks */
 {
 	xfs_fsblock_t		firstblock;	/* 1st block/ag allocated */
-	struct xfs_defer_ops	dfops;		/* freed extent records */
+	xfs_bmap_free_t		flist;		/* freed extent records */
 	xfs_mount_t		*mp;		/* mount structure */
 	xfs_trans_t		*tp;		/* transaction pointer */
 	int			blks;		/* space reservation */
@@ -1113,14 +1116,15 @@ xfs_bmap_add_attrfork(

 	mp = ip->i_mount;
 	ASSERT(!XFS_NOT_DQATTACHED(mp, ip));
-
+	tp = xfs_trans_alloc(mp, XFS_TRANS_ADDAFORK);
 	blks = XFS_ADDAFORK_SPACE_RES(mp);
-
-	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_addafork, blks, 0,
-			rsvd ? XFS_TRANS_RESERVE : 0, &tp);
-	if (error)
+	if (rsvd)
+		tp->t_flags |= XFS_TRANS_RESERVE;
+	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_addafork, blks, 0);
+	if (error) {
+		xfs_trans_cancel(tp);
 		return error;
-
+	}
 	xfs_ilock(ip, XFS_ILOCK_EXCL);
 	error = xfs_trans_reserve_quota_nblks(tp, ip, blks, 0, rsvd ?
 			XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :
@@ -1167,18 +1171,18 @@ xfs_bmap_add_attrfork(
 	ip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);
 	ip->i_afp->if_flags = XFS_IFEXTENTS;
 	logflags = 0;
-	xfs_defer_init(&dfops, &firstblock);
+	xfs_bmap_init(&flist, &firstblock);
 	switch (ip->i_d.di_format) {
 	case XFS_DINODE_FMT_LOCAL:
-		error = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &dfops,
+		error = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,
 			&logflags);
 		break;
 	case XFS_DINODE_FMT_EXTENTS:
 		error = xfs_bmap_add_attrfork_extents(tp, ip, &firstblock,
-			&dfops, &logflags);
+			&flist, &logflags);
 		break;
 	case XFS_DINODE_FMT_BTREE:
-		error = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &dfops,
+		error = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &flist,
 			&logflags);
 		break;
 	default:
@@ -1207,7 +1211,7 @@ xfs_bmap_add_attrfork(
 			xfs_log_sb(tp);
 	}

-	error = xfs_defer_finish(&tp, &dfops, NULL);
+	error = xfs_bmap_finish(&tp, &flist, NULL);
 	if (error)
 		goto bmap_cancel;
 	error = xfs_trans_commit(tp);
@@ -1215,7 +1219,7 @@ xfs_bmap_add_attrfork(
 	return error;

 bmap_cancel:
-	xfs_defer_cancel(&dfops);
+	xfs_bmap_cancel(&flist);
 trans_cancel:
 	xfs_trans_cancel(tp);
 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
@@ -1698,8 +1702,7 @@ xfs_bmap_one_block(
  */
 STATIC int				/* error */
 xfs_bmap_add_extent_delay_real(
-	struct xfs_bmalloca	*bma,
-	int			whichfork)
+	struct xfs_bmalloca	*bma)
 {
 	struct xfs_bmbt_irec	*new = &bma->got;
 	int			diff;	/* temp value */
@@ -1718,13 +1721,10 @@ xfs_bmap_add_extent_delay_real(
 	xfs_filblks_t		temp2=0;/* value for da_new calculations */
 	int			tmp_rval;	/* partial logging flags */
 	struct xfs_mount	*mp;
-	xfs_extnum_t		*nextents;
+	int			whichfork = XFS_DATA_FORK;

 	mp = bma->ip->i_mount;
 	ifp = XFS_IFORK_PTR(bma->ip, whichfork);
-	ASSERT(whichfork != XFS_ATTR_FORK);
-	nextents = (whichfork == XFS_COW_FORK ? &bma->ip->i_cnextents :
-						&bma->ip->i_d.di_nextents);

 	ASSERT(bma->idx >= 0);
 	ASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));
@@ -1738,9 +1738,6 @@ xfs_bmap_add_extent_delay_real(
 #define	RIGHT		r[1]
 #define	PREV		r[2]

-	if (whichfork == XFS_COW_FORK)
-		state |= BMAP_COWFORK;
-
 	/*
 	 * Set up a bunch of variables to make the tests simpler.
 	 */
@@ -1827,7 +1824,7 @@ xfs_bmap_add_extent_delay_real(
 		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);

 		xfs_iext_remove(bma->ip, bma->idx + 1, 2, state);
-		(*nextents)--;
+		bma->ip->i_d.di_nextents--;
 		if (bma->cur == NULL)
 			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
 		else {
@@ -1929,7 +1926,7 @@ xfs_bmap_add_extent_delay_real(
 		xfs_bmbt_set_startblock(ep, new->br_startblock);
 		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);

-		(*nextents)++;
+		bma->ip->i_d.di_nextents++;
 		if (bma->cur == NULL)
 			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
 		else {
@@ -1999,7 +1996,7 @@ xfs_bmap_add_extent_delay_real(
 		temp = PREV.br_blockcount - new->br_blockcount;
 		xfs_bmbt_set_blockcount(ep, temp);
 		xfs_iext_insert(bma->ip, bma->idx, 1, new, state);
-		(*nextents)++;
+		bma->ip->i_d.di_nextents++;
 		if (bma->cur == NULL)
 			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
 		else {
@@ -2019,7 +2016,7 @@ xfs_bmap_add_extent_delay_real(

 		if (xfs_bmap_needs_btree(bma->ip, whichfork)) {
 			error = xfs_bmap_extents_to_btree(bma->tp, bma->ip,
-					bma->firstblock, bma->dfops,
+					bma->firstblock, bma->flist,
 					&bma->cur, 1, &tmp_rval, whichfork);
 			rval |= tmp_rval;
 			if (error)
@@ -2083,7 +2080,7 @@ xfs_bmap_add_extent_delay_real(
 		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 		xfs_bmbt_set_blockcount(ep, temp);
 		xfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);
-		(*nextents)++;
+		bma->ip->i_d.di_nextents++;
 		if (bma->cur == NULL)
 			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
 		else {
@@ -2103,7 +2100,7 @@ xfs_bmap_add_extent_delay_real(

 		if (xfs_bmap_needs_btree(bma->ip, whichfork)) {
 			error = xfs_bmap_extents_to_btree(bma->tp, bma->ip,
-				bma->firstblock, bma->dfops, &bma->cur, 1,
+				bma->firstblock, bma->flist, &bma->cur, 1,
 				&tmp_rval, whichfork);
 			rval |= tmp_rval;
 			if (error)
@@ -2152,7 +2149,7 @@ xfs_bmap_add_extent_delay_real(
 		RIGHT.br_blockcount = temp2;
 		/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */
 		xfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);
-		(*nextents)++;
+		bma->ip->i_d.di_nextents++;
 		if (bma->cur == NULL)
 			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
 		else {
@@ -2172,7 +2169,7 @@ xfs_bmap_add_extent_delay_real(

 		if (xfs_bmap_needs_btree(bma->ip, whichfork)) {
 			error = xfs_bmap_extents_to_btree(bma->tp, bma->ip,
-					bma->firstblock, bma->dfops, &bma->cur,
+					bma->firstblock, bma->flist, &bma->cur,
 					1, &tmp_rval, whichfork);
 			rval |= tmp_rval;
 			if (error)
@@ -2215,18 +2212,13 @@ xfs_bmap_add_extent_delay_real(
 		ASSERT(0);
 	}

-	/* add reverse mapping */
-	error = xfs_rmap_map_extent(mp, bma->dfops, bma->ip, whichfork, new);
-	if (error)
-		goto done;
-
 	/* convert to a btree if necessary */
 	if (xfs_bmap_needs_btree(bma->ip, whichfork)) {
 		int	tmp_logflags;	/* partial log flag return val */

 		ASSERT(bma->cur == NULL);
 		error = xfs_bmap_extents_to_btree(bma->tp, bma->ip,
-				bma->firstblock, bma->dfops, &bma->cur,
+				bma->firstblock, bma->flist, &bma->cur,
 				da_old > 0, &tmp_logflags, whichfork);
 		bma->logflags |= tmp_logflags;
 		if (error)
@@ -2250,8 +2242,7 @@ xfs_bmap_add_extent_delay_real(

 	xfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);
 done:
-	if (whichfork != XFS_COW_FORK)
-		bma->logflags |= rval;
+	bma->logflags |= rval;
 	return error;
 #undef	LEFT
 #undef	RIGHT
@@ -2269,7 +2260,7 @@ xfs_bmap_add_extent_unwritten_real(
 	xfs_btree_cur_t		**curp,	/* if *curp is null, not a btree */
 	xfs_bmbt_irec_t		*new,	/* new data to add to file extents */
 	xfs_fsblock_t		*first,	/* pointer to firstblock variable */
-	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
+	xfs_bmap_free_t		*flist,	/* list of extents to be freed */
 	int			*logflagsp) /* inode logging flags */
 {
 	xfs_btree_cur_t		*cur;	/* btree cursor */
@@ -2757,17 +2748,12 @@ xfs_bmap_add_extent_unwritten_real(
 		ASSERT(0);
 	}

-	/* update reverse mappings */
-	error = xfs_rmap_convert_extent(mp, dfops, ip, XFS_DATA_FORK, new);
-	if (error)
-		goto done;
-
 	/* convert to a btree if necessary */
 	if (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {
 		int	tmp_logflags;	/* partial log flag return val */

 		ASSERT(cur == NULL);
-		error = xfs_bmap_extents_to_btree(tp, ip, first, dfops, &cur,
+		error = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,
 				0, &tmp_logflags, XFS_DATA_FORK);
 		*logflagsp |= tmp_logflags;
 		if (error)
@@ -2795,7 +2781,6 @@ done:
 STATIC void
 xfs_bmap_add_extent_hole_delay(
 	xfs_inode_t		*ip,	/* incore inode pointer */
-	int			whichfork,
 	xfs_extnum_t		*idx,	/* extent number to update/insert */
 	xfs_bmbt_irec_t		*new)	/* new data to add to file extents */
 {
@@ -2807,10 +2792,8 @@ xfs_bmap_add_extent_hole_delay(
 	int			state;  /* state bits, accessed thru macros */
 	xfs_filblks_t		temp=0;	/* temp for indirect calculations */

-	ifp = XFS_IFORK_PTR(ip, whichfork);
+	ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
 	state = 0;
-	if (whichfork == XFS_COW_FORK)
-		state |= BMAP_COWFORK;
 	ASSERT(isnullstartblock(new->br_startblock));

 	/*
@@ -2828,7 +2811,7 @@ xfs_bmap_add_extent_hole_delay(
 	 * Check and set flags if the current (right) segment exists.
 	 * If it doesn't exist, we're converting the hole at end-of-file.
 	 */
-	if (*idx < ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {
+	if (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {
 		state |= BMAP_RIGHT_VALID;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &right);

@@ -2962,7 +2945,6 @@ xfs_bmap_add_extent_hole_real(
 	ASSERT(!isnullstartblock(new->br_startblock));
 	ASSERT(!bma->cur ||
 	       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));
-	ASSERT(whichfork != XFS_COW_FORK);

 	XFS_STATS_INC(mp, xs_add_exlist);

@@ -3158,18 +3140,13 @@ xfs_bmap_add_extent_hole_real(
 		break;
 	}

-	/* add reverse mapping */
-	error = xfs_rmap_map_extent(mp, bma->dfops, bma->ip, whichfork, new);
-	if (error)
-		goto done;
-
 	/* convert to a btree if necessary */
 	if (xfs_bmap_needs_btree(bma->ip, whichfork)) {
 		int	tmp_logflags;	/* partial log flag return val */

 		ASSERT(bma->cur == NULL);
 		error = xfs_bmap_extents_to_btree(bma->tp, bma->ip,
-				bma->firstblock, bma->dfops, &bma->cur,
+				bma->firstblock, bma->flist, &bma->cur,
 				0, &tmp_logflags, whichfork);
 		bma->logflags |= tmp_logflags;
 		if (error)
@@ -3388,8 +3365,7 @@ xfs_bmap_adjacent(

 	mp = ap->ip->i_mount;
 	nullfb = *ap->firstblock == NULLFSBLOCK;
-	rt = XFS_IS_REALTIME_INODE(ap->ip) &&
-		xfs_alloc_is_userdata(ap->datatype);
+	rt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;
 	fb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);
 	/*
 	 * If allocating at eof, and there's a previous real block,
@@ -3543,8 +3519,7 @@ xfs_bmap_longest_free_extent(
 	}

 	longest = xfs_alloc_longest_free_extent(mp, pag,
-				xfs_alloc_min_freelist(mp, pag),
-				xfs_ag_resv_needed(pag, XFS_AG_RESV_NONE));
+					xfs_alloc_min_freelist(mp, pag));
 	if (*blen < longest)
 		*blen = longest;

@@ -3665,7 +3640,7 @@ xfs_bmap_btalloc(
 {
 	xfs_mount_t	*mp;		/* mount point structure */
 	xfs_alloctype_t	atype = 0;	/* type for allocation routines */
-	xfs_extlen_t	align = 0;	/* minimum allocation alignment */
+	xfs_extlen_t	align;		/* minimum allocation alignment */
 	xfs_agnumber_t	fb_agno;	/* ag number of ap->firstblock */
 	xfs_agnumber_t	ag;
 	xfs_alloc_arg_t	args;
@@ -3688,10 +3663,7 @@ xfs_bmap_btalloc(
 	else if (mp->m_dalign)
 		stripe_align = mp->m_dalign;

-	if (ap->flags & XFS_BMAPI_COWFORK)
-		align = xfs_get_cowextsz_hint(ap->ip);
-	else if (xfs_alloc_is_userdata(ap->datatype))
-		align = xfs_get_extsz_hint(ap->ip);
+	align = ap->userdata ? xfs_get_extsz_hint(ap->ip) : 0;
 	if (unlikely(align)) {
 		error = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,
 						align, 0, ap->eof, 0, ap->conv,
@@ -3704,8 +3676,7 @@ xfs_bmap_btalloc(
 	nullfb = *ap->firstblock == NULLFSBLOCK;
 	fb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);
 	if (nullfb) {
-		if (xfs_alloc_is_userdata(ap->datatype) &&
-		    xfs_inode_is_filestream(ap->ip)) {
+		if (ap->userdata && xfs_inode_is_filestream(ap->ip)) {
 			ag = xfs_filestream_lookup_ag(ap->ip);
 			ag = (ag != NULLAGNUMBER) ? ag : 0;
 			ap->blkno = XFS_AGB_TO_FSB(mp, ag, 0);
@@ -3733,10 +3704,9 @@ xfs_bmap_btalloc(
 	args.tp = ap->tp;
 	args.mp = mp;
 	args.fsbno = ap->blkno;
-	xfs_rmap_skip_owner_update(&args.oinfo);

 	/* Trim the allocation back to the maximum an AG can fit. */
-	args.maxlen = MIN(ap->length, mp->m_ag_max_usable);
+	args.maxlen = MIN(ap->length, XFS_ALLOC_AG_MAX_USABLE(mp));
 	args.firstblock = *ap->firstblock;
 	blen = 0;
 	if (nullfb) {
@@ -3745,14 +3715,13 @@ xfs_bmap_btalloc(
 		 * enough for the request.  If one isn't found, then adjust
 		 * the minimum allocation size to the largest space found.
 		 */
-		if (xfs_alloc_is_userdata(ap->datatype) &&
-		    xfs_inode_is_filestream(ap->ip))
+		if (ap->userdata && xfs_inode_is_filestream(ap->ip))
 			error = xfs_bmap_btalloc_filestreams(ap, &args, &blen);
 		else
 			error = xfs_bmap_btalloc_nullfb(ap, &args, &blen);
 		if (error)
 			return error;
-	} else if (ap->dfops->dop_low) {
+	} else if (ap->flist->xbf_low) {
 		if (xfs_inode_is_filestream(ap->ip))
 			args.type = XFS_ALLOCTYPE_FIRST_AG;
 		else
@@ -3768,11 +3737,11 @@ xfs_bmap_btalloc(
 		args.prod = align;
 		if ((args.mod = (xfs_extlen_t)do_mod(ap->offset, args.prod)))
 			args.mod = (xfs_extlen_t)(args.prod - args.mod);
-	} else if (mp->m_sb.sb_blocksize >= PAGE_SIZE) {
+	} else if (mp->m_sb.sb_blocksize >= PAGE_CACHE_SIZE) {
 		args.prod = 1;
 		args.mod = 0;
 	} else {
-		args.prod = PAGE_SIZE >> mp->m_sb.sb_blocklog;
+		args.prod = PAGE_CACHE_SIZE >> mp->m_sb.sb_blocklog;
 		if ((args.mod = (xfs_extlen_t)(do_mod(ap->offset, args.prod))))
 			args.mod = (xfs_extlen_t)(args.prod - args.mod);
 	}
@@ -3785,7 +3754,7 @@ xfs_bmap_btalloc(
 	 * is >= the stripe unit and the allocation offset is
 	 * at the end of file.
 	 */
-	if (!ap->dfops->dop_low && ap->aeof) {
+	if (!ap->flist->xbf_low && ap->aeof) {
 		if (!ap->offset) {
 			args.alignment = stripe_align;
 			atype = args.type;
@@ -3829,9 +3798,9 @@ xfs_bmap_btalloc(
 	}
 	args.minleft = ap->minleft;
 	args.wasdel = ap->wasdel;
-	args.resv = XFS_AG_RESV_NONE;
-	args.datatype = ap->datatype;
-	if (ap->datatype & XFS_ALLOC_USERDATA_ZERO)
+	args.isfl = 0;
+	args.userdata = ap->userdata;
+	if (ap->userdata & XFS_ALLOC_USERDATA_ZERO)
 		args.ip = ap->ip;

 	error = xfs_alloc_vextent(&args);
@@ -3878,7 +3847,7 @@ xfs_bmap_btalloc(
 		args.minleft = 0;
 		if ((error = xfs_alloc_vextent(&args)))
 			return error;
-		ap->dfops->dop_low = true;
+		ap->flist->xbf_low = 1;
 	}
 	if (args.fsbno != NULLFSBLOCK) {
 		/*
@@ -3888,7 +3857,7 @@ xfs_bmap_btalloc(
 		ASSERT(*ap->firstblock == NULLFSBLOCK ||
 		       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==
 		       XFS_FSB_TO_AGNO(mp, args.fsbno) ||
-		       (ap->dfops->dop_low &&
+		       (ap->flist->xbf_low &&
 			XFS_FSB_TO_AGNO(mp, *ap->firstblock) <
 			XFS_FSB_TO_AGNO(mp, args.fsbno)));

@@ -3896,10 +3865,9 @@ xfs_bmap_btalloc(
 		if (*ap->firstblock == NULLFSBLOCK)
 			*ap->firstblock = args.fsbno;
 		ASSERT(nullfb || fb_agno == args.agno ||
-		       (ap->dfops->dop_low && fb_agno < args.agno));
+		       (ap->flist->xbf_low && fb_agno < args.agno));
 		ap->length = args.len;
-		if (!(ap->flags & XFS_BMAPI_COWFORK))
-			ap->ip->i_d.di_nblocks += args.len;
+		ap->ip->i_d.di_nblocks += args.len;
 		xfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);
 		if (ap->wasdel)
 			ap->ip->i_delayed_blks -= args.len;
@@ -3919,60 +3887,6 @@ xfs_bmap_btalloc(
 }

 /*
- * For a remap operation, just "allocate" an extent at the address that the
- * caller passed in, and ensure that the AGFL is the right size.  The caller
- * will then map the "allocated" extent into the file somewhere.
- */
-STATIC int
-xfs_bmap_remap_alloc(
-	struct xfs_bmalloca	*ap)
-{
-	struct xfs_trans	*tp = ap->tp;
-	struct xfs_mount	*mp = tp->t_mountp;
-	xfs_agblock_t		bno;
-	struct xfs_alloc_arg	args;
-	int			error;
-
-	/*
-	 * validate that the block number is legal - the enables us to detect
-	 * and handle a silent filesystem corruption rather than crashing.
-	 */
-	memset(&args, 0, sizeof(struct xfs_alloc_arg));
-	args.tp = ap->tp;
-	args.mp = ap->tp->t_mountp;
-	bno = *ap->firstblock;
-	args.agno = XFS_FSB_TO_AGNO(mp, bno);
-	args.agbno = XFS_FSB_TO_AGBNO(mp, bno);
-	if (args.agno >= mp->m_sb.sb_agcount ||
-	    args.agbno >= mp->m_sb.sb_agblocks)
-		return -EFSCORRUPTED;
-
-	/* "Allocate" the extent from the range we passed in. */
-	trace_xfs_bmap_remap_alloc(ap->ip, *ap->firstblock, ap->length);
-	ap->blkno = bno;
-	ap->ip->i_d.di_nblocks += ap->length;
-	xfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);
-
-	/* Fix the freelist, like a real allocator does. */
-	args.datatype = ap->datatype;
-	args.pag = xfs_perag_get(args.mp, args.agno);
-	ASSERT(args.pag);
-
-	/*
-	 * The freelist fixing code will decline the allocation if
-	 * the size and shape of the free space doesn't allow for
-	 * allocating the extent and updating all the metadata that
-	 * happens during an allocation.  We're remapping, not
-	 * allocating, so skip that check by pretending to be freeing.
-	 */
-	error = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);
-	xfs_perag_put(args.pag);
-	if (error)
-		trace_xfs_bmap_remap_alloc_error(ap->ip, error, _RET_IP_);
-	return error;
-}
-
-/*
  * xfs_bmap_alloc is called by xfs_bmapi to allocate an extent for a file.
  * It figures out where to ask the underlying allocator to put the new extent.
  */
@@ -3980,47 +3894,11 @@ STATIC int
 xfs_bmap_alloc(
 	struct xfs_bmalloca	*ap)	/* bmap alloc argument struct */
 {
-	if (ap->flags & XFS_BMAPI_REMAP)
-		return xfs_bmap_remap_alloc(ap);
-	if (XFS_IS_REALTIME_INODE(ap->ip) &&
-	    xfs_alloc_is_userdata(ap->datatype))
+	if (XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata)
 		return xfs_bmap_rtalloc(ap);
 	return xfs_bmap_btalloc(ap);
 }

-/* Trim extent to fit a logical block range. */
-void
-xfs_trim_extent(
-	struct xfs_bmbt_irec	*irec,
-	xfs_fileoff_t		bno,
-	xfs_filblks_t		len)
-{
-	xfs_fileoff_t		distance;
-	xfs_fileoff_t		end = bno + len;
-
-	if (irec->br_startoff + irec->br_blockcount <= bno ||
-	    irec->br_startoff >= end) {
-		irec->br_blockcount = 0;
-		return;
-	}
-
-	if (irec->br_startoff < bno) {
-		distance = bno - irec->br_startoff;
-		if (isnullstartblock(irec->br_startblock))
-			irec->br_startblock = DELAYSTARTBLOCK;
-		if (irec->br_startblock != DELAYSTARTBLOCK &&
-		    irec->br_startblock != HOLESTARTBLOCK)
-			irec->br_startblock += distance;
-		irec->br_startoff += distance;
-		irec->br_blockcount -= distance;
-	}
-
-	if (end < irec->br_startoff + irec->br_blockcount) {
-		distance = irec->br_startoff + irec->br_blockcount - end;
-		irec->br_blockcount -= distance;
-	}
-}
-
 /*
  * Trim the returned map to the required bounds
  */
@@ -4144,11 +4022,12 @@ xfs_bmapi_read(
 	int			error;
 	int			eof;
 	int			n = 0;
-	int			whichfork = xfs_bmapi_whichfork(flags);
+	int			whichfork = (flags & XFS_BMAPI_ATTRFORK) ?
+						XFS_ATTR_FORK : XFS_DATA_FORK;

 	ASSERT(*nmap >= 1);
 	ASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|
-			   XFS_BMAPI_IGSTATE|XFS_BMAPI_COWFORK)));
+			   XFS_BMAPI_IGSTATE)));
 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));

 	if (unlikely(XFS_TEST_ERROR(
@@ -4166,16 +4045,6 @@ xfs_bmapi_read(

 	ifp = XFS_IFORK_PTR(ip, whichfork);

-	/* No CoW fork?  Return a hole. */
-	if (whichfork == XFS_COW_FORK && !ifp) {
-		mval->br_startoff = bno;
-		mval->br_startblock = HOLESTARTBLOCK;
-		mval->br_blockcount = len;
-		mval->br_state = XFS_EXT_NORM;
-		*nmap = 1;
-		return 0;
-	}
-
 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
 		error = xfs_iread_extents(NULL, ip, whichfork);
 		if (error)
@@ -4222,10 +4091,9 @@ xfs_bmapi_read(
 	return 0;
 }

-int
+STATIC int
 xfs_bmapi_reserve_delalloc(
 	struct xfs_inode	*ip,
-	int			whichfork,
 	xfs_fileoff_t		aoff,
 	xfs_filblks_t		len,
 	struct xfs_bmbt_irec	*got,
@@ -4234,7 +4102,7 @@ xfs_bmapi_reserve_delalloc(
 	int			eof)
 {
 	struct xfs_mount	*mp = ip->i_mount;
-	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
 	xfs_extlen_t		alen;
 	xfs_extlen_t		indlen;
 	char			rt = XFS_IS_REALTIME_INODE(ip);
@@ -4246,10 +4114,7 @@ xfs_bmapi_reserve_delalloc(
 		alen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);

 	/* Figure out the extent size, adjust alen */
-	if (whichfork == XFS_COW_FORK)
-		extsz = xfs_get_cowextsz_hint(ip);
-	else
-		extsz = xfs_get_extsz_hint(ip);
+	extsz = xfs_get_extsz_hint(ip);
 	if (extsz) {
 		error = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,
 					       1, 0, &aoff, &alen);
@@ -4296,7 +4161,7 @@ xfs_bmapi_reserve_delalloc(
 	got->br_startblock = nullstartblock(indlen);
 	got->br_blockcount = alen;
 	got->br_state = XFS_EXT_NORM;
-	xfs_bmap_add_extent_hole_delay(ip, whichfork, lastx, got);
+	xfs_bmap_add_extent_hole_delay(ip, lastx, got);

 	/*
 	 * Update our extent pointer, given that xfs_bmap_add_extent_hole_delay
@@ -4322,12 +4187,98 @@ out_unreserve_quota:
 	return error;
 }

+/*
+ * Map file blocks to filesystem blocks, adding delayed allocations as needed.
+ */
+int
+xfs_bmapi_delay(
+	struct xfs_inode	*ip,	/* incore inode */
+	xfs_fileoff_t		bno,	/* starting file offs. mapped */
+	xfs_filblks_t		len,	/* length to map in file */
+	struct xfs_bmbt_irec	*mval,	/* output: map values */
+	int			*nmap,	/* i/o: mval size/count */
+	int			flags)	/* XFS_BMAPI_... */
+{
+	struct xfs_mount	*mp = ip->i_mount;
+	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
+	struct xfs_bmbt_irec	got;	/* current file extent record */
+	struct xfs_bmbt_irec	prev;	/* previous file extent record */
+	xfs_fileoff_t		obno;	/* old block number (offset) */
+	xfs_fileoff_t		end;	/* end of mapped file region */
+	xfs_extnum_t		lastx;	/* last useful extent number */
+	int			eof;	/* we've hit the end of extents */
+	int			n = 0;	/* current extent index */
+	int			error = 0;
+
+	ASSERT(*nmap >= 1);
+	ASSERT(*nmap <= XFS_BMAP_MAX_NMAP);
+	ASSERT(!(flags & ~XFS_BMAPI_ENTIRE));
+	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+
+	if (unlikely(XFS_TEST_ERROR(
+	    (XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&
+	     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),
+	     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {
+		XFS_ERROR_REPORT("xfs_bmapi_delay", XFS_ERRLEVEL_LOW, mp);
+		return -EFSCORRUPTED;
+	}
+
+	if (XFS_FORCED_SHUTDOWN(mp))
+		return -EIO;
+
+	XFS_STATS_INC(mp, xs_blk_mapw);
+
+	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+		error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);
+		if (error)
+			return error;
+	}
+
+	xfs_bmap_search_extents(ip, bno, XFS_DATA_FORK, &eof, &lastx, &got, &prev);
+	end = bno + len;
+	obno = bno;
+
+	while (bno < end && n < *nmap) {
+		if (eof || got.br_startoff > bno) {
+			error = xfs_bmapi_reserve_delalloc(ip, bno, len, &got,
+							   &prev, &lastx, eof);
+			if (error) {
+				if (n == 0) {
+					*nmap = 0;
+					return error;
+				}
+				break;
+			}
+		}
+
+		/* set up the extent map to return. */
+		xfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);
+		xfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);
+
+		/* If we're done, stop now. */
+		if (bno >= end || n >= *nmap)
+			break;
+
+		/* Else go on to the next record. */
+		prev = got;
+		if (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))
+			xfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);
+		else
+			eof = 1;
+	}
+
+	*nmap = n;
+	return 0;
+}
+
+
 static int
 xfs_bmapi_allocate(
 	struct xfs_bmalloca	*bma)
 {
 	struct xfs_mount	*mp = bma->ip->i_mount;
-	int			whichfork = xfs_bmapi_whichfork(bma->flags);
+	int			whichfork = (bma->flags & XFS_BMAPI_ATTRFORK) ?
+						XFS_ATTR_FORK : XFS_DATA_FORK;
 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(bma->ip, whichfork);
 	int			tmp_logflags = 0;
 	int			error;
@@ -4353,21 +4304,15 @@ xfs_bmapi_allocate(
 	}

 	/*
-	 * Set the data type being allocated. For the data fork, the first data
-	 * in the file is treated differently to all other allocations. For the
-	 * attribute fork, we only need to ensure the allocated range is not on
-	 * the busy list.
+	 * Indicate if this is the first user data in the file, or just any
+	 * user data. And if it is userdata, indicate whether it needs to
+	 * be initialised to zero during allocation.
 	 */
 	if (!(bma->flags & XFS_BMAPI_METADATA)) {
-		bma->datatype = XFS_ALLOC_NOBUSY;
-		if (whichfork == XFS_DATA_FORK) {
-			if (bma->offset == 0)
-				bma->datatype |= XFS_ALLOC_INITIAL_USER_DATA;
-			else
-				bma->datatype |= XFS_ALLOC_USERDATA;
-		}
+		bma->userdata = (bma->offset == 0) ?
+			XFS_ALLOC_INITIAL_USER_DATA : XFS_ALLOC_USERDATA;
 		if (bma->flags & XFS_BMAPI_ZERO)
-			bma->datatype |= XFS_ALLOC_USERDATA_ZERO;
+			bma->userdata |= XFS_ALLOC_USERDATA_ZERO;
 	}

 	bma->minlen = (bma->flags & XFS_BMAPI_CONTIG) ? bma->length : 1;
@@ -4387,7 +4332,7 @@ xfs_bmapi_allocate(
 	if (error)
 		return error;

-	if (bma->dfops->dop_low)
+	if (bma->flist->xbf_low)
 		bma->minleft = 0;
 	if (bma->cur)
 		bma->cur->bc_private.b.firstblock = *bma->firstblock;
@@ -4396,7 +4341,7 @@ xfs_bmapi_allocate(
 	if ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {
 		bma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);
 		bma->cur->bc_private.b.firstblock = *bma->firstblock;
-		bma->cur->bc_private.b.dfops = bma->dfops;
+		bma->cur->bc_private.b.flist = bma->flist;
 	}
 	/*
 	 * Bump the number of extents we've allocated
@@ -4422,7 +4367,7 @@ xfs_bmapi_allocate(
 		bma->got.br_state = XFS_EXT_UNWRITTEN;

 	if (bma->wasdel)
-		error = xfs_bmap_add_extent_delay_real(bma, whichfork);
+		error = xfs_bmap_add_extent_delay_real(bma);
 	else
 		error = xfs_bmap_add_extent_hole_real(bma, whichfork);

@@ -4452,7 +4397,8 @@ xfs_bmapi_convert_unwritten(
 	xfs_filblks_t		len,
 	int			flags)
 {
-	int			whichfork = xfs_bmapi_whichfork(flags);
+	int			whichfork = (flags & XFS_BMAPI_ATTRFORK) ?
+						XFS_ATTR_FORK : XFS_DATA_FORK;
 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(bma->ip, whichfork);
 	int			tmp_logflags = 0;
 	int			error;
@@ -4468,8 +4414,6 @@ xfs_bmapi_convert_unwritten(
 			(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))
 		return 0;

-	ASSERT(whichfork != XFS_COW_FORK);
-
 	/*
 	 * Modify (by adding) the state flag, if writing.
 	 */
@@ -4478,7 +4422,7 @@ xfs_bmapi_convert_unwritten(
 		bma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,
 					bma->ip, whichfork);
 		bma->cur->bc_private.b.firstblock = *bma->firstblock;
-		bma->cur->bc_private.b.dfops = bma->dfops;
+		bma->cur->bc_private.b.flist = bma->flist;
 	}
 	mval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)
 				? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;
@@ -4495,7 +4439,7 @@ xfs_bmapi_convert_unwritten(
 	}

 	error = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, &bma->idx,
-			&bma->cur, mval, bma->firstblock, bma->dfops,
+			&bma->cur, mval, bma->firstblock, bma->flist,
 			&tmp_logflags);
 	/*
 	 * Log the inode core unconditionally in the unwritten extent conversion
@@ -4549,7 +4493,7 @@ xfs_bmapi_write(
 	xfs_extlen_t		total,		/* total blocks needed */
 	struct xfs_bmbt_irec	*mval,		/* output: map values */
 	int			*nmap,		/* i/o: mval size/count */
-	struct xfs_defer_ops	*dfops)		/* i/o: list extents to free */
+	struct xfs_bmap_free	*flist)		/* i/o: list extents to free */
 {
 	struct xfs_mount	*mp = ip->i_mount;
 	struct xfs_ifork	*ifp;
@@ -4576,7 +4520,8 @@ xfs_bmapi_write(
 	orig_mval = mval;
 	orig_nmap = *nmap;
 #endif
-	whichfork = xfs_bmapi_whichfork(flags);
+	whichfork = (flags & XFS_BMAPI_ATTRFORK) ?
+		XFS_ATTR_FORK : XFS_DATA_FORK;

 	ASSERT(*nmap >= 1);
 	ASSERT(*nmap <= XFS_BMAP_MAX_NMAP);
@@ -4585,11 +4530,6 @@ xfs_bmapi_write(
 	ASSERT(len > 0);
 	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);
 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
-	ASSERT(!(flags & XFS_BMAPI_REMAP) || whichfork == XFS_DATA_FORK);
-	ASSERT(!(flags & XFS_BMAPI_PREALLOC) || !(flags & XFS_BMAPI_REMAP));
-	ASSERT(!(flags & XFS_BMAPI_CONVERT) || !(flags & XFS_BMAPI_REMAP));
-	ASSERT(!(flags & XFS_BMAPI_PREALLOC) || whichfork != XFS_COW_FORK);
-	ASSERT(!(flags & XFS_BMAPI_CONVERT) || whichfork != XFS_COW_FORK);

 	/* zeroing is for currently only for data extents, not metadata */
 	ASSERT((flags & (XFS_BMAPI_METADATA | XFS_BMAPI_ZERO)) !=
@@ -4642,8 +4582,8 @@ xfs_bmapi_write(
 	bma.tp = tp;
 	bma.ip = ip;
 	bma.total = total;
-	bma.datatype = 0;
-	bma.dfops = dfops;
+	bma.userdata = 0;
+	bma.flist = flist;
 	bma.firstblock = firstblock;

 	while (bno < end && n < *nmap) {
@@ -4651,14 +4591,6 @@ xfs_bmapi_write(
 		wasdelay = !inhole && isnullstartblock(bma.got.br_startblock);

 		/*
-		 * Make sure we only reflink into a hole.
-		 */
-		if (flags & XFS_BMAPI_REMAP)
-			ASSERT(inhole);
-		if (flags & XFS_BMAPI_COWFORK)
-			ASSERT(!inhole);
-
-		/*
 		 * First, deal with the hole before the allocated space
 		 * that we found, if any.
 		 */
@@ -4688,17 +4620,6 @@ xfs_bmapi_write(
 				goto error0;
 			if (bma.blkno == NULLFSBLOCK)
 				break;
-
-			/*
-			 * If this is a CoW allocation, record the data in
-			 * the refcount btree for orphan recovery.
-			 */
-			if (whichfork == XFS_COW_FORK) {
-				error = xfs_refcount_alloc_cow_extent(mp, dfops,
-						bma.blkno, bma.length);
-				if (error)
-					goto error0;
-			}
 		}

 		/* Deal with the allocated space we found.  */
@@ -4776,7 +4697,7 @@ error0:
 			       XFS_FSB_TO_AGNO(mp, *firstblock) ==
 			       XFS_FSB_TO_AGNO(mp,
 				       bma.cur->bc_private.b.firstblock) ||
-			       (dfops->dop_low &&
+			       (flist->xbf_low &&
 				XFS_FSB_TO_AGNO(mp, *firstblock) <
 				XFS_FSB_TO_AGNO(mp,
 					bma.cur->bc_private.b.firstblock)));
@@ -4792,280 +4713,6 @@ error0:
 }

 /*
- * When a delalloc extent is split (e.g., due to a hole punch), the original
- * indlen reservation must be shared across the two new extents that are left
- * behind.
- *
- * Given the original reservation and the worst case indlen for the two new
- * extents (as calculated by xfs_bmap_worst_indlen()), split the original
- * reservation fairly across the two new extents. If necessary, steal available
- * blocks from a deleted extent to make up a reservation deficiency (e.g., if
- * ores == 1). The number of stolen blocks is returned. The availability and
- * subsequent accounting of stolen blocks is the responsibility of the caller.
- */
-static xfs_filblks_t
-xfs_bmap_split_indlen(
-	xfs_filblks_t			ores,		/* original res. */
-	xfs_filblks_t			*indlen1,	/* ext1 worst indlen */
-	xfs_filblks_t			*indlen2,	/* ext2 worst indlen */
-	xfs_filblks_t			avail)		/* stealable blocks */
-{
-	xfs_filblks_t			len1 = *indlen1;
-	xfs_filblks_t			len2 = *indlen2;
-	xfs_filblks_t			nres = len1 + len2; /* new total res. */
-	xfs_filblks_t			stolen = 0;
-
-	/*
-	 * Steal as many blocks as we can to try and satisfy the worst case
-	 * indlen for both new extents.
-	 */
-	while (nres > ores && avail) {
-		nres--;
-		avail--;
-		stolen++;
-	}
-
-	/*
-	 * The only blocks available are those reserved for the original
-	 * extent and what we can steal from the extent being removed.
-	 * If this still isn't enough to satisfy the combined
-	 * requirements for the two new extents, skim blocks off of each
-	 * of the new reservations until they match what is available.
-	 */
-	while (nres > ores) {
-		if (len1) {
-			len1--;
-			nres--;
-		}
-		if (nres == ores)
-			break;
-		if (len2) {
-			len2--;
-			nres--;
-		}
-	}
-
-	*indlen1 = len1;
-	*indlen2 = len2;
-
-	return stolen;
-}
-
-int
-xfs_bmap_del_extent_delay(
-	struct xfs_inode	*ip,
-	int			whichfork,
-	xfs_extnum_t		*idx,
-	struct xfs_bmbt_irec	*got,
-	struct xfs_bmbt_irec	*del)
-{
-	struct xfs_mount	*mp = ip->i_mount;
-	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
-	struct xfs_bmbt_irec	new;
-	int64_t			da_old, da_new, da_diff = 0;
-	xfs_fileoff_t		del_endoff, got_endoff;
-	xfs_filblks_t		got_indlen, new_indlen, stolen;
-	int			error = 0, state = 0;
-	bool			isrt;
-
-	XFS_STATS_INC(mp, xs_del_exlist);
-
-	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
-	del_endoff = del->br_startoff + del->br_blockcount;
-	got_endoff = got->br_startoff + got->br_blockcount;
-	da_old = startblockval(got->br_startblock);
-	da_new = 0;
-
-	ASSERT(*idx >= 0);
-	ASSERT(*idx < ifp->if_bytes / sizeof(struct xfs_bmbt_rec));
-	ASSERT(del->br_blockcount > 0);
-	ASSERT(got->br_startoff <= del->br_startoff);
-	ASSERT(got_endoff >= del_endoff);
-
-	if (isrt) {
-		int64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
-
-		do_div(rtexts, mp->m_sb.sb_rextsize);
-		xfs_mod_frextents(mp, rtexts);
-	}
-
-	/*
-	 * Update the inode delalloc counter now and wait to update the
-	 * sb counters as we might have to borrow some blocks for the
-	 * indirect block accounting.
-	 */
-	error = xfs_trans_reserve_quota_nblks(NULL, ip,
-			-((long)del->br_blockcount), 0,
-			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
-	ip->i_delayed_blks -= del->br_blockcount;
-
-	if (whichfork == XFS_COW_FORK)
-		state |= BMAP_COWFORK;
-
-	if (got->br_startoff == del->br_startoff)
-		state |= BMAP_LEFT_CONTIG;
-	if (got_endoff == del_endoff)
-		state |= BMAP_RIGHT_CONTIG;
-
-	switch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {
-	case BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:
-		/*
-		 * Matches the whole extent.  Delete the entry.
-		 */
-		xfs_iext_remove(ip, *idx, 1, state);
-		--*idx;
-		break;
-	case BMAP_LEFT_CONTIG:
-		/*
-		 * Deleting the first part of the extent.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-		got->br_startoff = del_endoff;
-		got->br_blockcount -= del->br_blockcount;
-		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
-				got->br_blockcount), da_old);
-		got->br_startblock = nullstartblock((int)da_new);
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
-		break;
-	case BMAP_RIGHT_CONTIG:
-		/*
-		 * Deleting the last part of the extent.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-		got->br_blockcount = got->br_blockcount - del->br_blockcount;
-		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
-				got->br_blockcount), da_old);
-		got->br_startblock = nullstartblock((int)da_new);
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
-		break;
-	case 0:
-		/*
-		 * Deleting the middle of the extent.
-		 *
-		 * Distribute the original indlen reservation across the two new
-		 * extents.  Steal blocks from the deleted extent if necessary.
-		 * Stealing blocks simply fudges the fdblocks accounting below.
-		 * Warn if either of the new indlen reservations is zero as this
-		 * can lead to delalloc problems.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-
-		got->br_blockcount = del->br_startoff - got->br_startoff;
-		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
-
-		new.br_blockcount = got_endoff - del_endoff;
-		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
-
-		WARN_ON_ONCE(!got_indlen || !new_indlen);
-		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
-						       del->br_blockcount);
-
-		got->br_startblock = nullstartblock((int)got_indlen);
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, 0, _THIS_IP_);
-
-		new.br_startoff = del_endoff;
-		new.br_state = got->br_state;
-		new.br_startblock = nullstartblock((int)new_indlen);
-
-		++*idx;
-		xfs_iext_insert(ip, *idx, 1, &new, state);
-
-		da_new = got_indlen + new_indlen - stolen;
-		del->br_blockcount -= stolen;
-		break;
-	}
-
-	ASSERT(da_old >= da_new);
-	da_diff = da_old - da_new;
-	if (!isrt)
-		da_diff += del->br_blockcount;
-	if (da_diff)
-		xfs_mod_fdblocks(mp, da_diff, false);
-	return error;
-}
-
-void
-xfs_bmap_del_extent_cow(
-	struct xfs_inode	*ip,
-	xfs_extnum_t		*idx,
-	struct xfs_bmbt_irec	*got,
-	struct xfs_bmbt_irec	*del)
-{
-	struct xfs_mount	*mp = ip->i_mount;
-	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
-	struct xfs_bmbt_irec	new;
-	xfs_fileoff_t		del_endoff, got_endoff;
-	int			state = BMAP_COWFORK;
-
-	XFS_STATS_INC(mp, xs_del_exlist);
-
-	del_endoff = del->br_startoff + del->br_blockcount;
-	got_endoff = got->br_startoff + got->br_blockcount;
-
-	ASSERT(*idx >= 0);
-	ASSERT(*idx < ifp->if_bytes / sizeof(struct xfs_bmbt_rec));
-	ASSERT(del->br_blockcount > 0);
-	ASSERT(got->br_startoff <= del->br_startoff);
-	ASSERT(got_endoff >= del_endoff);
-	ASSERT(!isnullstartblock(got->br_startblock));
-
-	if (got->br_startoff == del->br_startoff)
-		state |= BMAP_LEFT_CONTIG;
-	if (got_endoff == del_endoff)
-		state |= BMAP_RIGHT_CONTIG;
-
-	switch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {
-	case BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:
-		/*
-		 * Matches the whole extent.  Delete the entry.
-		 */
-		xfs_iext_remove(ip, *idx, 1, state);
-		--*idx;
-		break;
-	case BMAP_LEFT_CONTIG:
-		/*
-		 * Deleting the first part of the extent.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-		got->br_startoff = del_endoff;
-		got->br_blockcount -= del->br_blockcount;
-		got->br_startblock = del->br_startblock + del->br_blockcount;
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
-		break;
-	case BMAP_RIGHT_CONTIG:
-		/*
-		 * Deleting the last part of the extent.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-		got->br_blockcount -= del->br_blockcount;
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
-		break;
-	case 0:
-		/*
-		 * Deleting the middle of the extent.
-		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
-		got->br_blockcount = del->br_startoff - got->br_startoff;
-		xfs_bmbt_set_all(xfs_iext_get_ext(ifp, *idx), got);
-		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
-
-		new.br_startoff = del_endoff;
-		new.br_blockcount = got_endoff - del_endoff;
-		new.br_state = got->br_state;
-		new.br_startblock = del->br_startblock + del->br_blockcount;
-
-		++*idx;
-		xfs_iext_insert(ip, *idx, 1, &new, state);
-		break;
-	}
-}
-
-/*
  * Called by xfs_bmapi to update file extent records and the btree
  * after removing space (or undoing a delayed allocation).
  */
@@ -5074,12 +4721,11 @@ xfs_bmap_del_extent(
 	xfs_inode_t		*ip,	/* incore inode pointer */
 	xfs_trans_t		*tp,	/* current transaction pointer */
 	xfs_extnum_t		*idx,	/* extent number to update/delete */
-	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
+	xfs_bmap_free_t		*flist,	/* list of extents to be freed */
 	xfs_btree_cur_t		*cur,	/* if null, not a btree */
 	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
 	int			*logflagsp, /* inode logging flags */
-	int			whichfork, /* data or attr fork */
-	int			bflags)	/* bmapi flags */
+	int			whichfork) /* data or attr fork */
 {
 	xfs_filblks_t		da_new;	/* new delay-alloc indirect blocks */
 	xfs_filblks_t		da_old;	/* old delay-alloc indirect blocks */
@@ -5108,8 +4754,6 @@ xfs_bmap_del_extent(

 	if (whichfork == XFS_ATTR_FORK)
 		state |= BMAP_ATTRFORK;
-	else if (whichfork == XFS_COW_FORK)
-		state |= BMAP_COWFORK;

 	ifp = XFS_IFORK_PTR(ip, whichfork);
 	ASSERT((*idx >= 0) && (*idx < ifp->if_bytes /
@@ -5179,7 +4823,6 @@ xfs_bmap_del_extent(
 		nblks = 0;
 		do_fx = 0;
 	}
-
 	/*
 	 * Set flag value to use in switch statement.
 	 * Left-contig is 2, right-contig is 1.
@@ -5190,7 +4833,6 @@ xfs_bmap_del_extent(
 		/*
 		 * Matches the whole extent.  Delete the entry.
 		 */
-		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 		xfs_iext_remove(ip, *idx, 1,
 				whichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);
 		--*idx;
@@ -5334,56 +4976,40 @@ xfs_bmap_del_extent(
 			XFS_IFORK_NEXT_SET(ip, whichfork,
 				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
 		} else {
-			xfs_filblks_t	stolen;
 			ASSERT(whichfork == XFS_DATA_FORK);
-
-			/*
-			 * Distribute the original indlen reservation across the
-			 * two new extents. Steal blocks from the deleted extent
-			 * if necessary. Stealing blocks simply fudges the
-			 * fdblocks accounting in xfs_bunmapi().
-			 */
-			temp = xfs_bmap_worst_indlen(ip, got.br_blockcount);
-			temp2 = xfs_bmap_worst_indlen(ip, new.br_blockcount);
-			stolen = xfs_bmap_split_indlen(da_old, &temp, &temp2,
-						       del->br_blockcount);
-			da_new = temp + temp2 - stolen;
-			del->br_blockcount -= stolen;
-
-			/*
-			 * Set the reservation for each extent. Warn if either
-			 * is zero as this can lead to delalloc problems.
-			 */
-			WARN_ON_ONCE(!temp || !temp2);
+			temp = xfs_bmap_worst_indlen(ip, temp);
 			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
+			temp2 = xfs_bmap_worst_indlen(ip, temp2);
 			new.br_startblock = nullstartblock((int)temp2);
+			da_new = temp + temp2;
+			while (da_new > da_old) {
+				if (temp) {
+					temp--;
+					da_new--;
+					xfs_bmbt_set_startblock(ep,
+						nullstartblock((int)temp));
+				}
+				if (da_new == da_old)
+					break;
+				if (temp2) {
+					temp2--;
+					da_new--;
+					new.br_startblock =
+						nullstartblock((int)temp2);
+				}
+			}
 		}
 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 		xfs_iext_insert(ip, *idx + 1, 1, &new, state);
 		++*idx;
 		break;
 	}
-
-	/* remove reverse mapping */
-	if (!delay) {
-		error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, del);
-		if (error)
-			goto done;
-	}
-
 	/*
 	 * If we need to, add to list of extents to delete.
 	 */
-	if (do_fx && !(bflags & XFS_BMAPI_REMAP)) {
-		if (xfs_is_reflink_inode(ip) && whichfork == XFS_DATA_FORK) {
-			error = xfs_refcount_decrease_extent(mp, dfops, del);
-			if (error)
-				goto done;
-		} else
-			xfs_bmap_add_free(mp, dfops, del->br_startblock,
-					del->br_blockcount, NULL);
-	}
-
+	if (do_fx)
+		xfs_bmap_add_free(mp, flist, del->br_startblock,
+			del->br_blockcount);
 	/*
 	 * Adjust inode # blocks in the file.
 	 */
@@ -5392,7 +5018,7 @@ xfs_bmap_del_extent(
 	/*
 	 * Adjust quota data.
 	 */
-	if (qfield && !(bflags & XFS_BMAPI_REMAP))
+	if (qfield)
 		xfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);

 	/*
@@ -5414,16 +5040,17 @@ done:
  * *done is set.
  */
 int						/* error */
-__xfs_bunmapi(
+xfs_bunmapi(
 	xfs_trans_t		*tp,		/* transaction pointer */
 	struct xfs_inode	*ip,		/* incore inode */
 	xfs_fileoff_t		bno,		/* starting offset to unmap */
-	xfs_filblks_t		*rlen,		/* i/o: amount remaining */
+	xfs_filblks_t		len,		/* length to unmap in file */
 	int			flags,		/* misc flags */
 	xfs_extnum_t		nexts,		/* number of extents max */
 	xfs_fsblock_t		*firstblock,	/* first allocated block
 						   controls a.g. for allocs */
-	struct xfs_defer_ops	*dfops)		/* i/o: deferred updates */
+	xfs_bmap_free_t		*flist,		/* i/o: list extents to free */
+	int			*done)		/* set if not done yet */
 {
 	xfs_btree_cur_t		*cur;		/* bmap btree cursor */
 	xfs_bmbt_irec_t		del;		/* extent being deleted */
@@ -5445,12 +5072,11 @@ __xfs_bunmapi(
 	int			wasdel;		/* was a delayed alloc extent */
 	int			whichfork;	/* data or attribute fork */
 	xfs_fsblock_t		sum;
-	xfs_filblks_t		len = *rlen;	/* length to unmap in file */

 	trace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);

-	whichfork = xfs_bmapi_whichfork(flags);
-	ASSERT(whichfork != XFS_COW_FORK);
+	whichfork = (flags & XFS_BMAPI_ATTRFORK) ?
+		XFS_ATTR_FORK : XFS_DATA_FORK;
 	ifp = XFS_IFORK_PTR(ip, whichfork);
 	if (unlikely(
 	    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
@@ -5472,7 +5098,7 @@ __xfs_bunmapi(
 		return error;
 	nextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);
 	if (nextents == 0) {
-		*rlen = 0;
+		*done = 1;
 		return 0;
 	}
 	XFS_STATS_INC(mp, xs_blk_unmap);
@@ -5496,7 +5122,7 @@ __xfs_bunmapi(
 		ASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);
 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
 		cur->bc_private.b.firstblock = *firstblock;
-		cur->bc_private.b.dfops = dfops;
+		cur->bc_private.b.flist = flist;
 		cur->bc_private.b.flags = 0;
 	} else
 		cur = NULL;
@@ -5505,10 +5131,8 @@ __xfs_bunmapi(
 		/*
 		 * Synchronize by locking the bitmap inode.
 		 */
-		xfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL|XFS_ILOCK_RTBITMAP);
+		xfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);
 		xfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);
-		xfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL|XFS_ILOCK_RTSUM);
-		xfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);
 	}

 	extno = 0;
@@ -5578,7 +5202,7 @@ __xfs_bunmapi(
 			 * This is better than zeroing it.
 			 */
 			ASSERT(del.br_state == XFS_EXT_NORM);
-			ASSERT(tp->t_blk_res > 0);
+			ASSERT(xfs_trans_get_block_res(tp) > 0);
 			/*
 			 * If this spans a realtime extent boundary,
 			 * chop it back to the start of the one we end at.
@@ -5590,7 +5214,7 @@ __xfs_bunmapi(
 			}
 			del.br_state = XFS_EXT_UNWRITTEN;
 			error = xfs_bmap_add_extent_unwritten_real(tp, ip,
-					&lastx, &cur, &del, firstblock, dfops,
+					&lastx, &cur, &del, firstblock, flist,
 					&logflags);
 			if (error)
 				goto error0;
@@ -5609,7 +5233,7 @@ __xfs_bunmapi(
 				del.br_startblock += mod;
 			} else if ((del.br_startoff == start &&
 				    (del.br_state == XFS_EXT_UNWRITTEN ||
-				     tp->t_blk_res == 0)) ||
+				     xfs_trans_get_block_res(tp) == 0)) ||
 				   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {
 				/*
 				 * Can't make it unwritten.  There isn't
@@ -5649,7 +5273,7 @@ __xfs_bunmapi(
 				lastx--;
 				error = xfs_bmap_add_extent_unwritten_real(tp,
 						ip, &lastx, &cur, &prev,
-						firstblock, dfops, &logflags);
+						firstblock, flist, &logflags);
 				if (error)
 					goto error0;
 				goto nodelete;
@@ -5658,43 +5282,15 @@ __xfs_bunmapi(
 				del.br_state = XFS_EXT_UNWRITTEN;
 				error = xfs_bmap_add_extent_unwritten_real(tp,
 						ip, &lastx, &cur, &del,
-						firstblock, dfops, &logflags);
+						firstblock, flist, &logflags);
 				if (error)
 					goto error0;
 				goto nodelete;
 			}
 		}
-
-		/*
-		 * If it's the case where the directory code is running
-		 * with no block reservation, and the deleted block is in
-		 * the middle of its extent, and the resulting insert
-		 * of an extent would cause transformation to btree format,
-		 * then reject it.  The calling code will then swap
-		 * blocks around instead.
-		 * We have to do this now, rather than waiting for the
-		 * conversion to btree format, since the transaction
-		 * will be dirty.
-		 */
-		if (!wasdel && tp->t_blk_res == 0 &&
-		    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
-		    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */
-			XFS_IFORK_MAXEXT(ip, whichfork) &&
-		    del.br_startoff > got.br_startoff &&
-		    del.br_startoff + del.br_blockcount <
-		    got.br_startoff + got.br_blockcount) {
-			error = -ENOSPC;
-			goto error0;
-		}
-
-		/*
-		 * Unreserve quota and update realtime free space, if
-		 * appropriate. If delayed allocation, update the inode delalloc
-		 * counter now and wait to update the sb counters as
-		 * xfs_bmap_del_extent() might need to borrow some blocks.
-		 */
 		if (wasdel) {
 			ASSERT(startblockval(del.br_startblock) > 0);
+			/* Update realtime/data freespace, unreserve quota */
 			if (isrt) {
 				xfs_filblks_t rtexts;

@@ -5705,6 +5301,8 @@ __xfs_bunmapi(
 					ip, -((long)del.br_blockcount), 0,
 					XFS_QMOPT_RES_RTBLKS);
 			} else {
+				xfs_mod_fdblocks(mp, (int64_t)del.br_blockcount,
+						 false);
 				(void)xfs_trans_reserve_quota_nblks(NULL,
 					ip, -((long)del.br_blockcount), 0,
 					XFS_QMOPT_RES_REGBLKS);
@@ -5715,16 +5313,32 @@ __xfs_bunmapi(
 					XFS_BTCUR_BPRV_WASDEL;
 		} else if (cur)
 			cur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;
-
-		error = xfs_bmap_del_extent(ip, tp, &lastx, dfops, cur, &del,
-				&tmp_logflags, whichfork, flags);
+		/*
+		 * If it's the case where the directory code is running
+		 * with no block reservation, and the deleted block is in
+		 * the middle of its extent, and the resulting insert
+		 * of an extent would cause transformation to btree format,
+		 * then reject it.  The calling code will then swap
+		 * blocks around instead.
+		 * We have to do this now, rather than waiting for the
+		 * conversion to btree format, since the transaction
+		 * will be dirty.
+		 */
+		if (!wasdel && xfs_trans_get_block_res(tp) == 0 &&
+		    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
+		    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */
+			XFS_IFORK_MAXEXT(ip, whichfork) &&
+		    del.br_startoff > got.br_startoff &&
+		    del.br_startoff + del.br_blockcount <
+		    got.br_startoff + got.br_blockcount) {
+			error = -ENOSPC;
+			goto error0;
+		}
+		error = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,
+				&tmp_logflags, whichfork);
 		logflags |= tmp_logflags;
 		if (error)
 			goto error0;
-
-		if (!isrt && wasdel)
-			xfs_mod_fdblocks(mp, (int64_t)del.br_blockcount, false);
-
 		bno = del.br_startoff - 1;
 nodelete:
 		/*
@@ -5743,17 +5357,14 @@ nodelete:
 			extno++;
 		}
 	}
-	if (bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0)
-		*rlen = 0;
-	else
-		*rlen = bno - start + 1;
+	*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;

 	/*
 	 * Convert to a btree if necessary.
 	 */
 	if (xfs_bmap_needs_btree(ip, whichfork)) {
 		ASSERT(cur == NULL);
-		error = xfs_bmap_extents_to_btree(tp, ip, firstblock, dfops,
+		error = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,
 			&cur, 0, &tmp_logflags, whichfork);
 		logflags |= tmp_logflags;
 		if (error)
@@ -5802,27 +5413,6 @@ error0:
 	return error;
 }

-/* Unmap a range of a file. */
-int
-xfs_bunmapi(
-	xfs_trans_t		*tp,
-	struct xfs_inode	*ip,
-	xfs_fileoff_t		bno,
-	xfs_filblks_t		len,
-	int			flags,
-	xfs_extnum_t		nexts,
-	xfs_fsblock_t		*firstblock,
-	struct xfs_defer_ops	*dfops,
-	int			*done)
-{
-	int			error;
-
-	error = __xfs_bunmapi(tp, ip, bno, &len, flags, nexts, firstblock,
-			dfops);
-	*done = (len == 0);
-	return error;
-}
-
 /*
  * Determine whether an extent shift can be accomplished by a merge with the
  * extent that precedes the target hole of the shift.
@@ -5941,8 +5531,7 @@ xfs_bmse_shift_one(
 	struct xfs_bmbt_rec_host	*gotp,
 	struct xfs_btree_cur		*cur,
 	int				*logflags,
-	enum shift_direction		direction,
-	struct xfs_defer_ops		*dfops)
+	enum shift_direction		direction)
 {
 	struct xfs_ifork		*ifp;
 	struct xfs_mount		*mp;
@@ -5990,13 +5579,9 @@ xfs_bmse_shift_one(
 		/* check whether to merge the extent or shift it down */
 		if (xfs_bmse_can_merge(&adj_irec, &got,
 				       offset_shift_fsb)) {
-			error = xfs_bmse_merge(ip, whichfork, offset_shift_fsb,
-					       *current_ext, gotp, adj_irecp,
-					       cur, logflags);
-			if (error)
-				return error;
-			adj_irec = got;
-			goto update_rmap;
+			return xfs_bmse_merge(ip, whichfork, offset_shift_fsb,
+					      *current_ext, gotp, adj_irecp,
+					      cur, logflags);
 		}
 	} else {
 		startoff = got.br_startoff + offset_shift_fsb;
@@ -6033,10 +5618,9 @@ update_current_ext:
 		(*current_ext)--;
 	xfs_bmbt_set_startoff(gotp, startoff);
 	*logflags |= XFS_ILOG_CORE;
-	adj_irec = got;
 	if (!cur) {
 		*logflags |= XFS_ILOG_DEXT;
-		goto update_rmap;
+		return 0;
 	}

 	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
@@ -6046,18 +5630,8 @@ update_current_ext:
 	XFS_WANT_CORRUPTED_RETURN(mp, i == 1);

 	got.br_startoff = startoff;
-	error = xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
-			got.br_blockcount, got.br_state);
-	if (error)
-		return error;
-
-update_rmap:
-	/* update reverse mapping */
-	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, &adj_irec);
-	if (error)
-		return error;
-	adj_irec.br_startoff = startoff;
-	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &adj_irec);
+	return xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
+			       got.br_blockcount, got.br_state);
 }

 /*
@@ -6079,7 +5653,7 @@ xfs_bmap_shift_extents(
 	int			*done,
 	xfs_fileoff_t		stop_fsb,
 	xfs_fsblock_t		*firstblock,
-	struct xfs_defer_ops	*dfops,
+	struct xfs_bmap_free	*flist,
 	enum shift_direction	direction,
 	int			num_exts)
 {
@@ -6124,7 +5698,7 @@ xfs_bmap_shift_extents(
 	if (ifp->if_flags & XFS_IFBROOT) {
 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
 		cur->bc_private.b.firstblock = *firstblock;
-		cur->bc_private.b.dfops = dfops;
+		cur->bc_private.b.flist = flist;
 		cur->bc_private.b.flags = 0;
 	}

@@ -6185,7 +5759,7 @@ xfs_bmap_shift_extents(
 	while (nexts++ < num_exts) {
 		error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
 					   &current_ext, gotp, cur, &logflags,
-					   direction, dfops);
+					   direction);
 		if (error)
 			goto del_cursor;
 		/*
@@ -6233,7 +5807,7 @@ xfs_bmap_split_extent_at(
 	struct xfs_inode	*ip,
 	xfs_fileoff_t		split_fsb,
 	xfs_fsblock_t		*firstfsb,
-	struct xfs_defer_ops	*dfops)
+	struct xfs_bmap_free	*free_list)
 {
 	int				whichfork = XFS_DATA_FORK;
 	struct xfs_btree_cur		*cur = NULL;
@@ -6295,7 +5869,7 @@ xfs_bmap_split_extent_at(
 	if (ifp->if_flags & XFS_IFBROOT) {
 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
 		cur->bc_private.b.firstblock = *firstfsb;
-		cur->bc_private.b.dfops = dfops;
+		cur->bc_private.b.flist = free_list;
 		cur->bc_private.b.flags = 0;
 		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
 				got.br_startblock,
@@ -6348,7 +5922,7 @@ xfs_bmap_split_extent_at(
 		int tmp_logflags; /* partial log flag return val */

 		ASSERT(cur == NULL);
-		error = xfs_bmap_extents_to_btree(tp, ip, firstfsb, dfops,
+		error = xfs_bmap_extents_to_btree(tp, ip, firstfsb, free_list,
 				&cur, 0, &tmp_logflags, whichfork);
 		logflags |= tmp_logflags;
 	}
@@ -6372,176 +5946,36 @@ xfs_bmap_split_extent(
 {
 	struct xfs_mount        *mp = ip->i_mount;
 	struct xfs_trans        *tp;
-	struct xfs_defer_ops    dfops;
+	struct xfs_bmap_free    free_list;
 	xfs_fsblock_t           firstfsb;
 	int                     error;

-	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write,
-			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0, 0, &tp);
-	if (error)
+	tp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);
+	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,
+			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0);
+	if (error) {
+		xfs_trans_cancel(tp);
 		return error;
+	}

 	xfs_ilock(ip, XFS_ILOCK_EXCL);
 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);

-	xfs_defer_init(&dfops, &firstfsb);
+	xfs_bmap_init(&free_list, &firstfsb);

 	error = xfs_bmap_split_extent_at(tp, ip, split_fsb,
-			&firstfsb, &dfops);
+			&firstfsb, &free_list);
 	if (error)
 		goto out;

-	error = xfs_defer_finish(&tp, &dfops, NULL);
+	error = xfs_bmap_finish(&tp, &free_list, NULL);
 	if (error)
 		goto out;

 	return xfs_trans_commit(tp);

 out:
-	xfs_defer_cancel(&dfops);
+	xfs_bmap_cancel(&free_list);
 	xfs_trans_cancel(tp);
 	return error;
 }
-
-/* Deferred mapping is only for real extents in the data fork. */
-static bool
-xfs_bmap_is_update_needed(
-	struct xfs_bmbt_irec	*bmap)
-{
-	return  bmap->br_startblock != HOLESTARTBLOCK &&
-		bmap->br_startblock != DELAYSTARTBLOCK;
-}
-
-/* Record a bmap intent. */
-static int
-__xfs_bmap_add(
-	struct xfs_mount		*mp,
-	struct xfs_defer_ops		*dfops,
-	enum xfs_bmap_intent_type	type,
-	struct xfs_inode		*ip,
-	int				whichfork,
-	struct xfs_bmbt_irec		*bmap)
-{
-	int				error;
-	struct xfs_bmap_intent		*bi;
-
-	trace_xfs_bmap_defer(mp,
-			XFS_FSB_TO_AGNO(mp, bmap->br_startblock),
-			type,
-			XFS_FSB_TO_AGBNO(mp, bmap->br_startblock),
-			ip->i_ino, whichfork,
-			bmap->br_startoff,
-			bmap->br_blockcount,
-			bmap->br_state);
-
-	bi = kmem_alloc(sizeof(struct xfs_bmap_intent), KM_SLEEP | KM_NOFS);
-	INIT_LIST_HEAD(&bi->bi_list);
-	bi->bi_type = type;
-	bi->bi_owner = ip;
-	bi->bi_whichfork = whichfork;
-	bi->bi_bmap = *bmap;
-
-	error = xfs_defer_join(dfops, bi->bi_owner);
-	if (error) {
-		kmem_free(bi);
-		return error;
-	}
-
-	xfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_BMAP, &bi->bi_list);
-	return 0;
-}
-
-/* Map an extent into a file. */
-int
-xfs_bmap_map_extent(
-	struct xfs_mount	*mp,
-	struct xfs_defer_ops	*dfops,
-	struct xfs_inode	*ip,
-	struct xfs_bmbt_irec	*PREV)
-{
-	if (!xfs_bmap_is_update_needed(PREV))
-		return 0;
-
-	return __xfs_bmap_add(mp, dfops, XFS_BMAP_MAP, ip,
-			XFS_DATA_FORK, PREV);
-}
-
-/* Unmap an extent out of a file. */
-int
-xfs_bmap_unmap_extent(
-	struct xfs_mount	*mp,
-	struct xfs_defer_ops	*dfops,
-	struct xfs_inode	*ip,
-	struct xfs_bmbt_irec	*PREV)
-{
-	if (!xfs_bmap_is_update_needed(PREV))
-		return 0;
-
-	return __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,
-			XFS_DATA_FORK, PREV);
-}
-
-/*
- * Process one of the deferred bmap operations.  We pass back the
- * btree cursor to maintain our lock on the bmapbt between calls.
- */
-int
-xfs_bmap_finish_one(
-	struct xfs_trans		*tp,
-	struct xfs_defer_ops		*dfops,
-	struct xfs_inode		*ip,
-	enum xfs_bmap_intent_type	type,
-	int				whichfork,
-	xfs_fileoff_t			startoff,
-	xfs_fsblock_t			startblock,
-	xfs_filblks_t			blockcount,
-	xfs_exntst_t			state)
-{
-	struct xfs_bmbt_irec		bmap;
-	int				nimaps = 1;
-	xfs_fsblock_t			firstfsb;
-	int				flags = XFS_BMAPI_REMAP;
-	int				done;
-	int				error = 0;
-
-	bmap.br_startblock = startblock;
-	bmap.br_startoff = startoff;
-	bmap.br_blockcount = blockcount;
-	bmap.br_state = state;
-
-	trace_xfs_bmap_deferred(tp->t_mountp,
-			XFS_FSB_TO_AGNO(tp->t_mountp, startblock), type,
-			XFS_FSB_TO_AGBNO(tp->t_mountp, startblock),
-			ip->i_ino, whichfork, startoff, blockcount, state);
-
-	if (whichfork != XFS_DATA_FORK && whichfork != XFS_ATTR_FORK)
-		return -EFSCORRUPTED;
-	if (whichfork == XFS_ATTR_FORK)
-		flags |= XFS_BMAPI_ATTRFORK;
-
-	if (XFS_TEST_ERROR(false, tp->t_mountp,
-			XFS_ERRTAG_BMAP_FINISH_ONE,
-			XFS_RANDOM_BMAP_FINISH_ONE))
-		return -EIO;
-
-	switch (type) {
-	case XFS_BMAP_MAP:
-		firstfsb = bmap.br_startblock;
-		error = xfs_bmapi_write(tp, ip, bmap.br_startoff,
-					bmap.br_blockcount, flags, &firstfsb,
-					bmap.br_blockcount, &bmap, &nimaps,
-					dfops);
-		break;
-	case XFS_BMAP_UNMAP:
-		error = xfs_bunmapi(tp, ip, bmap.br_startoff,
-				bmap.br_blockcount, flags, 1, &firstfsb,
-				dfops, &done);
-		ASSERT(done);
-		break;
-	default:
-		ASSERT(0);
-		error = -EFSCORRUPTED;
-	}
-
-	return error;
-}
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_bmap.h package_partclone/src/xfs/libxfs/xfs_bmap.h
--- package_partclone_orig/src/xfs/libxfs/xfs_bmap.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_bmap.h	2019-11-12 13:59:47.916149884 -0300
@@ -32,7 +32,7 @@ extern kmem_zone_t	*xfs_bmap_free_item_z
  */
 struct xfs_bmalloca {
 	xfs_fsblock_t		*firstblock; /* i/o first block allocated */
-	struct xfs_defer_ops	*dfops;	/* bmap freelist */
+	struct xfs_bmap_free	*flist;	/* bmap freelist */
 	struct xfs_trans	*tp;	/* transaction pointer */
 	struct xfs_inode	*ip;	/* incore inode pointer */
 	struct xfs_bmbt_irec	prev;	/* extent before the new one */
@@ -54,7 +54,7 @@ struct xfs_bmalloca {
 	bool			wasdel;	/* replacing a delayed allocation */
 	bool			aeof;	/* allocated space at eof */
 	bool			conv;	/* overwriting unwritten extents */
-	int			datatype;/* data type being allocated */
+	char			userdata;/* userdata mask */
 	int			flags;
 };

@@ -62,13 +62,33 @@ struct xfs_bmalloca {
  * List of extents to be free "later".
  * The list is kept sorted on xbf_startblock.
  */
-struct xfs_extent_free_item
+typedef struct xfs_bmap_free_item
 {
-	xfs_fsblock_t		xefi_startblock;/* starting fs block number */
-	xfs_extlen_t		xefi_blockcount;/* number of blocks in extent */
-	struct list_head	xefi_list;
-	struct xfs_owner_info	xefi_oinfo;	/* extent owner */
-};
+	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
+	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
+	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */
+} xfs_bmap_free_item_t;
+
+/*
+ * Header for free extent list.
+ *
+ * xbf_low is used by the allocator to activate the lowspace algorithm -
+ * when free space is running low the extent allocator may choose to
+ * allocate an extent from an AG without leaving sufficient space for
+ * a btree split when inserting the new extent.  In this case the allocator
+ * will enable the lowspace algorithm which is supposed to allow further
+ * allocations (such as btree splits and newroots) to allocate from
+ * sequential AGs.  In order to avoid locking AGs out of order the lowspace
+ * algorithm will start searching for free space from AG 0.  If the correct
+ * transaction reservations have been made then this algorithm will eventually
+ * find all the space it needs.
+ */
+typedef	struct xfs_bmap_free
+{
+	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
+	int			xbf_count;	/* count of items on list */
+	int			xbf_low;	/* alloc in low mode */
+} xfs_bmap_free_t;

 #define	XFS_BMAP_MAX_NMAP	4

@@ -97,19 +117,6 @@ struct xfs_extent_free_item
  */
 #define XFS_BMAPI_ZERO		0x080

-/*
- * Map the inode offset to the block given in ap->firstblock.  Primarily
- * used for reflink.  The range must be in a hole, and this flag cannot be
- * turned on with PREALLOC or CONVERT, and cannot be used on the attr fork.
- *
- * For bunmapi, this flag unmaps the range without adjusting quota, reducing
- * refcount, or freeing the blocks.
- */
-#define XFS_BMAPI_REMAP		0x100
-
-/* Map something in the CoW fork. */
-#define XFS_BMAPI_COWFORK	0x200
-
 #define XFS_BMAPI_FLAGS \
 	{ XFS_BMAPI_ENTIRE,	"ENTIRE" }, \
 	{ XFS_BMAPI_METADATA,	"METADATA" }, \
@@ -118,24 +125,12 @@ struct xfs_extent_free_item
 	{ XFS_BMAPI_IGSTATE,	"IGSTATE" }, \
 	{ XFS_BMAPI_CONTIG,	"CONTIG" }, \
 	{ XFS_BMAPI_CONVERT,	"CONVERT" }, \
-	{ XFS_BMAPI_ZERO,	"ZERO" }, \
-	{ XFS_BMAPI_REMAP,	"REMAP" }, \
-	{ XFS_BMAPI_COWFORK,	"COWFORK" }
+	{ XFS_BMAPI_ZERO,	"ZERO" }


 static inline int xfs_bmapi_aflag(int w)
 {
-	return (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK :
-	       (w == XFS_COW_FORK ? XFS_BMAPI_COWFORK : 0));
-}
-
-static inline int xfs_bmapi_whichfork(int bmapi_flags)
-{
-	if (bmapi_flags & XFS_BMAPI_COWFORK)
-		return XFS_COW_FORK;
-	else if (bmapi_flags & XFS_BMAPI_ATTRFORK)
-		return XFS_ATTR_FORK;
-	return XFS_DATA_FORK;
+	return (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);
 }

 /*
@@ -144,6 +139,12 @@ static inline int xfs_bmapi_whichfork(in
 #define	DELAYSTARTBLOCK		((xfs_fsblock_t)-1LL)
 #define	HOLESTARTBLOCK		((xfs_fsblock_t)-2LL)

+static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)
+{
+	((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \
+		(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);
+}
+
 /*
  * Flags for xfs_bmap_add_extent*.
  */
@@ -156,15 +157,13 @@ static inline int xfs_bmapi_whichfork(in
 #define BMAP_LEFT_VALID		(1 << 6)
 #define BMAP_RIGHT_VALID	(1 << 7)
 #define BMAP_ATTRFORK		(1 << 8)
-#define BMAP_COWFORK		(1 << 9)

 #define XFS_BMAP_EXT_FLAGS \
 	{ BMAP_LEFT_CONTIG,	"LC" }, \
 	{ BMAP_RIGHT_CONTIG,	"RC" }, \
 	{ BMAP_LEFT_FILLING,	"LF" }, \
 	{ BMAP_RIGHT_FILLING,	"RF" }, \
-	{ BMAP_ATTRFORK,	"ATTR" }, \
-	{ BMAP_COWFORK,		"COW" }
+	{ BMAP_ATTRFORK,	"ATTR" }


 /*
@@ -190,13 +189,13 @@ void	xfs_bmap_trace_exlist(struct xfs_in
 #define	XFS_BMAP_TRACE_EXLIST(ip,c,w)
 #endif

-void	xfs_trim_extent(struct xfs_bmbt_irec *irec, xfs_fileoff_t bno,
-		xfs_filblks_t len);
 int	xfs_bmap_add_attrfork(struct xfs_inode *ip, int size, int rsvd);
 void	xfs_bmap_local_to_extents_empty(struct xfs_inode *ip, int whichfork);
-void	xfs_bmap_add_free(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
-			  xfs_fsblock_t bno, xfs_filblks_t len,
-			  struct xfs_owner_info *oinfo);
+void	xfs_bmap_add_free(struct xfs_mount *mp, struct xfs_bmap_free *flist,
+			  xfs_fsblock_t bno, xfs_filblks_t len);
+void	xfs_bmap_cancel(struct xfs_bmap_free *flist);
+int	xfs_bmap_finish(struct xfs_trans **tp, struct xfs_bmap_free *flist,
+			struct xfs_inode *ip);
 void	xfs_bmap_compute_maxlevels(struct xfs_mount *mp, int whichfork);
 int	xfs_bmap_first_unused(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_extlen_t len, xfs_fileoff_t *unused, int whichfork);
@@ -210,41 +209,27 @@ int	xfs_bmap_read_extents(struct xfs_tra
 int	xfs_bmapi_read(struct xfs_inode *ip, xfs_fileoff_t bno,
 		xfs_filblks_t len, struct xfs_bmbt_irec *mval,
 		int *nmap, int flags);
+int	xfs_bmapi_delay(struct xfs_inode *ip, xfs_fileoff_t bno,
+		xfs_filblks_t len, struct xfs_bmbt_irec *mval,
+		int *nmap, int flags);
 int	xfs_bmapi_write(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
 		xfs_fsblock_t *firstblock, xfs_extlen_t total,
 		struct xfs_bmbt_irec *mval, int *nmap,
-		struct xfs_defer_ops *dfops);
-int	__xfs_bunmapi(struct xfs_trans *tp, struct xfs_inode *ip,
-		xfs_fileoff_t bno, xfs_filblks_t *rlen, int flags,
-		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
-		struct xfs_defer_ops *dfops);
+		struct xfs_bmap_free *flist);
 int	xfs_bunmapi(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
 		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
-		struct xfs_defer_ops *dfops, int *done);
-int	xfs_bmap_del_extent_delay(struct xfs_inode *ip, int whichfork,
-		xfs_extnum_t *idx, struct xfs_bmbt_irec *got,
-		struct xfs_bmbt_irec *del);
-void	xfs_bmap_del_extent_cow(struct xfs_inode *ip, xfs_extnum_t *idx,
-		struct xfs_bmbt_irec *got, struct xfs_bmbt_irec *del);
+		struct xfs_bmap_free *flist, int *done);
 int	xfs_check_nostate_extents(struct xfs_ifork *ifp, xfs_extnum_t idx,
 		xfs_extnum_t num);
 uint	xfs_default_attroffset(struct xfs_inode *ip);
 int	xfs_bmap_shift_extents(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
 		int *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
-		struct xfs_defer_ops *dfops, enum shift_direction direction,
+		struct xfs_bmap_free *flist, enum shift_direction direction,
 		int num_exts);
 int	xfs_bmap_split_extent(struct xfs_inode *ip, xfs_fileoff_t split_offset);
-struct xfs_bmbt_rec_host *
-	xfs_bmap_search_extents(struct xfs_inode *ip, xfs_fileoff_t bno,
-		int fork, int *eofp, xfs_extnum_t *lastxp,
-		struct xfs_bmbt_irec *gotp, struct xfs_bmbt_irec *prevp);
-int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, int whichfork,
-		xfs_fileoff_t aoff, xfs_filblks_t len,
-		struct xfs_bmbt_irec *got, struct xfs_bmbt_irec *prev,
-		xfs_extnum_t *lastx, int eof);

 struct xfs_bmbt_rec_host *
 	xfs_bmap_search_extents(struct xfs_inode *ip, xfs_fileoff_t bno,
@@ -253,26 +238,4 @@ struct xfs_bmbt_rec_host *
 				struct xfs_bmbt_irec *prevp);


-enum xfs_bmap_intent_type {
-	XFS_BMAP_MAP = 1,
-	XFS_BMAP_UNMAP,
-};
-
-struct xfs_bmap_intent {
-	struct list_head			bi_list;
-	enum xfs_bmap_intent_type		bi_type;
-	struct xfs_inode			*bi_owner;
-	int					bi_whichfork;
-	struct xfs_bmbt_irec			bi_bmap;
-};
-
-int	xfs_bmap_finish_one(struct xfs_trans *tp, struct xfs_defer_ops *dfops,
-		struct xfs_inode *ip, enum xfs_bmap_intent_type type,
-		int whichfork, xfs_fileoff_t startoff, xfs_fsblock_t startblock,
-		xfs_filblks_t blockcount, xfs_exntst_t state);
-int	xfs_bmap_map_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
-		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
-int	xfs_bmap_unmap_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
-		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
-
 #endif	/* __XFS_BMAP_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_btree.c package_partclone/src/xfs/libxfs/xfs_btree.c
--- package_partclone_orig/src/xfs/libxfs/xfs_btree.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_btree.c	2019-11-12 13:59:47.918149884 -0300
@@ -23,7 +23,6 @@
 #include "xfs_trans_resv.h"
 #include "xfs_bit.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_trans.h"
 #include "xfs_btree.h"
@@ -40,15 +39,15 @@ kmem_zone_t	*xfs_btree_cur_zone;
  * Btree magic numbers.
  */
 static const __uint32_t xfs_magics[2][XFS_BTNUM_MAX] = {
-	{ XFS_ABTB_MAGIC, XFS_ABTC_MAGIC, 0, XFS_BMAP_MAGIC, XFS_IBT_MAGIC,
-	  XFS_FIBT_MAGIC, 0 },
-	{ XFS_ABTB_CRC_MAGIC, XFS_ABTC_CRC_MAGIC, XFS_RMAP_CRC_MAGIC,
-	  XFS_BMAP_CRC_MAGIC, XFS_IBT_CRC_MAGIC, XFS_FIBT_CRC_MAGIC,
-	  XFS_REFC_CRC_MAGIC }
+	{ XFS_ABTB_MAGIC, XFS_ABTC_MAGIC, XFS_BMAP_MAGIC, XFS_IBT_MAGIC,
+	  XFS_FIBT_MAGIC },
+	{ XFS_ABTB_CRC_MAGIC, XFS_ABTC_CRC_MAGIC,
+	  XFS_BMAP_CRC_MAGIC, XFS_IBT_CRC_MAGIC, XFS_FIBT_CRC_MAGIC }
 };
 #define xfs_btree_magic(cur) \
 	xfs_magics[!!((cur)->bc_flags & XFS_BTREE_CRC_BLOCKS)][cur->bc_btnum]

+
 STATIC int				/* error (0 or EFSCORRUPTED) */
 xfs_btree_check_lblock(
 	struct xfs_btree_cur	*cur,	/* btree cursor */
@@ -291,21 +290,6 @@ xfs_btree_sblock_verify_crc(
 	return true;
 }

-static int
-xfs_btree_free_block(
-	struct xfs_btree_cur	*cur,
-	struct xfs_buf		*bp)
-{
-	int			error;
-
-	error = cur->bc_ops->free_block(cur, bp);
-	if (!error) {
-		xfs_trans_binval(cur->bc_tp, bp);
-		XFS_BTREE_STATS_INC(cur, free);
-	}
-	return error;
-}
-
 /*
  * Delete the btree cursor.
  */
@@ -425,50 +409,6 @@ xfs_btree_dup_cursor(
  * into a btree block (xfs_btree_*_offset) or return a pointer to the given
  * record, key or pointer (xfs_btree_*_addr).  Note that all addressing
  * inside the btree block is done using indices starting at one, not zero!
- *
- * If XFS_BTREE_OVERLAPPING is set, then this btree supports keys containing
- * overlapping intervals.  In such a tree, records are still sorted lowest to
- * highest and indexed by the smallest key value that refers to the record.
- * However, nodes are different: each pointer has two associated keys -- one
- * indexing the lowest key available in the block(s) below (the same behavior
- * as the key in a regular btree) and another indexing the highest key
- * available in the block(s) below.  Because records are /not/ sorted by the
- * highest key, all leaf block updates require us to compute the highest key
- * that matches any record in the leaf and to recursively update the high keys
- * in the nodes going further up in the tree, if necessary.  Nodes look like
- * this:
- *
- *		+--------+-----+-----+-----+-----+-----+-------+-------+-----+
- * Non-Leaf:	| header | lo1 | hi1 | lo2 | hi2 | ... | ptr 1 | ptr 2 | ... |
- *		+--------+-----+-----+-----+-----+-----+-------+-------+-----+
- *
- * To perform an interval query on an overlapped tree, perform the usual
- * depth-first search and use the low and high keys to decide if we can skip
- * that particular node.  If a leaf node is reached, return the records that
- * intersect the interval.  Note that an interval query may return numerous
- * entries.  For a non-overlapped tree, simply search for the record associated
- * with the lowest key and iterate forward until a non-matching record is
- * found.  Section 14.3 ("Interval Trees") of _Introduction to Algorithms_ by
- * Cormen, Leiserson, Rivest, and Stein (2nd or 3rd ed. only) discuss this in
- * more detail.
- *
- * Why do we care about overlapping intervals?  Let's say you have a bunch of
- * reverse mapping records on a reflink filesystem:
- *
- * 1: +- file A startblock B offset C length D -----------+
- * 2:      +- file E startblock F offset G length H --------------+
- * 3:      +- file I startblock F offset J length K --+
- * 4:                                                        +- file L... --+
- *
- * Now say we want to map block (B+D) into file A at offset (C+D).  Ideally,
- * we'd simply increment the length of record 1.  But how do we find the record
- * that ends at (B+D-1) (i.e. record 1)?  A LE lookup of (B+D-1) would return
- * record 3 because the keys are ordered first by startblock.  An interval
- * query would return records 1 and 2 because they both overlap (B+D-1), and
- * from that we can pick out record 1 as the appropriate left neighbor.
- *
- * In the non-overlapped case you can do a LE lookup and decrement the cursor
- * because a record's interval must end before the next record.
  */

 /*
@@ -520,18 +460,6 @@ xfs_btree_key_offset(
 }

 /*
- * Calculate offset of the n-th high key in a btree block.
- */
-STATIC size_t
-xfs_btree_high_key_offset(
-	struct xfs_btree_cur	*cur,
-	int			n)
-{
-	return xfs_btree_block_len(cur) +
-		(n - 1) * cur->bc_ops->key_len + (cur->bc_ops->key_len / 2);
-}
-
-/*
  * Calculate offset of the n-th block pointer in a btree block.
  */
 STATIC size_t
@@ -572,19 +500,6 @@ xfs_btree_key_addr(
 }

 /*
- * Return a pointer to the n-th high key in the btree block.
- */
-STATIC union xfs_btree_key *
-xfs_btree_high_key_addr(
-	struct xfs_btree_cur	*cur,
-	int			n,
-	struct xfs_btree_block	*block)
-{
-	return (union xfs_btree_key *)
-		((char *)block + xfs_btree_high_key_offset(cur, n));
-}
-
-/*
  * Return a pointer to the n-th block pointer in the btree block.
  */
 STATIC union xfs_btree_ptr *
@@ -609,12 +524,12 @@ xfs_btree_ptr_addr(
  */
 STATIC struct xfs_btree_block *
 xfs_btree_get_iroot(
-	struct xfs_btree_cur	*cur)
+       struct xfs_btree_cur    *cur)
 {
-	struct xfs_ifork	*ifp;
+       struct xfs_ifork        *ifp;

-	ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);
-	return (struct xfs_btree_block *)ifp->if_broot;
+       ifp = XFS_IFORK_PTR(cur->bc_private.b.ip, cur->bc_private.b.whichfork);
+       return (struct xfs_btree_block *)ifp->if_broot;
 }

 /*
@@ -1210,12 +1125,6 @@ xfs_btree_set_refs(
 	case XFS_BTNUM_BMAP:
 		xfs_buf_set_ref(bp, XFS_BMAP_BTREE_REF);
 		break;
-	case XFS_BTNUM_RMAP:
-		xfs_buf_set_ref(bp, XFS_RMAP_BTREE_REF);
-		break;
-	case XFS_BTNUM_REFC:
-		xfs_buf_set_ref(bp, XFS_REFC_BTREE_REF);
-		break;
 	default:
 		ASSERT(0);
 	}
@@ -1814,10 +1723,6 @@ xfs_btree_lookup(

 	XFS_BTREE_STATS_INC(cur, lookup);

-	/* No such thing as a zero-level tree. */
-	if (cur->bc_nlevels == 0)
-		return -EFSCORRUPTED;
-
 	block = NULL;
 	keyno = 0;

@@ -1955,214 +1860,32 @@ error0:
 	return error;
 }

-/* Find the high key storage area from a regular key. */
-STATIC union xfs_btree_key *
-xfs_btree_high_key_from_key(
-	struct xfs_btree_cur	*cur,
-	union xfs_btree_key	*key)
-{
-	ASSERT(cur->bc_flags & XFS_BTREE_OVERLAPPING);
-	return (union xfs_btree_key *)((char *)key +
-			(cur->bc_ops->key_len / 2));
-}
-
-/* Determine the low (and high if overlapped) keys of a leaf block */
-STATIC void
-xfs_btree_get_leaf_keys(
-	struct xfs_btree_cur	*cur,
-	struct xfs_btree_block	*block,
-	union xfs_btree_key	*key)
-{
-	union xfs_btree_key	max_hkey;
-	union xfs_btree_key	hkey;
-	union xfs_btree_rec	*rec;
-	union xfs_btree_key	*high;
-	int			n;
-
-	rec = xfs_btree_rec_addr(cur, 1, block);
-	cur->bc_ops->init_key_from_rec(key, rec);
-
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING) {
-
-		cur->bc_ops->init_high_key_from_rec(&max_hkey, rec);
-		for (n = 2; n <= xfs_btree_get_numrecs(block); n++) {
-			rec = xfs_btree_rec_addr(cur, n, block);
-			cur->bc_ops->init_high_key_from_rec(&hkey, rec);
-			if (cur->bc_ops->diff_two_keys(cur, &hkey, &max_hkey)
-					> 0)
-				max_hkey = hkey;
-		}
-
-		high = xfs_btree_high_key_from_key(cur, key);
-		memcpy(high, &max_hkey, cur->bc_ops->key_len / 2);
-	}
-}
-
-/* Determine the low (and high if overlapped) keys of a node block */
-STATIC void
-xfs_btree_get_node_keys(
-	struct xfs_btree_cur	*cur,
-	struct xfs_btree_block	*block,
-	union xfs_btree_key	*key)
-{
-	union xfs_btree_key	*hkey;
-	union xfs_btree_key	*max_hkey;
-	union xfs_btree_key	*high;
-	int			n;
-
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING) {
-		memcpy(key, xfs_btree_key_addr(cur, 1, block),
-				cur->bc_ops->key_len / 2);
-
-		max_hkey = xfs_btree_high_key_addr(cur, 1, block);
-		for (n = 2; n <= xfs_btree_get_numrecs(block); n++) {
-			hkey = xfs_btree_high_key_addr(cur, n, block);
-			if (cur->bc_ops->diff_two_keys(cur, hkey, max_hkey) > 0)
-				max_hkey = hkey;
-		}
-
-		high = xfs_btree_high_key_from_key(cur, key);
-		memcpy(high, max_hkey, cur->bc_ops->key_len / 2);
-	} else {
-		memcpy(key, xfs_btree_key_addr(cur, 1, block),
-				cur->bc_ops->key_len);
-	}
-}
-
-/* Derive the keys for any btree block. */
-STATIC void
-xfs_btree_get_keys(
-	struct xfs_btree_cur	*cur,
-	struct xfs_btree_block	*block,
-	union xfs_btree_key	*key)
-{
-	if (be16_to_cpu(block->bb_level) == 0)
-		xfs_btree_get_leaf_keys(cur, block, key);
-	else
-		xfs_btree_get_node_keys(cur, block, key);
-}
-
-/*
- * Decide if we need to update the parent keys of a btree block.  For
- * a standard btree this is only necessary if we're updating the first
- * record/key.  For an overlapping btree, we must always update the
- * keys because the highest key can be in any of the records or keys
- * in the block.
- */
-static inline bool
-xfs_btree_needs_key_update(
-	struct xfs_btree_cur	*cur,
-	int			ptr)
-{
-	return (cur->bc_flags & XFS_BTREE_OVERLAPPING) || ptr == 1;
-}
-
-/*
- * Update the low and high parent keys of the given level, progressing
- * towards the root.  If force_all is false, stop if the keys for a given
- * level do not need updating.
- */
-STATIC int
-__xfs_btree_updkeys(
-	struct xfs_btree_cur	*cur,
-	int			level,
-	struct xfs_btree_block	*block,
-	struct xfs_buf		*bp0,
-	bool			force_all)
-{
-	union xfs_btree_key	key;	/* keys from current level */
-	union xfs_btree_key	*lkey;	/* keys from the next level up */
-	union xfs_btree_key	*hkey;
-	union xfs_btree_key	*nlkey;	/* keys from the next level up */
-	union xfs_btree_key	*nhkey;
-	struct xfs_buf		*bp;
-	int			ptr;
-
-	ASSERT(cur->bc_flags & XFS_BTREE_OVERLAPPING);
-
-	/* Exit if there aren't any parent levels to update. */
-	if (level + 1 >= cur->bc_nlevels)
-		return 0;
-
-	trace_xfs_btree_updkeys(cur, level, bp0);
-
-	lkey = &key;
-	hkey = xfs_btree_high_key_from_key(cur, lkey);
-	xfs_btree_get_keys(cur, block, lkey);
-	for (level++; level < cur->bc_nlevels; level++) {
-#ifdef DEBUG
-		int		error;
-#endif
-		block = xfs_btree_get_block(cur, level, &bp);
-		trace_xfs_btree_updkeys(cur, level, bp);
-#ifdef DEBUG
-		error = xfs_btree_check_block(cur, block, level, bp);
-		if (error) {
-			XFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);
-			return error;
-		}
-#endif
-		ptr = cur->bc_ptrs[level];
-		nlkey = xfs_btree_key_addr(cur, ptr, block);
-		nhkey = xfs_btree_high_key_addr(cur, ptr, block);
-		if (!force_all &&
-		    !(cur->bc_ops->diff_two_keys(cur, nlkey, lkey) != 0 ||
-		      cur->bc_ops->diff_two_keys(cur, nhkey, hkey) != 0))
-			break;
-		xfs_btree_copy_keys(cur, nlkey, lkey, 1);
-		xfs_btree_log_keys(cur, bp, ptr, ptr);
-		if (level + 1 >= cur->bc_nlevels)
-			break;
-		xfs_btree_get_node_keys(cur, block, lkey);
-	}
-
-	return 0;
-}
-
-/* Update all the keys from some level in cursor back to the root. */
-STATIC int
-xfs_btree_updkeys_force(
-	struct xfs_btree_cur	*cur,
-	int			level)
-{
-	struct xfs_buf		*bp;
-	struct xfs_btree_block	*block;
-
-	block = xfs_btree_get_block(cur, level, &bp);
-	return __xfs_btree_updkeys(cur, level, block, bp, true);
-}
-
 /*
- * Update the parent keys of the given level, progressing towards the root.
+ * Update keys at all levels from here to the root along the cursor's path.
  */
 STATIC int
-xfs_btree_update_keys(
+xfs_btree_updkey(
 	struct xfs_btree_cur	*cur,
+	union xfs_btree_key	*keyp,
 	int			level)
 {
 	struct xfs_btree_block	*block;
 	struct xfs_buf		*bp;
 	union xfs_btree_key	*kp;
-	union xfs_btree_key	key;
 	int			ptr;

-	ASSERT(level >= 0);
-
-	block = xfs_btree_get_block(cur, level, &bp);
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING)
-		return __xfs_btree_updkeys(cur, level, block, bp, false);
-
 	XFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);
 	XFS_BTREE_TRACE_ARGIK(cur, level, keyp);

+	ASSERT(!(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) || level >= 1);
+
 	/*
 	 * Go up the tree from this level toward the root.
 	 * At each level, update the key value to the value input.
 	 * Stop when we reach a level where the cursor isn't pointing
 	 * at the first entry in the block.
 	 */
-	xfs_btree_get_keys(cur, block, &key);
-	for (level++, ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {
+	for (ptr = 1; ptr == 1 && level < cur->bc_nlevels; level++) {
 #ifdef DEBUG
 		int		error;
 #endif
@@ -2176,7 +1899,7 @@ xfs_btree_update_keys(
 #endif
 		ptr = cur->bc_ptrs[level];
 		kp = xfs_btree_key_addr(cur, ptr, block);
-		xfs_btree_copy_keys(cur, kp, &key, 1);
+		xfs_btree_copy_keys(cur, kp, keyp, 1);
 		xfs_btree_log_keys(cur, bp, ptr, ptr);
 	}

@@ -2228,9 +1951,12 @@ xfs_btree_update(
 					    ptr, LASTREC_UPDATE);
 	}

-	/* Pass new key value up to our parent. */
-	if (xfs_btree_needs_key_update(cur, ptr)) {
-		error = xfs_btree_update_keys(cur, 0);
+	/* Updating first rec in leaf. Pass new key value up to our parent. */
+	if (ptr == 1) {
+		union xfs_btree_key	key;
+
+		cur->bc_ops->init_key_from_rec(&key, rec);
+		error = xfs_btree_updkey(cur, &key, 1);
 		if (error)
 			goto error0;
 	}
@@ -2253,19 +1979,18 @@ xfs_btree_lshift(
 	int			level,
 	int			*stat)		/* success/failure */
 {
+	union xfs_btree_key	key;		/* btree key */
 	struct xfs_buf		*lbp;		/* left buffer pointer */
 	struct xfs_btree_block	*left;		/* left btree block */
 	int			lrecs;		/* left record count */
 	struct xfs_buf		*rbp;		/* right buffer pointer */
 	struct xfs_btree_block	*right;		/* right btree block */
-	struct xfs_btree_cur	*tcur;		/* temporary btree cursor */
 	int			rrecs;		/* right record count */
 	union xfs_btree_ptr	lptr;		/* left btree pointer */
 	union xfs_btree_key	*rkp = NULL;	/* right btree key */
 	union xfs_btree_ptr	*rpp = NULL;	/* right address pointer */
 	union xfs_btree_rec	*rrp = NULL;	/* right record pointer */
 	int			error;		/* error return value */
-	int			i;

 	XFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);
 	XFS_BTREE_TRACE_ARGI(cur, level);
@@ -2395,33 +2120,18 @@ xfs_btree_lshift(
 			xfs_btree_rec_addr(cur, 2, right),
 			-1, rrecs);
 		xfs_btree_log_recs(cur, rbp, 1, rrecs);
-	}

-	/*
-	 * Using a temporary cursor, update the parent key values of the
-	 * block on the left.
-	 */
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING) {
-		error = xfs_btree_dup_cursor(cur, &tcur);
-		if (error)
-			goto error0;
-		i = xfs_btree_firstrec(tcur, level);
-		XFS_WANT_CORRUPTED_GOTO(tcur->bc_mp, i == 1, error0);
-
-		error = xfs_btree_decrement(tcur, level, &i);
-		if (error)
-			goto error1;
-
-		/* Update the parent high keys of the left block, if needed. */
-		error = xfs_btree_update_keys(tcur, level);
-		if (error)
-			goto error1;
-
-		xfs_btree_del_cursor(tcur, XFS_BTREE_NOERROR);
+		/*
+		 * If it's the first record in the block, we'll need a key
+		 * structure to pass up to the next level (updkey).
+		 */
+		cur->bc_ops->init_key_from_rec(&key,
+			xfs_btree_rec_addr(cur, 1, right));
+		rkp = &key;
 	}

-	/* Update the parent keys of the right block. */
-	error = xfs_btree_update_keys(cur, level);
+	/* Update the parent key values of right. */
+	error = xfs_btree_updkey(cur, rkp, level + 1);
 	if (error)
 		goto error0;

@@ -2440,11 +2150,6 @@ out0:
 error0:
 	XFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);
 	return error;
-
-error1:
-	XFS_BTREE_TRACE_CURSOR(tcur, XBT_ERROR);
-	xfs_btree_del_cursor(tcur, XFS_BTREE_ERROR);
-	return error;
 }

 /*
@@ -2457,6 +2162,7 @@ xfs_btree_rshift(
 	int			level,
 	int			*stat)		/* success/failure */
 {
+	union xfs_btree_key	key;		/* btree key */
 	struct xfs_buf		*lbp;		/* left buffer pointer */
 	struct xfs_btree_block	*left;		/* left btree block */
 	struct xfs_buf		*rbp;		/* right buffer pointer */
@@ -2565,6 +2271,12 @@ xfs_btree_rshift(
 		/* Now put the new data in, and log it. */
 		xfs_btree_copy_recs(cur, rrp, lrp, 1);
 		xfs_btree_log_recs(cur, rbp, 1, rrecs + 1);
+
+		cur->bc_ops->init_key_from_rec(&key, rrp);
+		rkp = &key;
+
+		ASSERT(cur->bc_ops->recs_inorder(cur, rrp,
+			xfs_btree_rec_addr(cur, 2, right)));
 	}

 	/*
@@ -2584,21 +2296,13 @@ xfs_btree_rshift(
 	if (error)
 		goto error0;
 	i = xfs_btree_lastrec(tcur, level);
-	XFS_WANT_CORRUPTED_GOTO(tcur->bc_mp, i == 1, error0);
+	XFS_WANT_CORRUPTED_GOTO(cur->bc_mp, i == 1, error0);

 	error = xfs_btree_increment(tcur, level, &i);
 	if (error)
 		goto error1;

-	/* Update the parent high keys of the left block, if needed. */
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING) {
-		error = xfs_btree_update_keys(cur, level);
-		if (error)
-			goto error1;
-	}
-
-	/* Update the parent keys of the right block. */
-	error = xfs_btree_update_keys(tcur, level);
+	error = xfs_btree_updkey(tcur, rkp, level + 1);
 	if (error)
 		goto error1;

@@ -2699,11 +2403,6 @@ __xfs_btree_split(

 	XFS_BTREE_STATS_ADD(cur, moves, rrecs);

-	/* Adjust numrecs for the later get_*_keys() calls. */
-	lrecs -= rrecs;
-	xfs_btree_set_numrecs(left, lrecs);
-	xfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);
-
 	/*
 	 * Copy btree block entries from the left block over to the
 	 * new block, the right. Update the right block and log the
@@ -2729,15 +2428,14 @@ __xfs_btree_split(
 		}
 #endif

-		/* Copy the keys & pointers to the new block. */
 		xfs_btree_copy_keys(cur, rkp, lkp, rrecs);
 		xfs_btree_copy_ptrs(cur, rpp, lpp, rrecs);

 		xfs_btree_log_keys(cur, rbp, 1, rrecs);
 		xfs_btree_log_ptrs(cur, rbp, 1, rrecs);

-		/* Stash the keys of the new block for later insertion. */
-		xfs_btree_get_node_keys(cur, right, key);
+		/* Grab the keys to the entries moved to the right block */
+		xfs_btree_copy_keys(cur, key, rkp, 1);
 	} else {
 		/* It's a leaf.  Move records.  */
 		union xfs_btree_rec	*lrp;	/* left record pointer */
@@ -2746,23 +2444,27 @@ __xfs_btree_split(
 		lrp = xfs_btree_rec_addr(cur, src_index, left);
 		rrp = xfs_btree_rec_addr(cur, 1, right);

-		/* Copy records to the new block. */
 		xfs_btree_copy_recs(cur, rrp, lrp, rrecs);
 		xfs_btree_log_recs(cur, rbp, 1, rrecs);

-		/* Stash the keys of the new block for later insertion. */
-		xfs_btree_get_leaf_keys(cur, right, key);
+		cur->bc_ops->init_key_from_rec(key,
+			xfs_btree_rec_addr(cur, 1, right));
 	}

+
 	/*
 	 * Find the left block number by looking in the buffer.
-	 * Adjust sibling pointers.
+	 * Adjust numrecs, sibling pointers.
 	 */
 	xfs_btree_get_sibling(cur, left, &rrptr, XFS_BB_RIGHTSIB);
 	xfs_btree_set_sibling(cur, right, &rrptr, XFS_BB_RIGHTSIB);
 	xfs_btree_set_sibling(cur, right, &lptr, XFS_BB_LEFTSIB);
 	xfs_btree_set_sibling(cur, left, &rptr, XFS_BB_RIGHTSIB);

+	lrecs -= rrecs;
+	xfs_btree_set_numrecs(left, lrecs);
+	xfs_btree_set_numrecs(right, xfs_btree_get_numrecs(right) + rrecs);
+
 	xfs_btree_log_block(cur, rbp, XFS_BB_ALL_BITS);
 	xfs_btree_log_block(cur, lbp, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB);

@@ -2778,14 +2480,6 @@ __xfs_btree_split(
 		xfs_btree_set_sibling(cur, rrblock, &rptr, XFS_BB_LEFTSIB);
 		xfs_btree_log_block(cur, rrbp, XFS_BB_LEFTSIB);
 	}
-
-	/* Update the parent high keys of the left block, if needed. */
-	if (cur->bc_flags & XFS_BTREE_OVERLAPPING) {
-		error = xfs_btree_update_keys(cur, level);
-		if (error)
-			goto error0;
-	}
-
 	/*
 	 * If the cursor is really in the right block, move it there.
 	 * If it's just pointing past the last entry in left, then we'll
@@ -3093,7 +2787,6 @@ xfs_btree_new_root(
 		bp = lbp;
 		nptr = 2;
 	}
-
 	/* Fill in the new block's btree header and log it. */
 	xfs_btree_init_block_cur(cur, nbp, cur->bc_nlevels, 2);
 	xfs_btree_log_block(cur, nbp, XFS_BB_ALL_BITS);
@@ -3102,24 +2795,19 @@ xfs_btree_new_root(

 	/* Fill in the key data in the new root. */
 	if (xfs_btree_get_level(left) > 0) {
-		/*
-		 * Get the keys for the left block's keys and put them directly
-		 * in the parent block.  Do the same for the right block.
-		 */
-		xfs_btree_get_node_keys(cur, left,
-				xfs_btree_key_addr(cur, 1, new));
-		xfs_btree_get_node_keys(cur, right,
-				xfs_btree_key_addr(cur, 2, new));
+		xfs_btree_copy_keys(cur,
+				xfs_btree_key_addr(cur, 1, new),
+				xfs_btree_key_addr(cur, 1, left), 1);
+		xfs_btree_copy_keys(cur,
+				xfs_btree_key_addr(cur, 2, new),
+				xfs_btree_key_addr(cur, 1, right), 1);
 	} else {
-		/*
-		 * Get the keys for the left block's records and put them
-		 * directly in the parent block.  Do the same for the right
-		 * block.
-		 */
-		xfs_btree_get_leaf_keys(cur, left,
-			xfs_btree_key_addr(cur, 1, new));
-		xfs_btree_get_leaf_keys(cur, right,
-			xfs_btree_key_addr(cur, 2, new));
+		cur->bc_ops->init_key_from_rec(
+				xfs_btree_key_addr(cur, 1, new),
+				xfs_btree_rec_addr(cur, 1, left));
+		cur->bc_ops->init_key_from_rec(
+				xfs_btree_key_addr(cur, 2, new),
+				xfs_btree_rec_addr(cur, 1, right));
 	}
 	xfs_btree_log_keys(cur, nbp, 1, 2);

@@ -3155,9 +2843,10 @@ xfs_btree_make_block_unfull(
 	int			*index,	/* new tree index */
 	union xfs_btree_ptr	*nptr,	/* new btree ptr */
 	struct xfs_btree_cur	**ncur,	/* new btree cursor */
-	union xfs_btree_key	*key,	/* key of new block */
+	union xfs_btree_rec	*nrec,	/* new record */
 	int			*stat)
 {
+	union xfs_btree_key	key;	/* new btree key value */
 	int			error = 0;

 	if ((cur->bc_flags & XFS_BTREE_ROOT_IN_INODE) &&
@@ -3167,7 +2856,6 @@ xfs_btree_make_block_unfull(
 		if (numrecs < cur->bc_ops->get_dmaxrecs(cur, level)) {
 			/* A root block that can be made bigger. */
 			xfs_iroot_realloc(ip, 1, cur->bc_private.b.whichfork);
-			*stat = 1;
 		} else {
 			/* A root block that needs replacing */
 			int	logflags = 0;
@@ -3203,12 +2891,13 @@ xfs_btree_make_block_unfull(
 	 * If this works we have to re-set our variables because we
 	 * could be in a different block now.
 	 */
-	error = xfs_btree_split(cur, level, nptr, key, ncur, stat);
+	error = xfs_btree_split(cur, level, nptr, &key, ncur, stat);
 	if (error || *stat == 0)
 		return error;


 	*index = cur->bc_ptrs[level];
+	cur->bc_ops->init_rec_from_key(&key, nrec);
 	return 0;
 }

@@ -3221,17 +2910,16 @@ xfs_btree_insrec(
 	struct xfs_btree_cur	*cur,	/* btree cursor */
 	int			level,	/* level to insert record at */
 	union xfs_btree_ptr	*ptrp,	/* i/o: block number inserted */
-	union xfs_btree_rec	*rec,	/* record to insert */
-	union xfs_btree_key	*key,	/* i/o: block key for ptrp */
+	union xfs_btree_rec	*recp,	/* i/o: record data inserted */
 	struct xfs_btree_cur	**curp,	/* output: new cursor replacing cur */
 	int			*stat)	/* success/failure */
 {
 	struct xfs_btree_block	*block;	/* btree block */
 	struct xfs_buf		*bp;	/* buffer for block */
+	union xfs_btree_key	key;	/* btree key */
 	union xfs_btree_ptr	nptr;	/* new block ptr */
 	struct xfs_btree_cur	*ncur;	/* new btree cursor */
-	union xfs_btree_key	nkey;	/* new block key */
-	union xfs_btree_key	*lkey;
+	union xfs_btree_rec	nrec;	/* new record count */
 	int			optr;	/* old key/record index */
 	int			ptr;	/* key/record index */
 	int			numrecs;/* number of records */
@@ -3239,13 +2927,11 @@ xfs_btree_insrec(
 #ifdef DEBUG
 	int			i;
 #endif
-	xfs_daddr_t		old_bn;

 	XFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);
-	XFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, &rec);
+	XFS_BTREE_TRACE_ARGIPR(cur, level, *ptrp, recp);

 	ncur = NULL;
-	lkey = &nkey;

 	/*
 	 * If we have an external root pointer, and we've made it to the
@@ -3268,13 +2954,15 @@ xfs_btree_insrec(
 		return 0;
 	}

+	/* Make a key out of the record data to be inserted, and save it. */
+	cur->bc_ops->init_key_from_rec(&key, recp);
+
 	optr = ptr;

 	XFS_BTREE_STATS_INC(cur, insrec);

 	/* Get pointers to the btree buffer and block. */
 	block = xfs_btree_get_block(cur, level, &bp);
-	old_bn = bp ? bp->b_bn : XFS_BUF_DADDR_NULL;
 	numrecs = xfs_btree_get_numrecs(block);

 #ifdef DEBUG
@@ -3285,10 +2973,10 @@ xfs_btree_insrec(
 	/* Check that the new entry is being inserted in the right place. */
 	if (ptr <= numrecs) {
 		if (level == 0) {
-			ASSERT(cur->bc_ops->recs_inorder(cur, rec,
+			ASSERT(cur->bc_ops->recs_inorder(cur, recp,
 				xfs_btree_rec_addr(cur, ptr, block)));
 		} else {
-			ASSERT(cur->bc_ops->keys_inorder(cur, key,
+			ASSERT(cur->bc_ops->keys_inorder(cur, &key,
 				xfs_btree_key_addr(cur, ptr, block)));
 		}
 	}
@@ -3301,7 +2989,7 @@ xfs_btree_insrec(
 	xfs_btree_set_ptr_null(cur, &nptr);
 	if (numrecs == cur->bc_ops->get_maxrecs(cur, level)) {
 		error = xfs_btree_make_block_unfull(cur, level, numrecs,
-					&optr, &ptr, &nptr, &ncur, lkey, stat);
+					&optr, &ptr, &nptr, &ncur, &nrec, stat);
 		if (error || *stat == 0)
 			goto error0;
 	}
@@ -3351,7 +3039,7 @@ xfs_btree_insrec(
 #endif

 		/* Now put the new data in, bump numrecs and log it. */
-		xfs_btree_copy_keys(cur, kp, key, 1);
+		xfs_btree_copy_keys(cur, kp, &key, 1);
 		xfs_btree_copy_ptrs(cur, pp, ptrp, 1);
 		numrecs++;
 		xfs_btree_set_numrecs(block, numrecs);
@@ -3372,7 +3060,7 @@ xfs_btree_insrec(
 		xfs_btree_shift_recs(cur, rp, 1, numrecs - ptr + 1);

 		/* Now put the new data in, bump numrecs and log it. */
-		xfs_btree_copy_recs(cur, rp, rec, 1);
+		xfs_btree_copy_recs(cur, rp, recp, 1);
 		xfs_btree_set_numrecs(block, ++numrecs);
 		xfs_btree_log_recs(cur, bp, ptr, numrecs);
 #ifdef DEBUG
@@ -3386,18 +3074,9 @@ xfs_btree_insrec(
 	/* Log the new number of records in the btree header. */
 	xfs_btree_log_block(cur, bp, XFS_BB_NUMRECS);

-	/*
-	 * If we just inserted into a new tree block, we have to
-	 * recalculate nkey here because nkey is out of date.
-	 *
-	 * Otherwise we're just updating an existing block (having shoved
-	 * some records into the new tree block), so use the regular key
-	 * update mechanism.
-	 */
-	if (bp && bp->b_bn != old_bn) {
-		xfs_btree_get_keys(cur, block, lkey);
-	} else if (xfs_btree_needs_key_update(cur, optr)) {
-		error = xfs_btree_update_keys(cur, level);
+	/* If we inserted at the start of a block, update the parents' keys. */
+	if (optr == 1) {
+		error = xfs_btree_updkey(cur, &key, level + 1);
 		if (error)
 			goto error0;
 	}
@@ -3407,7 +3086,7 @@ xfs_btree_insrec(
 	 * we are at the far right edge of the tree, update it.
 	 */
 	if (xfs_btree_is_lastrec(cur, block, level)) {
-		cur->bc_ops->update_lastrec(cur, block, rec,
+		cur->bc_ops->update_lastrec(cur, block, recp,
 					    ptr, LASTREC_INSREC);
 	}

@@ -3417,7 +3096,7 @@ xfs_btree_insrec(
 	 */
 	*ptrp = nptr;
 	if (!xfs_btree_ptr_is_null(cur, &nptr)) {
-		xfs_btree_copy_keys(cur, key, lkey, 1);
+		*recp = nrec;
 		*curp = ncur;
 	}

@@ -3448,20 +3127,14 @@ xfs_btree_insert(
 	union xfs_btree_ptr	nptr;	/* new block number (split result) */
 	struct xfs_btree_cur	*ncur;	/* new cursor (split result) */
 	struct xfs_btree_cur	*pcur;	/* previous level's cursor */
-	union xfs_btree_key	bkey;	/* key of block to insert */
-	union xfs_btree_key	*key;
 	union xfs_btree_rec	rec;	/* record to insert */

 	level = 0;
 	ncur = NULL;
 	pcur = cur;
-	key = &bkey;

 	xfs_btree_set_ptr_null(cur, &nptr);
-
-	/* Make a key out of the record data to be inserted, and save it. */
 	cur->bc_ops->init_rec_from_cur(cur, &rec);
-	cur->bc_ops->init_key_from_rec(key, &rec);

 	/*
 	 * Loop going up the tree, starting at the leaf level.
@@ -3473,8 +3146,7 @@ xfs_btree_insert(
 		 * Insert nrec/nptr into this level of the tree.
 		 * Note if we fail, nptr will be null.
 		 */
-		error = xfs_btree_insrec(pcur, level, &nptr, &rec, key,
-				&ncur, &i);
+		error = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);
 		if (error) {
 			if (pcur != cur)
 				xfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);
@@ -3537,7 +3209,6 @@ xfs_btree_kill_iroot(
 	int			level;
 	int			index;
 	int			numrecs;
-	int			error;
 #ifdef DEBUG
 	union xfs_btree_ptr	ptr;
 	int			i;
@@ -3601,6 +3272,8 @@ xfs_btree_kill_iroot(
 	cpp = xfs_btree_ptr_addr(cur, 1, cblock);
 #ifdef DEBUG
 	for (i = 0; i < numrecs; i++) {
+		int		error;
+
 		error = xfs_btree_check_ptr(cur, cpp, i, level - 1);
 		if (error) {
 			XFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);
@@ -3610,11 +3283,8 @@ xfs_btree_kill_iroot(
 #endif
 	xfs_btree_copy_ptrs(cur, pp, cpp, numrecs);

-	error = xfs_btree_free_block(cur, cbp);
-	if (error) {
-		XFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);
-		return error;
-	}
+	cur->bc_ops->free_block(cur, cbp);
+	XFS_BTREE_STATS_INC(cur, free);

 	cur->bc_bufs[level - 1] = NULL;
 	be16_add_cpu(&block->bb_level, -1);
@@ -3647,12 +3317,14 @@ xfs_btree_kill_root(
 	 */
 	cur->bc_ops->set_root(cur, newroot, -1);

-	error = xfs_btree_free_block(cur, bp);
+	error = cur->bc_ops->free_block(cur, bp);
 	if (error) {
 		XFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);
 		return error;
 	}

+	XFS_BTREE_STATS_INC(cur, free);
+
 	cur->bc_bufs[level] = NULL;
 	cur->bc_ra[level] = 0;
 	cur->bc_nlevels--;
@@ -3698,6 +3370,8 @@ xfs_btree_delrec(
 	struct xfs_buf		*bp;		/* buffer for block */
 	int			error;		/* error return value */
 	int			i;		/* loop counter */
+	union xfs_btree_key	key;		/* storage for keyp */
+	union xfs_btree_key	*keyp = &key;	/* passed to the next level */
 	union xfs_btree_ptr	lptr;		/* left sibling block ptr */
 	struct xfs_buf		*lbp;		/* left buffer pointer */
 	struct xfs_btree_block	*left;		/* left btree block */
@@ -3768,6 +3442,13 @@ xfs_btree_delrec(
 			xfs_btree_log_keys(cur, bp, ptr, numrecs - 1);
 			xfs_btree_log_ptrs(cur, bp, ptr, numrecs - 1);
 		}
+
+		/*
+		 * If it's the first record in the block, we'll need to pass a
+		 * key up to the next level (updkey).
+		 */
+		if (ptr == 1)
+			keyp = xfs_btree_key_addr(cur, 1, block);
 	} else {
 		/* It's a leaf. operate on records */
 		if (ptr < numrecs) {
@@ -3776,6 +3457,16 @@ xfs_btree_delrec(
 				-1, numrecs - ptr);
 			xfs_btree_log_recs(cur, bp, ptr, numrecs - 1);
 		}
+
+		/*
+		 * If it's the first record in the block, we'll need a key
+		 * structure to pass up to the next level (updkey).
+		 */
+		if (ptr == 1) {
+			cur->bc_ops->init_key_from_rec(&key,
+					xfs_btree_rec_addr(cur, 1, block));
+			keyp = &key;
+		}
 	}

 	/*
@@ -3842,8 +3533,8 @@ xfs_btree_delrec(
 	 * If we deleted the leftmost entry in the block, update the
 	 * key values above us in the tree.
 	 */
-	if (xfs_btree_needs_key_update(cur, ptr)) {
-		error = xfs_btree_update_keys(cur, level);
+	if (ptr == 1) {
+		error = xfs_btree_updkey(cur, keyp, level + 1);
 		if (error)
 			goto error0;
 	}
@@ -4139,9 +3830,10 @@ xfs_btree_delrec(
 	}

 	/* Free the deleted block. */
-	error = xfs_btree_free_block(cur, rbp);
+	error = cur->bc_ops->free_block(cur, rbp);
 	if (error)
 		goto error0;
+	XFS_BTREE_STATS_INC(cur, free);

 	/*
 	 * If we joined with the left neighbor, set the buffer in the
@@ -4172,16 +3864,6 @@ xfs_btree_delrec(
 	if (level > 0)
 		cur->bc_ptrs[level]--;

-	/*
-	 * We combined blocks, so we have to update the parent keys if the
-	 * btree supports overlapped intervals.  However, bc_ptrs[level + 1]
-	 * points to the old block so that the caller knows which record to
-	 * delete.  Therefore, the caller must be savvy enough to call updkeys
-	 * for us if we return stat == 2.  The other exit points from this
-	 * function don't require deletions further up the tree, so they can
-	 * call updkeys directly.
-	 */
-
 	XFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);
 	/* Return value means the next level up has something to do. */
 	*stat = 2;
@@ -4207,7 +3889,6 @@ xfs_btree_delete(
 	int			error;	/* error return value */
 	int			level;
 	int			i;
-	bool			joined = false;

 	XFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);

@@ -4221,18 +3902,6 @@ xfs_btree_delete(
 		error = xfs_btree_delrec(cur, level, &i);
 		if (error)
 			goto error0;
-		if (i == 2)
-			joined = true;
-	}
-
-	/*
-	 * If we combined blocks as part of deleting the record, delrec won't
-	 * have updated the parent high keys so we have to do that here.
-	 */
-	if (joined && (cur->bc_flags & XFS_BTREE_OVERLAPPING)) {
-		error = xfs_btree_updkeys_force(cur, 0);
-		if (error)
-			goto error0;
 	}

 	if (i == 0) {
@@ -4295,81 +3964,6 @@ xfs_btree_get_rec(
 	return 0;
 }

-/* Visit a block in a btree. */
-STATIC int
-xfs_btree_visit_block(
-	struct xfs_btree_cur		*cur,
-	int				level,
-	xfs_btree_visit_blocks_fn	fn,
-	void				*data)
-{
-	struct xfs_btree_block		*block;
-	struct xfs_buf			*bp;
-	union xfs_btree_ptr		rptr;
-	int				error;
-
-	/* do right sibling readahead */
-	xfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);
-	block = xfs_btree_get_block(cur, level, &bp);
-
-	/* process the block */
-	error = fn(cur, level, data);
-	if (error)
-		return error;
-
-	/* now read rh sibling block for next iteration */
-	xfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);
-	if (xfs_btree_ptr_is_null(cur, &rptr))
-		return -ENOENT;
-
-	return xfs_btree_lookup_get_block(cur, level, &rptr, &block);
-}
-
-
-/* Visit every block in a btree. */
-int
-xfs_btree_visit_blocks(
-	struct xfs_btree_cur		*cur,
-	xfs_btree_visit_blocks_fn	fn,
-	void				*data)
-{
-	union xfs_btree_ptr		lptr;
-	int				level;
-	struct xfs_btree_block		*block = NULL;
-	int				error = 0;
-
-	cur->bc_ops->init_ptr_from_cur(cur, &lptr);
-
-	/* for each level */
-	for (level = cur->bc_nlevels - 1; level >= 0; level--) {
-		/* grab the left hand block */
-		error = xfs_btree_lookup_get_block(cur, level, &lptr, &block);
-		if (error)
-			return error;
-
-		/* readahead the left most block for the next level down */
-		if (level > 0) {
-			union xfs_btree_ptr     *ptr;
-
-			ptr = xfs_btree_ptr_addr(cur, 1, block);
-			xfs_btree_readahead_ptr(cur, ptr, 1);
-
-			/* save for the next iteration of the loop */
-			lptr = *ptr;
-		}
-
-		/* for each buffer in the level */
-		do {
-			error = xfs_btree_visit_block(cur, level, fn, data);
-		} while (!error);
-
-		if (error != -ENOENT)
-			return error;
-	}
-
-	return 0;
-}
-
 /*
  * Change the owner of a btree.
  *
@@ -4394,27 +3988,26 @@ xfs_btree_visit_blocks(
  * just queue the modified buffer as delayed write buffer so the transaction
  * recovery completion writes the changes to disk.
  */
-struct xfs_btree_block_change_owner_info {
-	__uint64_t		new_owner;
-	struct list_head	*buffer_list;
-};
-
 static int
 xfs_btree_block_change_owner(
 	struct xfs_btree_cur	*cur,
 	int			level,
-	void			*data)
+	__uint64_t		new_owner,
+	struct list_head	*buffer_list)
 {
-	struct xfs_btree_block_change_owner_info	*bbcoi = data;
 	struct xfs_btree_block	*block;
 	struct xfs_buf		*bp;
+	union xfs_btree_ptr     rptr;
+
+	/* do right sibling readahead */
+	xfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);

 	/* modify the owner */
 	block = xfs_btree_get_block(cur, level, &bp);
 	if (cur->bc_flags & XFS_BTREE_LONG_PTRS)
-		block->bb_u.l.bb_owner = cpu_to_be64(bbcoi->new_owner);
+		block->bb_u.l.bb_owner = cpu_to_be64(new_owner);
 	else
-		block->bb_u.s.bb_owner = cpu_to_be32(bbcoi->new_owner);
+		block->bb_u.s.bb_owner = cpu_to_be32(new_owner);

 	/*
 	 * If the block is a root block hosted in an inode, we might not have a
@@ -4428,14 +4021,19 @@ xfs_btree_block_change_owner(
 			xfs_trans_ordered_buf(cur->bc_tp, bp);
 			xfs_btree_log_block(cur, bp, XFS_BB_OWNER);
 		} else {
-			xfs_buf_delwri_queue(bp, bbcoi->buffer_list);
+			xfs_buf_delwri_queue(bp, buffer_list);
 		}
 	} else {
 		ASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);
 		ASSERT(level == cur->bc_nlevels - 1);
 	}

-	return 0;
+	/* now read rh sibling block for next iteration */
+	xfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);
+	if (xfs_btree_ptr_is_null(cur, &rptr))
+		return -ENOENT;
+
+	return xfs_btree_lookup_get_block(cur, level, &rptr, &block);
 }

 int
@@ -4444,13 +4042,43 @@ xfs_btree_change_owner(
 	__uint64_t		new_owner,
 	struct list_head	*buffer_list)
 {
-	struct xfs_btree_block_change_owner_info	bbcoi;
+	union xfs_btree_ptr     lptr;
+	int			level;
+	struct xfs_btree_block	*block = NULL;
+	int			error = 0;

-	bbcoi.new_owner = new_owner;
-	bbcoi.buffer_list = buffer_list;
+	cur->bc_ops->init_ptr_from_cur(cur, &lptr);

-	return xfs_btree_visit_blocks(cur, xfs_btree_block_change_owner,
-			&bbcoi);
+	/* for each level */
+	for (level = cur->bc_nlevels - 1; level >= 0; level--) {
+		/* grab the left hand block */
+		error = xfs_btree_lookup_get_block(cur, level, &lptr, &block);
+		if (error)
+			return error;
+
+		/* readahead the left most block for the next level down */
+		if (level > 0) {
+			union xfs_btree_ptr     *ptr;
+
+			ptr = xfs_btree_ptr_addr(cur, 1, block);
+			xfs_btree_readahead_ptr(cur, ptr, 1);
+
+			/* save for the next iteration of the loop */
+			lptr = *ptr;
+		}
+
+		/* for each buffer in the level */
+		do {
+			error = xfs_btree_block_change_owner(cur, level,
+							     new_owner,
+							     buffer_list);
+		} while (!error);
+
+		if (error != -ENOENT)
+			return error;
+	}
+
+	return 0;
 }

 /**
@@ -4510,341 +4138,3 @@ xfs_btree_sblock_verify(

 	return true;
 }
-
-/*
- * Calculate the number of btree levels needed to store a given number of
- * records in a short-format btree.
- */
-uint
-xfs_btree_compute_maxlevels(
-	struct xfs_mount	*mp,
-	uint			*limits,
-	unsigned long		len)
-{
-	uint			level;
-	unsigned long		maxblocks;
-
-	maxblocks = (len + limits[0] - 1) / limits[0];
-	for (level = 1; maxblocks > 1; level++)
-		maxblocks = (maxblocks + limits[1] - 1) / limits[1];
-	return level;
-}
-
-/*
- * Query a regular btree for all records overlapping a given interval.
- * Start with a LE lookup of the key of low_rec and return all records
- * until we find a record with a key greater than the key of high_rec.
- */
-STATIC int
-xfs_btree_simple_query_range(
-	struct xfs_btree_cur		*cur,
-	union xfs_btree_key		*low_key,
-	union xfs_btree_key		*high_key,
-	xfs_btree_query_range_fn	fn,
-	void				*priv)
-{
-	union xfs_btree_rec		*recp;
-	union xfs_btree_key		rec_key;
-	__int64_t			diff;
-	int				stat;
-	bool				firstrec = true;
-	int				error;
-
-	ASSERT(cur->bc_ops->init_high_key_from_rec);
-	ASSERT(cur->bc_ops->diff_two_keys);
-
-	/*
-	 * Find the leftmost record.  The btree cursor must be set
-	 * to the low record used to generate low_key.
-	 */
-	stat = 0;
-	error = xfs_btree_lookup(cur, XFS_LOOKUP_LE, &stat);
-	if (error)
-		goto out;
-
-	/* Nothing?  See if there's anything to the right. */
-	if (!stat) {
-		error = xfs_btree_increment(cur, 0, &stat);
-		if (error)
-			goto out;
-	}
-
-	while (stat) {
-		/* Find the record. */
-		error = xfs_btree_get_rec(cur, &recp, &stat);
-		if (error || !stat)
-			break;
-
-		/* Skip if high_key(rec) < low_key. */
-		if (firstrec) {
-			cur->bc_ops->init_high_key_from_rec(&rec_key, recp);
-			firstrec = false;
-			diff = cur->bc_ops->diff_two_keys(cur, low_key,
-					&rec_key);
-			if (diff > 0)
-				goto advloop;
-		}
-
-		/* Stop if high_key < low_key(rec). */
-		cur->bc_ops->init_key_from_rec(&rec_key, recp);
-		diff = cur->bc_ops->diff_two_keys(cur, &rec_key, high_key);
-		if (diff > 0)
-			break;
-
-		/* Callback */
-		error = fn(cur, recp, priv);
-		if (error < 0 || error == XFS_BTREE_QUERY_RANGE_ABORT)
-			break;
-
-advloop:
-		/* Move on to the next record. */
-		error = xfs_btree_increment(cur, 0, &stat);
-		if (error)
-			break;
-	}
-
-out:
-	return error;
-}
-
-/*
- * Query an overlapped interval btree for all records overlapping a given
- * interval.  This function roughly follows the algorithm given in
- * "Interval Trees" of _Introduction to Algorithms_, which is section
- * 14.3 in the 2nd and 3rd editions.
- *
- * First, generate keys for the low and high records passed in.
- *
- * For any leaf node, generate the high and low keys for the record.
- * If the record keys overlap with the query low/high keys, pass the
- * record to the function iterator.
- *
- * For any internal node, compare the low and high keys of each
- * pointer against the query low/high keys.  If there's an overlap,
- * follow the pointer.
- *
- * As an optimization, we stop scanning a block when we find a low key
- * that is greater than the query's high key.
- */
-STATIC int
-xfs_btree_overlapped_query_range(
-	struct xfs_btree_cur		*cur,
-	union xfs_btree_key		*low_key,
-	union xfs_btree_key		*high_key,
-	xfs_btree_query_range_fn	fn,
-	void				*priv)
-{
-	union xfs_btree_ptr		ptr;
-	union xfs_btree_ptr		*pp;
-	union xfs_btree_key		rec_key;
-	union xfs_btree_key		rec_hkey;
-	union xfs_btree_key		*lkp;
-	union xfs_btree_key		*hkp;
-	union xfs_btree_rec		*recp;
-	struct xfs_btree_block		*block;
-	__int64_t			ldiff;
-	__int64_t			hdiff;
-	int				level;
-	struct xfs_buf			*bp;
-	int				i;
-	int				error;
-
-	/* Load the root of the btree. */
-	level = cur->bc_nlevels - 1;
-	cur->bc_ops->init_ptr_from_cur(cur, &ptr);
-	error = xfs_btree_lookup_get_block(cur, level, &ptr, &block);
-	if (error)
-		return error;
-	xfs_btree_get_block(cur, level, &bp);
-	trace_xfs_btree_overlapped_query_range(cur, level, bp);
-#ifdef DEBUG
-	error = xfs_btree_check_block(cur, block, level, bp);
-	if (error)
-		goto out;
-#endif
-	cur->bc_ptrs[level] = 1;
-
-	while (level < cur->bc_nlevels) {
-		block = xfs_btree_get_block(cur, level, &bp);
-
-		/* End of node, pop back towards the root. */
-		if (cur->bc_ptrs[level] > be16_to_cpu(block->bb_numrecs)) {
-pop_up:
-			if (level < cur->bc_nlevels - 1)
-				cur->bc_ptrs[level + 1]++;
-			level++;
-			continue;
-		}
-
-		if (level == 0) {
-			/* Handle a leaf node. */
-			recp = xfs_btree_rec_addr(cur, cur->bc_ptrs[0], block);
-
-			cur->bc_ops->init_high_key_from_rec(&rec_hkey, recp);
-			ldiff = cur->bc_ops->diff_two_keys(cur, &rec_hkey,
-					low_key);
-
-			cur->bc_ops->init_key_from_rec(&rec_key, recp);
-			hdiff = cur->bc_ops->diff_two_keys(cur, high_key,
-					&rec_key);
-
-			/*
-			 * If (record's high key >= query's low key) and
-			 *    (query's high key >= record's low key), then
-			 * this record overlaps the query range; callback.
-			 */
-			if (ldiff >= 0 && hdiff >= 0) {
-				error = fn(cur, recp, priv);
-				if (error < 0 ||
-				    error == XFS_BTREE_QUERY_RANGE_ABORT)
-					break;
-			} else if (hdiff < 0) {
-				/* Record is larger than high key; pop. */
-				goto pop_up;
-			}
-			cur->bc_ptrs[level]++;
-			continue;
-		}
-
-		/* Handle an internal node. */
-		lkp = xfs_btree_key_addr(cur, cur->bc_ptrs[level], block);
-		hkp = xfs_btree_high_key_addr(cur, cur->bc_ptrs[level], block);
-		pp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[level], block);
-
-		ldiff = cur->bc_ops->diff_two_keys(cur, hkp, low_key);
-		hdiff = cur->bc_ops->diff_two_keys(cur, high_key, lkp);
-
-		/*
-		 * If (pointer's high key >= query's low key) and
-		 *    (query's high key >= pointer's low key), then
-		 * this record overlaps the query range; follow pointer.
-		 */
-		if (ldiff >= 0 && hdiff >= 0) {
-			level--;
-			error = xfs_btree_lookup_get_block(cur, level, pp,
-					&block);
-			if (error)
-				goto out;
-			xfs_btree_get_block(cur, level, &bp);
-			trace_xfs_btree_overlapped_query_range(cur, level, bp);
-#ifdef DEBUG
-			error = xfs_btree_check_block(cur, block, level, bp);
-			if (error)
-				goto out;
-#endif
-			cur->bc_ptrs[level] = 1;
-			continue;
-		} else if (hdiff < 0) {
-			/* The low key is larger than the upper range; pop. */
-			goto pop_up;
-		}
-		cur->bc_ptrs[level]++;
-	}
-
-out:
-	/*
-	 * If we don't end this function with the cursor pointing at a record
-	 * block, a subsequent non-error cursor deletion will not release
-	 * node-level buffers, causing a buffer leak.  This is quite possible
-	 * with a zero-results range query, so release the buffers if we
-	 * failed to return any results.
-	 */
-	if (cur->bc_bufs[0] == NULL) {
-		for (i = 0; i < cur->bc_nlevels; i++) {
-			if (cur->bc_bufs[i]) {
-				xfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);
-				cur->bc_bufs[i] = NULL;
-				cur->bc_ptrs[i] = 0;
-				cur->bc_ra[i] = 0;
-			}
-		}
-	}
-
-	return error;
-}
-
-/*
- * Query a btree for all records overlapping a given interval of keys.  The
- * supplied function will be called with each record found; return one of the
- * XFS_BTREE_QUERY_RANGE_{CONTINUE,ABORT} values or the usual negative error
- * code.  This function returns XFS_BTREE_QUERY_RANGE_ABORT, zero, or a
- * negative error code.
- */
-int
-xfs_btree_query_range(
-	struct xfs_btree_cur		*cur,
-	union xfs_btree_irec		*low_rec,
-	union xfs_btree_irec		*high_rec,
-	xfs_btree_query_range_fn	fn,
-	void				*priv)
-{
-	union xfs_btree_rec		rec;
-	union xfs_btree_key		low_key;
-	union xfs_btree_key		high_key;
-
-	/* Find the keys of both ends of the interval. */
-	cur->bc_rec = *high_rec;
-	cur->bc_ops->init_rec_from_cur(cur, &rec);
-	cur->bc_ops->init_key_from_rec(&high_key, &rec);
-
-	cur->bc_rec = *low_rec;
-	cur->bc_ops->init_rec_from_cur(cur, &rec);
-	cur->bc_ops->init_key_from_rec(&low_key, &rec);
-
-	/* Enforce low key < high key. */
-	if (cur->bc_ops->diff_two_keys(cur, &low_key, &high_key) > 0)
-		return -EINVAL;
-
-	if (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))
-		return xfs_btree_simple_query_range(cur, &low_key,
-				&high_key, fn, priv);
-	return xfs_btree_overlapped_query_range(cur, &low_key, &high_key,
-			fn, priv);
-}
-
-/*
- * Calculate the number of blocks needed to store a given number of records
- * in a short-format (per-AG metadata) btree.
- */
-xfs_extlen_t
-xfs_btree_calc_size(
-	struct xfs_mount	*mp,
-	uint			*limits,
-	unsigned long long	len)
-{
-	int			level;
-	int			maxrecs;
-	xfs_extlen_t		rval;
-
-	maxrecs = limits[0];
-	for (level = 0, rval = 0; len > 1; level++) {
-		len += maxrecs - 1;
-		do_div(len, maxrecs);
-		maxrecs = limits[1];
-		rval += len;
-	}
-	return rval;
-}
-
-static int
-xfs_btree_count_blocks_helper(
-	struct xfs_btree_cur	*cur,
-	int			level,
-	void			*data)
-{
-	xfs_extlen_t		*blocks = data;
-	(*blocks)++;
-
-	return 0;
-}
-
-/* Count the blocks in a btree and return the result in *blocks. */
-int
-xfs_btree_count_blocks(
-	struct xfs_btree_cur	*cur,
-	xfs_extlen_t		*blocks)
-{
-	*blocks = 0;
-	return xfs_btree_visit_blocks(cur, xfs_btree_count_blocks_helper,
-			blocks);
-}
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_btree.h package_partclone/src/xfs/libxfs/xfs_btree.h
--- package_partclone_orig/src/xfs/libxfs/xfs_btree.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_btree.h	2019-11-12 13:59:47.919149884 -0300
@@ -19,7 +19,7 @@
 #define	__XFS_BTREE_H__

 struct xfs_buf;
-struct xfs_defer_ops;
+struct xfs_bmap_free;
 struct xfs_inode;
 struct xfs_mount;
 struct xfs_trans;
@@ -37,28 +37,18 @@ union xfs_btree_ptr {
 	__be64			l;	/* long form ptr */
 };

-/*
- * The in-core btree key.  Overlapping btrees actually store two keys
- * per pointer, so we reserve enough memory to hold both.  The __*bigkey
- * items should never be accessed directly.
- */
 union xfs_btree_key {
-	struct xfs_bmbt_key		bmbt;
-	xfs_bmdr_key_t			bmbr;	/* bmbt root block */
-	xfs_alloc_key_t			alloc;
-	struct xfs_inobt_key		inobt;
-	struct xfs_rmap_key		rmap;
-	struct xfs_rmap_key		__rmap_bigkey[2];
-	struct xfs_refcount_key		refc;
+	xfs_bmbt_key_t		bmbt;
+	xfs_bmdr_key_t		bmbr;	/* bmbt root block */
+	xfs_alloc_key_t		alloc;
+	xfs_inobt_key_t		inobt;
 };

 union xfs_btree_rec {
-	struct xfs_bmbt_rec		bmbt;
-	xfs_bmdr_rec_t			bmbr;	/* bmbt root block */
-	struct xfs_alloc_rec		alloc;
-	struct xfs_inobt_rec		inobt;
-	struct xfs_rmap_rec		rmap;
-	struct xfs_refcount_rec		refc;
+	xfs_bmbt_rec_t		bmbt;
+	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
+	xfs_alloc_rec_t		alloc;
+	xfs_inobt_rec_t		inobt;
 };

 /*
@@ -73,8 +63,6 @@ union xfs_btree_rec {
 #define	XFS_BTNUM_BMAP	((xfs_btnum_t)XFS_BTNUM_BMAPi)
 #define	XFS_BTNUM_INO	((xfs_btnum_t)XFS_BTNUM_INOi)
 #define	XFS_BTNUM_FINO	((xfs_btnum_t)XFS_BTNUM_FINOi)
-#define	XFS_BTNUM_RMAP	((xfs_btnum_t)XFS_BTNUM_RMAPi)
-#define	XFS_BTNUM_REFC	((xfs_btnum_t)XFS_BTNUM_REFCi)

 /*
  * For logging record fields.
@@ -107,8 +95,6 @@ do {    \
 	case XFS_BTNUM_BMAP: __XFS_BTREE_STATS_INC(__mp, bmbt, stat); break; \
 	case XFS_BTNUM_INO: __XFS_BTREE_STATS_INC(__mp, ibt, stat); break; \
 	case XFS_BTNUM_FINO: __XFS_BTREE_STATS_INC(__mp, fibt, stat); break; \
-	case XFS_BTNUM_RMAP: __XFS_BTREE_STATS_INC(__mp, rmap, stat); break; \
-	case XFS_BTNUM_REFC: __XFS_BTREE_STATS_INC(__mp, refcbt, stat); break; \
 	case XFS_BTNUM_MAX: ASSERT(0); __mp = __mp /* fucking gcc */ ; break; \
 	}       \
 } while (0)
@@ -129,15 +115,11 @@ do {    \
 		__XFS_BTREE_STATS_ADD(__mp, ibt, stat, val); break; \
 	case XFS_BTNUM_FINO:	\
 		__XFS_BTREE_STATS_ADD(__mp, fibt, stat, val); break; \
-	case XFS_BTNUM_RMAP:	\
-		__XFS_BTREE_STATS_ADD(__mp, rmap, stat, val); break; \
-	case XFS_BTNUM_REFC:	\
-		__XFS_BTREE_STATS_ADD(__mp, refcbt, stat, val); break; \
 	case XFS_BTNUM_MAX: ASSERT(0); __mp = __mp /* fucking gcc */ ; break; \
 	}       \
 } while (0)

-#define	XFS_BTREE_MAXLEVELS	9	/* max of all btrees */
+#define	XFS_BTREE_MAXLEVELS	8	/* max of all btrees */

 struct xfs_btree_ops {
 	/* size of the key and record structures */
@@ -176,25 +158,17 @@ struct xfs_btree_ops {
 	/* init values of btree structures */
 	void	(*init_key_from_rec)(union xfs_btree_key *key,
 				     union xfs_btree_rec *rec);
+	void	(*init_rec_from_key)(union xfs_btree_key *key,
+				     union xfs_btree_rec *rec);
 	void	(*init_rec_from_cur)(struct xfs_btree_cur *cur,
 				     union xfs_btree_rec *rec);
 	void	(*init_ptr_from_cur)(struct xfs_btree_cur *cur,
 				     union xfs_btree_ptr *ptr);
-	void	(*init_high_key_from_rec)(union xfs_btree_key *key,
-					  union xfs_btree_rec *rec);

 	/* difference between key value and cursor value */
 	__int64_t (*key_diff)(struct xfs_btree_cur *cur,
 			      union xfs_btree_key *key);

-	/*
-	 * Difference between key2 and key1 -- positive if key1 > key2,
-	 * negative if key1 < key2, and zero if equal.
-	 */
-	__int64_t (*diff_two_keys)(struct xfs_btree_cur *cur,
-				   union xfs_btree_key *key1,
-				   union xfs_btree_key *key2);
-
 	const struct xfs_buf_ops	*buf_ops;

 #if defined(DEBUG) || defined(XFS_WARN)
@@ -218,22 +192,6 @@ struct xfs_btree_ops {
 #define LASTREC_DELREC	2


-union xfs_btree_irec {
-	struct xfs_alloc_rec_incore	a;
-	struct xfs_bmbt_irec		b;
-	struct xfs_inobt_rec_incore	i;
-	struct xfs_rmap_irec		r;
-	struct xfs_refcount_irec	rc;
-};
-
-/* Per-AG btree private information. */
-union xfs_btree_cur_private {
-	struct {
-		unsigned long	nr_ops;		/* # record updates */
-		int		shape_changes;	/* # of extent splits */
-	} refc;
-};
-
 /*
  * Btree cursor structure.
  * This collects all information needed by the btree code in one place.
@@ -244,7 +202,11 @@ typedef struct xfs_btree_cur
 	struct xfs_mount	*bc_mp;	/* file system mount struct */
 	const struct xfs_btree_ops *bc_ops;
 	uint			bc_flags; /* btree features - below */
-	union xfs_btree_irec	bc_rec;	/* current insert/search record value */
+	union {
+		xfs_alloc_rec_incore_t	a;
+		xfs_bmbt_irec_t		b;
+		xfs_inobt_rec_incore_t	i;
+	}		bc_rec;		/* current insert/search record value */
 	struct xfs_buf	*bc_bufs[XFS_BTREE_MAXLEVELS];	/* buf ptr per level */
 	int		bc_ptrs[XFS_BTREE_MAXLEVELS];	/* key/record # */
 	__uint8_t	bc_ra[XFS_BTREE_MAXLEVELS];	/* readahead bits */
@@ -256,13 +218,11 @@ typedef struct xfs_btree_cur
 	union {
 		struct {			/* needed for BNO, CNT, INO */
 			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
-			struct xfs_defer_ops *dfops;	/* deferred updates */
 			xfs_agnumber_t	agno;	/* ag number */
-			union xfs_btree_cur_private	priv;
 		} a;
 		struct {			/* needed for BMAP */
 			struct xfs_inode *ip;	/* pointer to our inode */
-			struct xfs_defer_ops *dfops;	/* deferred updates */
+			struct xfs_bmap_free *flist;	/* list to free after */
 			xfs_fsblock_t	firstblock;	/* 1st blk allocated */
 			int		allocated;	/* count of alloced */
 			short		forksize;	/* fork's inode space */
@@ -278,7 +238,6 @@ typedef struct xfs_btree_cur
 #define XFS_BTREE_ROOT_IN_INODE		(1<<1)	/* root may be variable size */
 #define XFS_BTREE_LASTREC_UPDATE	(1<<2)	/* track last rec externally */
 #define XFS_BTREE_CRC_BLOCKS		(1<<3)	/* uses extended btree blocks */
-#define XFS_BTREE_OVERLAPPING		(1<<4)	/* overlapping intervals */


 #define	XFS_BTREE_NOERROR	0
@@ -515,26 +474,5 @@ static inline int xfs_btree_get_level(st

 bool xfs_btree_sblock_v5hdr_verify(struct xfs_buf *bp);
 bool xfs_btree_sblock_verify(struct xfs_buf *bp, unsigned int max_recs);
-uint xfs_btree_compute_maxlevels(struct xfs_mount *mp, uint *limits,
-				 unsigned long len);
-xfs_extlen_t xfs_btree_calc_size(struct xfs_mount *mp, uint *limits,
-		unsigned long long len);
-
-/* return codes */
-#define XFS_BTREE_QUERY_RANGE_CONTINUE	0	/* keep iterating */
-#define XFS_BTREE_QUERY_RANGE_ABORT	1	/* stop iterating */
-typedef int (*xfs_btree_query_range_fn)(struct xfs_btree_cur *cur,
-		union xfs_btree_rec *rec, void *priv);
-
-int xfs_btree_query_range(struct xfs_btree_cur *cur,
-		union xfs_btree_irec *low_rec, union xfs_btree_irec *high_rec,
-		xfs_btree_query_range_fn fn, void *priv);
-
-typedef int (*xfs_btree_visit_blocks_fn)(struct xfs_btree_cur *cur, int level,
-		void *data);
-int xfs_btree_visit_blocks(struct xfs_btree_cur *cur,
-		xfs_btree_visit_blocks_fn fn, void *data);
-
-int xfs_btree_count_blocks(struct xfs_btree_cur *cur, xfs_extlen_t *blocks);

 #endif	/* __XFS_BTREE_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_da_btree.c package_partclone/src/xfs/libxfs/xfs_da_btree.c
--- package_partclone_orig/src/xfs/libxfs/xfs_da_btree.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_da_btree.c	2019-11-12 13:59:47.920149884 -0300
@@ -2024,7 +2024,7 @@ xfs_da_grow_inode_int(
 	error = xfs_bmapi_write(tp, dp, *bno, count,
 			xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA|XFS_BMAPI_CONTIG,
 			args->firstblock, args->total, &map, &nmap,
-			args->dfops);
+			args->flist);
 	if (error)
 		return error;

@@ -2047,7 +2047,7 @@ xfs_da_grow_inode_int(
 			error = xfs_bmapi_write(tp, dp, b, c,
 					xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,
 					args->firstblock, args->total,
-					&mapp[mapi], &nmap, args->dfops);
+					&mapp[mapi], &nmap, args->flist);
 			if (error)
 				goto out_free_map;
 			if (nmap < 1)
@@ -2357,7 +2357,7 @@ xfs_da_shrink_inode(
 		 */
 		error = xfs_bunmapi(tp, dp, dead_blkno, count,
 				    xfs_bmapi_aflag(w), 0, args->firstblock,
-				    args->dfops, &done);
+				    args->flist, &done);
 		if (error == -ENOSPC) {
 			if (w != XFS_DATA_FORK)
 				break;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_da_btree.h package_partclone/src/xfs/libxfs/xfs_da_btree.h
--- package_partclone_orig/src/xfs/libxfs/xfs_da_btree.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_da_btree.h	2019-11-12 13:59:47.920149884 -0300
@@ -19,7 +19,7 @@
 #ifndef __XFS_DA_BTREE_H__
 #define	__XFS_DA_BTREE_H__

-struct xfs_defer_ops;
+struct xfs_bmap_free;
 struct xfs_inode;
 struct xfs_trans;
 struct zone;
@@ -70,7 +70,7 @@ typedef struct xfs_da_args {
 	xfs_ino_t	inumber;	/* input/output inode number */
 	struct xfs_inode *dp;		/* directory inode to manipulate */
 	xfs_fsblock_t	*firstblock;	/* ptr to firstblock for bmap calls */
-	struct xfs_defer_ops *dfops;	/* ptr to freelist for bmap_finish */
+	struct xfs_bmap_free *flist;	/* ptr to freelist for bmap_finish */
 	struct xfs_trans *trans;	/* current trans (changes over time) */
 	xfs_extlen_t	total;		/* total blocks needed, for 1st bmap */
 	int		whichfork;	/* data or attribute fork */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_da_format.c package_partclone/src/xfs/libxfs/xfs_da_format.c
--- package_partclone_orig/src/xfs/libxfs/xfs_da_format.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_da_format.c	2019-11-12 13:59:47.920149884 -0300
@@ -40,7 +40,8 @@ xfs_dir2_sf_entsize(
 	int count = sizeof(struct xfs_dir2_sf_entry);	/* namelen + offset */

 	count += len;					/* name */
-	count += hdr->i8count ? XFS_INO64_SIZE : XFS_INO32_SIZE; /* ino # */
+	count += hdr->i8count ? sizeof(xfs_dir2_ino8_t) :
+				sizeof(xfs_dir2_ino4_t); /* ino # */
 	return count;
 }

@@ -124,33 +125,33 @@ xfs_dir3_sfe_put_ftype(
 static xfs_ino_t
 xfs_dir2_sf_get_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
-	__uint8_t		*from)
+	xfs_dir2_inou_t		*from)
 {
 	if (hdr->i8count)
-		return get_unaligned_be64(from) & 0x00ffffffffffffffULL;
+		return get_unaligned_be64(&from->i8.i) & 0x00ffffffffffffffULL;
 	else
-		return get_unaligned_be32(from);
+		return get_unaligned_be32(&from->i4.i);
 }

 static void
 xfs_dir2_sf_put_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
-	__uint8_t		*to,
+	xfs_dir2_inou_t		*to,
 	xfs_ino_t		ino)
 {
 	ASSERT((ino & 0xff00000000000000ULL) == 0);

 	if (hdr->i8count)
-		put_unaligned_be64(ino, to);
+		put_unaligned_be64(ino, &to->i8.i);
 	else
-		put_unaligned_be32(ino, to);
+		put_unaligned_be32(ino, &to->i4.i);
 }

 static xfs_ino_t
 xfs_dir2_sf_get_parent_ino(
 	struct xfs_dir2_sf_hdr	*hdr)
 {
-	return xfs_dir2_sf_get_ino(hdr, hdr->parent);
+	return xfs_dir2_sf_get_ino(hdr, &hdr->parent);
 }

 static void
@@ -158,7 +159,7 @@ xfs_dir2_sf_put_parent_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
 	xfs_ino_t		ino)
 {
-	xfs_dir2_sf_put_ino(hdr, hdr->parent, ino);
+	xfs_dir2_sf_put_ino(hdr, &hdr->parent, ino);
 }

 /*
@@ -172,7 +173,8 @@ xfs_dir2_sfe_get_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
 	struct xfs_dir2_sf_entry *sfep)
 {
-	return xfs_dir2_sf_get_ino(hdr, &sfep->name[sfep->namelen]);
+	return xfs_dir2_sf_get_ino(hdr,
+				(xfs_dir2_inou_t *)&sfep->name[sfep->namelen]);
 }

 static void
@@ -181,7 +183,8 @@ xfs_dir2_sfe_put_ino(
 	struct xfs_dir2_sf_entry *sfep,
 	xfs_ino_t		ino)
 {
-	xfs_dir2_sf_put_ino(hdr, &sfep->name[sfep->namelen], ino);
+	xfs_dir2_sf_put_ino(hdr,
+			    (xfs_dir2_inou_t *)&sfep->name[sfep->namelen], ino);
 }

 static xfs_ino_t
@@ -189,7 +192,8 @@ xfs_dir3_sfe_get_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
 	struct xfs_dir2_sf_entry *sfep)
 {
-	return xfs_dir2_sf_get_ino(hdr, &sfep->name[sfep->namelen + 1]);
+	return xfs_dir2_sf_get_ino(hdr,
+			(xfs_dir2_inou_t *)&sfep->name[sfep->namelen + 1]);
 }

 static void
@@ -198,7 +202,8 @@ xfs_dir3_sfe_put_ino(
 	struct xfs_dir2_sf_entry *sfep,
 	xfs_ino_t		ino)
 {
-	xfs_dir2_sf_put_ino(hdr, &sfep->name[sfep->namelen + 1], ino);
+	xfs_dir2_sf_put_ino(hdr,
+			(xfs_dir2_inou_t *)&sfep->name[sfep->namelen + 1], ino);
 }


diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_da_format.h package_partclone/src/xfs/libxfs/xfs_da_format.h
--- package_partclone_orig/src/xfs/libxfs/xfs_da_format.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_da_format.h	2019-11-12 13:59:47.921149884 -0300
@@ -192,6 +192,12 @@ typedef	__uint16_t	xfs_dir2_data_off_t;
 typedef uint		xfs_dir2_data_aoff_t;	/* argument form */

 /*
+ * Normalized offset (in a data block) of the entry, really xfs_dir2_data_off_t.
+ * Only need 16 bits, this is the byte offset into the single block form.
+ */
+typedef struct { __uint8_t i[2]; } __arch_pack xfs_dir2_sf_off_t;
+
+/*
  * Offset in data space of a data entry.
  */
 typedef	__uint32_t	xfs_dir2_dataptr_t;
@@ -208,10 +214,22 @@ typedef	xfs_off_t	xfs_dir2_off_t;
  */
 typedef	__uint32_t	xfs_dir2_db_t;

-#define XFS_INO32_SIZE	4
-#define XFS_INO64_SIZE	8
-#define XFS_INO64_DIFF	(XFS_INO64_SIZE - XFS_INO32_SIZE)
+/*
+ * Inode number stored as 8 8-bit values.
+ */
+typedef	struct { __uint8_t i[8]; } xfs_dir2_ino8_t;
+
+/*
+ * Inode number stored as 4 8-bit values.
+ * Works a lot of the time, when all the inode numbers in a directory
+ * fit in 32 bits.
+ */
+typedef struct { __uint8_t i[4]; } xfs_dir2_ino4_t;

+typedef union {
+	xfs_dir2_ino8_t	i8;
+	xfs_dir2_ino4_t	i4;
+} xfs_dir2_inou_t;
 #define	XFS_DIR2_MAX_SHORT_INUM	((xfs_ino_t)0xffffffffULL)

 /*
@@ -228,38 +246,39 @@ typedef	__uint32_t	xfs_dir2_db_t;
 typedef struct xfs_dir2_sf_hdr {
 	__uint8_t		count;		/* count of entries */
 	__uint8_t		i8count;	/* count of 8-byte inode #s */
-	__uint8_t		parent[8];	/* parent dir inode number */
-} __packed xfs_dir2_sf_hdr_t;
+	xfs_dir2_inou_t		parent;		/* parent dir inode number */
+} __arch_pack xfs_dir2_sf_hdr_t;

 typedef struct xfs_dir2_sf_entry {
 	__u8			namelen;	/* actual name length */
-	__u8			offset[2];	/* saved offset */
+	xfs_dir2_sf_off_t	offset;		/* saved offset */
 	__u8			name[];		/* name, variable size */
 	/*
 	 * A single byte containing the file type field follows the inode
 	 * number for version 3 directory entries.
 	 *
-	 * A 64-bit or 32-bit inode number follows here, at a variable offset
-	 * after the name.
+	 * A xfs_dir2_ino8_t or xfs_dir2_ino4_t follows here, at a
+	 * variable offset after the name.
 	 */
-} xfs_dir2_sf_entry_t;
+} __arch_pack xfs_dir2_sf_entry_t;

 static inline int xfs_dir2_sf_hdr_size(int i8count)
 {
 	return sizeof(struct xfs_dir2_sf_hdr) -
-		(i8count == 0) * XFS_INO64_DIFF;
+		(i8count == 0) *
+		(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));
 }

 static inline xfs_dir2_data_aoff_t
 xfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)
 {
-	return get_unaligned_be16(sfep->offset);
+	return get_unaligned_be16(&sfep->offset.i);
 }

 static inline void
 xfs_dir2_sf_put_offset(xfs_dir2_sf_entry_t *sfep, xfs_dir2_data_aoff_t off)
 {
-	put_unaligned_be16(off, sfep->offset);
+	put_unaligned_be16(off, &sfep->offset.i);
 }

 static inline struct xfs_dir2_sf_entry *
@@ -629,7 +648,6 @@ typedef struct xfs_attr_shortform {
 	struct xfs_attr_sf_hdr {	/* constant-structure header block */
 		__be16	totsize;	/* total bytes in shortform list */
 		__u8	count;	/* count of active entries */
-		__u8	padding;
 	} hdr;
 	struct xfs_attr_sf_entry {
 		__uint8_t namelen;	/* actual length of name (no NULL) */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_dir2.c package_partclone/src/xfs/libxfs/xfs_dir2.c
--- package_partclone_orig/src/xfs/libxfs/xfs_dir2.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_dir2.c	2019-11-12 13:59:47.921149884 -0300
@@ -21,7 +21,6 @@
 #include "xfs_log_format.h"
 #include "xfs_trans_resv.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_da_format.h"
 #include "xfs_da_btree.h"
 #include "xfs_inode.h"
@@ -175,7 +174,7 @@ xfs_dir_isempty(
 {
 	xfs_dir2_sf_hdr_t	*sfp;

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));
 	if (dp->i_d.di_size == 0)	/* might happen during shutdown. */
 		return 1;
 	if (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))
@@ -230,7 +229,7 @@ xfs_dir_init(
 	struct xfs_da_args *args;
 	int		error;

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));
 	error = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino);
 	if (error)
 		return error;
@@ -258,14 +257,14 @@ xfs_dir_createname(
 	struct xfs_name		*name,
 	xfs_ino_t		inum,		/* new entry inode number */
 	xfs_fsblock_t		*first,		/* bmap's firstblock */
-	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
+	xfs_bmap_free_t		*flist,		/* bmap's freeblock list */
 	xfs_extlen_t		total)		/* bmap's total block count */
 {
 	struct xfs_da_args	*args;
 	int			rval;
 	int			v;		/* type-checking value */

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));
 	if (inum) {
 		rval = xfs_dir_ino_validate(tp->t_mountp, inum);
 		if (rval)
@@ -285,7 +284,7 @@ xfs_dir_createname(
 	args->inumber = inum;
 	args->dp = dp;
 	args->firstblock = first;
-	args->dfops = dfops;
+	args->flist = flist;
 	args->total = total;
 	args->whichfork = XFS_DATA_FORK;
 	args->trans = tp;
@@ -363,7 +362,7 @@ xfs_dir_lookup(
 	int		v;		/* type-checking value */
 	int		lock_mode;

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));
 	XFS_STATS_INC(dp->i_mount, xs_dir_lookup);

 	/*
@@ -435,14 +434,14 @@ xfs_dir_removename(
 	struct xfs_name	*name,
 	xfs_ino_t	ino,
 	xfs_fsblock_t	*first,		/* bmap's firstblock */
-	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
+	xfs_bmap_free_t	*flist,		/* bmap's freeblock list */
 	xfs_extlen_t	total)		/* bmap's total block count */
 {
 	struct xfs_da_args *args;
 	int		rval;
 	int		v;		/* type-checking value */

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));
 	XFS_STATS_INC(dp->i_mount, xs_dir_remove);

 	args = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);
@@ -457,7 +456,7 @@ xfs_dir_removename(
 	args->inumber = ino;
 	args->dp = dp;
 	args->firstblock = first;
-	args->dfops = dfops;
+	args->flist = flist;
 	args->total = total;
 	args->whichfork = XFS_DATA_FORK;
 	args->trans = tp;
@@ -497,14 +496,14 @@ xfs_dir_replace(
 	struct xfs_name	*name,		/* name of entry to replace */
 	xfs_ino_t	inum,		/* new inode number */
 	xfs_fsblock_t	*first,		/* bmap's firstblock */
-	struct xfs_defer_ops	*dfops,		/* bmap's freeblock list */
+	xfs_bmap_free_t	*flist,		/* bmap's freeblock list */
 	xfs_extlen_t	total)		/* bmap's total block count */
 {
 	struct xfs_da_args *args;
 	int		rval;
 	int		v;		/* type-checking value */

-	ASSERT(S_ISDIR(VFS_I(dp)->i_mode));
+	ASSERT(S_ISDIR(dp->i_d.di_mode));

 	rval = xfs_dir_ino_validate(tp->t_mountp, inum);
 	if (rval)
@@ -522,7 +521,7 @@ xfs_dir_replace(
 	args->inumber = inum;
 	args->dp = dp;
 	args->firstblock = first;
-	args->dfops = dfops;
+	args->flist = flist;
 	args->total = total;
 	args->whichfork = XFS_DATA_FORK;
 	args->trans = tp;
@@ -679,7 +678,7 @@ xfs_dir2_shrink_inode(

 	/* Unmap the fsblock(s). */
 	error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount, 0, 0,
-			    args->firstblock, args->dfops, &done);
+			    args->firstblock, args->flist, &done);
 	if (error) {
 		/*
 		 * ENOSPC actually can happen if we're in a removename with no
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_dir2.h package_partclone/src/xfs/libxfs/xfs_dir2.h
--- package_partclone_orig/src/xfs/libxfs/xfs_dir2.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_dir2.h	2019-11-12 13:59:47.922149884 -0300
@@ -18,7 +18,7 @@
 #ifndef __XFS_DIR2_H__
 #define __XFS_DIR2_H__

-struct xfs_defer_ops;
+struct xfs_bmap_free;
 struct xfs_da_args;
 struct xfs_inode;
 struct xfs_mount;
@@ -129,18 +129,18 @@ extern int xfs_dir_init(struct xfs_trans
 extern int xfs_dir_createname(struct xfs_trans *tp, struct xfs_inode *dp,
 				struct xfs_name *name, xfs_ino_t inum,
 				xfs_fsblock_t *first,
-				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
+				struct xfs_bmap_free *flist, xfs_extlen_t tot);
 extern int xfs_dir_lookup(struct xfs_trans *tp, struct xfs_inode *dp,
 				struct xfs_name *name, xfs_ino_t *inum,
 				struct xfs_name *ci_name);
 extern int xfs_dir_removename(struct xfs_trans *tp, struct xfs_inode *dp,
 				struct xfs_name *name, xfs_ino_t ino,
 				xfs_fsblock_t *first,
-				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
+				struct xfs_bmap_free *flist, xfs_extlen_t tot);
 extern int xfs_dir_replace(struct xfs_trans *tp, struct xfs_inode *dp,
 				struct xfs_name *name, xfs_ino_t inum,
 				xfs_fsblock_t *first,
-				struct xfs_defer_ops *dfops, xfs_extlen_t tot);
+				struct xfs_bmap_free *flist, xfs_extlen_t tot);
 extern int xfs_dir_canenter(struct xfs_trans *tp, struct xfs_inode *dp,
 				struct xfs_name *name);

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_dir2_node.c package_partclone/src/xfs/libxfs/xfs_dir2_node.c
--- package_partclone_orig/src/xfs/libxfs/xfs_dir2_node.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_dir2_node.c	2019-11-12 13:59:47.922149884 -0300
@@ -2230,9 +2230,6 @@ xfs_dir2_node_trim_free(

 	dp = args->dp;
 	tp = args->trans;
-
-	*rvalp = 0;
-
 	/*
 	 * Read the freespace block.
 	 */
@@ -2253,6 +2250,7 @@ xfs_dir2_node_trim_free(
 	 */
 	if (freehdr.nused > 0) {
 		xfs_trans_brelse(tp, bp);
+		*rvalp = 0;
 		return 0;
 	}
 	/*
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_dir2_sf.c package_partclone/src/xfs/libxfs/xfs_dir2_sf.c
--- package_partclone_orig/src/xfs/libxfs/xfs_dir2_sf.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_dir2_sf.c	2019-11-12 13:59:47.923149884 -0300
@@ -124,12 +124,13 @@ xfs_dir2_block_sfsize(
 		/*
 		 * Calculate the new size, see if we should give up yet.
 		 */
-		size = xfs_dir2_sf_hdr_size(i8count) +	/* header */
-		       count * 3 * sizeof(__u8) +	/* namelen + offset */
-		       namelen +			/* name */
-		       (i8count ?			/* inumber */
-				count * XFS_INO64_SIZE :
-				count * XFS_INO32_SIZE);
+		size = xfs_dir2_sf_hdr_size(i8count) +		/* header */
+		       count +					/* namelen */
+		       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */
+		       namelen +				/* name */
+		       (i8count ?				/* inumber */
+				(uint)sizeof(xfs_dir2_ino8_t) * count :
+				(uint)sizeof(xfs_dir2_ino4_t) * count);
 		if (size > XFS_IFORK_DSIZE(dp))
 			return size;		/* size value is a failure */
 	}
@@ -254,12 +255,15 @@ xfs_dir2_block_to_sf(
 	 *
 	 * Convert the inode to local format and copy the data in.
 	 */
-	ASSERT(dp->i_df.if_bytes == 0);
-	xfs_init_local_fork(dp, XFS_DATA_FORK, dst, size);
+	dp->i_df.if_flags &= ~XFS_IFEXTENTS;
+	dp->i_df.if_flags |= XFS_IFINLINE;
 	dp->i_d.di_format = XFS_DINODE_FMT_LOCAL;
-	dp->i_d.di_size = size;
+	ASSERT(dp->i_df.if_bytes == 0);
+	xfs_idata_realloc(dp, size, XFS_DATA_FORK);

 	logflags |= XFS_ILOG_DDATA;
+	memcpy(dp->i_df.if_u1.if_data, dst, size);
+	dp->i_d.di_size = size;
 	xfs_dir2_sf_check(args);
 out:
 	xfs_trans_log_inode(args->trans, dp, logflags);
@@ -316,7 +320,10 @@ xfs_dir2_sf_addname(
 		/*
 		 * Yes, adjust the inode size.  old count + (parent + new)
 		 */
-		incr_isize += (sfp->count + 2) * XFS_INO64_DIFF;
+		incr_isize +=
+			(sfp->count + 2) *
+			((uint)sizeof(xfs_dir2_ino8_t) -
+			 (uint)sizeof(xfs_dir2_ino4_t));
 		objchange = 1;
 	}

@@ -891,7 +898,11 @@ xfs_dir2_sf_replace(
 		int	error;			/* error return value */
 		int	newsize;		/* new inode size */

-		newsize = dp->i_df.if_bytes + (sfp->count + 1) * XFS_INO64_DIFF;
+		newsize =
+			dp->i_df.if_bytes +
+			(sfp->count + 1) *
+			((uint)sizeof(xfs_dir2_ino8_t) -
+			 (uint)sizeof(xfs_dir2_ino4_t));
 		/*
 		 * Won't fit as shortform, convert to block then do replace.
 		 */
@@ -1012,7 +1023,10 @@ xfs_dir2_sf_toino4(
 	/*
 	 * Compute the new inode size.
 	 */
-	newsize = oldsize - (oldsfp->count + 1) * XFS_INO64_DIFF;
+	newsize =
+		oldsize -
+		(oldsfp->count + 1) *
+		((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));
 	xfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);
 	xfs_idata_realloc(dp, newsize, XFS_DATA_FORK);
 	/*
@@ -1035,7 +1049,7 @@ xfs_dir2_sf_toino4(
 	     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),
 		  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {
 		sfep->namelen = oldsfep->namelen;
-		memcpy(sfep->offset, oldsfep->offset, sizeof(sfep->offset));
+		sfep->offset = oldsfep->offset;
 		memcpy(sfep->name, oldsfep->name, sfep->namelen);
 		dp->d_ops->sf_put_ino(sfp, sfep,
 				      dp->d_ops->sf_get_ino(oldsfp, oldsfep));
@@ -1085,7 +1099,10 @@ xfs_dir2_sf_toino8(
 	/*
 	 * Compute the new inode size (nb: entry count + 1 for parent)
 	 */
-	newsize = oldsize + (oldsfp->count + 1) * XFS_INO64_DIFF;
+	newsize =
+		oldsize +
+		(oldsfp->count + 1) *
+		((uint)sizeof(xfs_dir2_ino8_t) - (uint)sizeof(xfs_dir2_ino4_t));
 	xfs_idata_realloc(dp, -oldsize, XFS_DATA_FORK);
 	xfs_idata_realloc(dp, newsize, XFS_DATA_FORK);
 	/*
@@ -1108,7 +1125,7 @@ xfs_dir2_sf_toino8(
 	     i++, sfep = dp->d_ops->sf_nextentry(sfp, sfep),
 		  oldsfep = dp->d_ops->sf_nextentry(oldsfp, oldsfep)) {
 		sfep->namelen = oldsfep->namelen;
-		memcpy(sfep->offset, oldsfep->offset, sizeof(sfep->offset));
+		sfep->offset = oldsfep->offset;
 		memcpy(sfep->name, oldsfep->name, sfep->namelen);
 		dp->d_ops->sf_put_ino(sfp, sfep,
 				      dp->d_ops->sf_get_ino(oldsfp, oldsfep));
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_dquot_buf.c package_partclone/src/xfs/libxfs/xfs_dquot_buf.c
--- package_partclone_orig/src/xfs/libxfs/xfs_dquot_buf.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_dquot_buf.c	2019-11-12 13:59:47.923149884 -0300
@@ -200,6 +200,7 @@ xfs_dquot_buf_verify_crc(
 		ndquots = mp->m_quotainfo->qi_dqperchunk;
 	else
 		ndquots = xfs_calc_dquots_per_chunk(bp->b_length);
+//					XFS_BB_TO_FSB(mp, bp->b_length));

 	for (i = 0; i < ndquots; i++, d++) {
 		if (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_format.h package_partclone/src/xfs/libxfs/xfs_format.h
--- package_partclone_orig/src/xfs/libxfs/xfs_format.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_format.h	2019-11-12 13:59:47.924149884 -0300
@@ -455,12 +455,8 @@ xfs_sb_has_compat_feature(
 }

 #define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)		/* free inode btree */
-#define XFS_SB_FEAT_RO_COMPAT_RMAPBT   (1 << 1)		/* reverse map btree */
-#define XFS_SB_FEAT_RO_COMPAT_REFLINK  (1 << 2)		/* reflinked files */
 #define XFS_SB_FEAT_RO_COMPAT_ALL \
-		(XFS_SB_FEAT_RO_COMPAT_FINOBT | \
-		 XFS_SB_FEAT_RO_COMPAT_RMAPBT | \
-		 XFS_SB_FEAT_RO_COMPAT_REFLINK)
+		(XFS_SB_FEAT_RO_COMPAT_FINOBT)
 #define XFS_SB_FEAT_RO_COMPAT_UNKNOWN	~XFS_SB_FEAT_RO_COMPAT_ALL
 static inline bool
 xfs_sb_has_ro_compat_feature(
@@ -543,18 +539,6 @@ static inline int xfs_sb_version_hasmeta
 		(sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID);
 }

-static inline bool xfs_sb_version_hasrmapbt(struct xfs_sb *sbp)
-{
-	return (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&
-		(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_RMAPBT);
-}
-
-static inline bool xfs_sb_version_hasreflink(struct xfs_sb *sbp)
-{
-	return XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&
-		(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_REFLINK);
-}
-
 /*
  * end of superblock version macros
  */
@@ -615,10 +599,10 @@ xfs_is_quota_inode(struct xfs_sb *sbp, x
 #define	XFS_AGI_GOOD_VERSION(v)	((v) == XFS_AGI_VERSION)

 /*
- * Btree number 0 is bno, 1 is cnt, 2 is rmap. This value gives the size of the
+ * Btree number 0 is bno, 1 is cnt.  This value gives the size of the
  * arrays below.
  */
-#define	XFS_BTNUM_AGF	((int)XFS_BTNUM_RMAPi + 1)
+#define	XFS_BTNUM_AGF	((int)XFS_BTNUM_CNTi + 1)

 /*
  * The second word of agf_levels in the first a.g. overlaps the EFS
@@ -635,10 +619,12 @@ typedef struct xfs_agf {
 	__be32		agf_seqno;	/* sequence # starting from 0 */
 	__be32		agf_length;	/* size in blocks of a.g. */
 	/*
-	 * Freespace and rmap information
+	 * Freespace information
 	 */
 	__be32		agf_roots[XFS_BTNUM_AGF];	/* root blocks */
+	__be32		agf_spare0;	/* spare field */
 	__be32		agf_levels[XFS_BTNUM_AGF];	/* btree levels */
+	__be32		agf_spare1;	/* spare field */

 	__be32		agf_flfirst;	/* first freelist block's index */
 	__be32		agf_fllast;	/* last freelist block's index */
@@ -649,18 +635,12 @@ typedef struct xfs_agf {
 	__be32		agf_btreeblks;	/* # of blocks held in AGF btrees */
 	uuid_t		agf_uuid;	/* uuid of filesystem */

-	__be32		agf_rmap_blocks;	/* rmapbt blocks used */
-	__be32		agf_refcount_blocks;	/* refcountbt blocks used */
-
-	__be32		agf_refcount_root;	/* refcount tree root block */
-	__be32		agf_refcount_level;	/* refcount btree levels */
-
 	/*
 	 * reserve some contiguous space for future logged fields before we add
 	 * the unlogged fields. This makes the range logging via flags and
 	 * structure offsets much simpler.
 	 */
-	__be64		agf_spare64[14];
+	__be64		agf_spare64[16];

 	/* unlogged fields, written during buffer writeback. */
 	__be64		agf_lsn;	/* last write sequence */
@@ -685,12 +665,7 @@ typedef struct xfs_agf {
 #define	XFS_AGF_LONGEST		0x00000400
 #define	XFS_AGF_BTREEBLKS	0x00000800
 #define	XFS_AGF_UUID		0x00001000
-#define	XFS_AGF_RMAP_BLOCKS	0x00002000
-#define	XFS_AGF_REFCOUNT_BLOCKS	0x00004000
-#define	XFS_AGF_REFCOUNT_ROOT	0x00008000
-#define	XFS_AGF_REFCOUNT_LEVEL	0x00010000
-#define	XFS_AGF_SPARE64		0x00020000
-#define	XFS_AGF_NUM_BITS	18
+#define	XFS_AGF_NUM_BITS	13
 #define	XFS_AGF_ALL_BITS	((1 << XFS_AGF_NUM_BITS) - 1)

 #define XFS_AGF_FLAGS \
@@ -706,12 +681,7 @@ typedef struct xfs_agf {
 	{ XFS_AGF_FREEBLKS,	"FREEBLKS" }, \
 	{ XFS_AGF_LONGEST,	"LONGEST" }, \
 	{ XFS_AGF_BTREEBLKS,	"BTREEBLKS" }, \
-	{ XFS_AGF_UUID,		"UUID" }, \
-	{ XFS_AGF_RMAP_BLOCKS,	"RMAP_BLOCKS" }, \
-	{ XFS_AGF_REFCOUNT_BLOCKS,	"REFCOUNT_BLOCKS" }, \
-	{ XFS_AGF_REFCOUNT_ROOT,	"REFCOUNT_ROOT" }, \
-	{ XFS_AGF_REFCOUNT_LEVEL,	"REFCOUNT_LEVEL" }, \
-	{ XFS_AGF_SPARE64,	"SPARE64" }
+	{ XFS_AGF_UUID,		"UUID" }

 /* disk block (xfs_daddr_t) in the AG */
 #define XFS_AGF_DADDR(mp)	((xfs_daddr_t)(1 << (mp)->m_sectbb_log))
@@ -817,7 +787,7 @@ typedef struct xfs_agfl {
 	__be64		agfl_lsn;
 	__be32		agfl_crc;
 	__be32		agfl_bno[];	/* actually XFS_AGFL_SIZE(mp) */
-} __attribute__((packed)) xfs_agfl_t;
+} xfs_agfl_t;

 #define XFS_AGFL_CRC_OFF	offsetof(struct xfs_agfl, agfl_crc)

@@ -902,8 +872,7 @@ typedef struct xfs_dinode {
 	__be64		di_changecount;	/* number of attribute changes */
 	__be64		di_lsn;		/* flush sequence */
 	__be64		di_flags2;	/* more random flags */
-	__be32		di_cowextsize;	/* basic cow extent size for file */
-	__u8		di_pad2[12];	/* more padding for future expansion */
+	__u8		di_pad2[16];	/* more padding for future expansion */

 	/* fields only written to during inode creation */
 	xfs_timestamp_t	di_crtime;	/* time created */
@@ -1059,14 +1028,9 @@ static inline void xfs_dinode_put_rdev(s
  * 16 bits of the XFS_XFLAG_s range.
  */
 #define XFS_DIFLAG2_DAX_BIT	0	/* use DAX for this inode */
-#define XFS_DIFLAG2_REFLINK_BIT	1	/* file's blocks may be shared */
-#define XFS_DIFLAG2_COWEXTSIZE_BIT   2  /* copy on write extent size hint */
 #define XFS_DIFLAG2_DAX		(1 << XFS_DIFLAG2_DAX_BIT)
-#define XFS_DIFLAG2_REFLINK     (1 << XFS_DIFLAG2_REFLINK_BIT)
-#define XFS_DIFLAG2_COWEXTSIZE  (1 << XFS_DIFLAG2_COWEXTSIZE_BIT)

-#define XFS_DIFLAG2_ANY \
-	(XFS_DIFLAG2_DAX | XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)
+#define XFS_DIFLAG2_ANY		(XFS_DIFLAG2_DAX)

 /*
  * Inode number format:
@@ -1344,174 +1308,15 @@ typedef __be32 xfs_inobt_ptr_t;
 #define	XFS_FIBT_BLOCK(mp)		((xfs_agblock_t)(XFS_IBT_BLOCK(mp) + 1))

 /*
- * Reverse mapping btree format definitions
- *
- * There is a btree for the reverse map per allocation group
+ * The first data block of an AG depends on whether the filesystem was formatted
+ * with the finobt feature. If so, account for the finobt reserved root btree
+ * block.
  */
-#define	XFS_RMAP_CRC_MAGIC	0x524d4233	/* 'RMB3' */
-
-/*
- * Ownership info for an extent.  This is used to create reverse-mapping
- * entries.
- */
-#define XFS_OWNER_INFO_ATTR_FORK	(1 << 0)
-#define XFS_OWNER_INFO_BMBT_BLOCK	(1 << 1)
-struct xfs_owner_info {
-	uint64_t		oi_owner;
-	xfs_fileoff_t		oi_offset;
-	unsigned int		oi_flags;
-};
-
-/*
- * Special owner types.
- *
- * Seeing as we only support up to 8EB, we have the upper bit of the owner field
- * to tell us we have a special owner value. We use these for static metadata
- * allocated at mkfs/growfs time, as well as for freespace management metadata.
- */
-#define XFS_RMAP_OWN_NULL	(-1ULL)	/* No owner, for growfs */
-#define XFS_RMAP_OWN_UNKNOWN	(-2ULL)	/* Unknown owner, for EFI recovery */
-#define XFS_RMAP_OWN_FS		(-3ULL)	/* static fs metadata */
-#define XFS_RMAP_OWN_LOG	(-4ULL)	/* static fs metadata */
-#define XFS_RMAP_OWN_AG		(-5ULL)	/* AG freespace btree blocks */
-#define XFS_RMAP_OWN_INOBT	(-6ULL)	/* Inode btree blocks */
-#define XFS_RMAP_OWN_INODES	(-7ULL)	/* Inode chunk */
-#define XFS_RMAP_OWN_REFC	(-8ULL) /* refcount tree */
-#define XFS_RMAP_OWN_COW	(-9ULL) /* cow allocations */
-#define XFS_RMAP_OWN_MIN	(-10ULL) /* guard */
-
-#define XFS_RMAP_NON_INODE_OWNER(owner)	(!!((owner) & (1ULL << 63)))
-
-/*
- * Data record structure
- */
-struct xfs_rmap_rec {
-	__be32		rm_startblock;	/* extent start block */
-	__be32		rm_blockcount;	/* extent length */
-	__be64		rm_owner;	/* extent owner */
-	__be64		rm_offset;	/* offset within the owner */
-};
-
-/*
- * rmap btree record
- *  rm_offset:63 is the attribute fork flag
- *  rm_offset:62 is the bmbt block flag
- *  rm_offset:61 is the unwritten extent flag (same as l0:63 in bmbt)
- *  rm_offset:54-60 aren't used and should be zero
- *  rm_offset:0-53 is the block offset within the inode
- */
-#define XFS_RMAP_OFF_ATTR_FORK	((__uint64_t)1ULL << 63)
-#define XFS_RMAP_OFF_BMBT_BLOCK	((__uint64_t)1ULL << 62)
-#define XFS_RMAP_OFF_UNWRITTEN	((__uint64_t)1ULL << 61)
-
-#define XFS_RMAP_LEN_MAX	((__uint32_t)~0U)
-#define XFS_RMAP_OFF_FLAGS	(XFS_RMAP_OFF_ATTR_FORK | \
-				 XFS_RMAP_OFF_BMBT_BLOCK | \
-				 XFS_RMAP_OFF_UNWRITTEN)
-#define XFS_RMAP_OFF_MASK	((__uint64_t)0x3FFFFFFFFFFFFFULL)
-
-#define XFS_RMAP_OFF(off)		((off) & XFS_RMAP_OFF_MASK)
-
-#define XFS_RMAP_IS_BMBT_BLOCK(off)	(!!((off) & XFS_RMAP_OFF_BMBT_BLOCK))
-#define XFS_RMAP_IS_ATTR_FORK(off)	(!!((off) & XFS_RMAP_OFF_ATTR_FORK))
-#define XFS_RMAP_IS_UNWRITTEN(len)	(!!((off) & XFS_RMAP_OFF_UNWRITTEN))
-
-#define RMAPBT_STARTBLOCK_BITLEN	32
-#define RMAPBT_BLOCKCOUNT_BITLEN	32
-#define RMAPBT_OWNER_BITLEN		64
-#define RMAPBT_ATTRFLAG_BITLEN		1
-#define RMAPBT_BMBTFLAG_BITLEN		1
-#define RMAPBT_EXNTFLAG_BITLEN		1
-#define RMAPBT_UNUSED_OFFSET_BITLEN	7
-#define RMAPBT_OFFSET_BITLEN		54
-
-#define XFS_RMAP_ATTR_FORK		(1 << 0)
-#define XFS_RMAP_BMBT_BLOCK		(1 << 1)
-#define XFS_RMAP_UNWRITTEN		(1 << 2)
-#define XFS_RMAP_KEY_FLAGS		(XFS_RMAP_ATTR_FORK | \
-					 XFS_RMAP_BMBT_BLOCK)
-#define XFS_RMAP_REC_FLAGS		(XFS_RMAP_UNWRITTEN)
-struct xfs_rmap_irec {
-	xfs_agblock_t	rm_startblock;	/* extent start block */
-	xfs_extlen_t	rm_blockcount;	/* extent length */
-	__uint64_t	rm_owner;	/* extent owner */
-	__uint64_t	rm_offset;	/* offset within the owner */
-	unsigned int	rm_flags;	/* state flags */
-};
-
-/*
- * Key structure
- *
- * We don't use the length for lookups
- */
-struct xfs_rmap_key {
-	__be32		rm_startblock;	/* extent start block */
-	__be64		rm_owner;	/* extent owner */
-	__be64		rm_offset;	/* offset within the owner */
-} __attribute__((packed));
-
-/* btree pointer type */
-typedef __be32 xfs_rmap_ptr_t;
-
-#define	XFS_RMAP_BLOCK(mp) \
+#define XFS_PREALLOC_BLOCKS(mp) \
 	(xfs_sb_version_hasfinobt(&((mp)->m_sb)) ? \
 	 XFS_FIBT_BLOCK(mp) + 1 : \
 	 XFS_IBT_BLOCK(mp) + 1)

-/*
- * Reference Count Btree format definitions
- *
- */
-#define	XFS_REFC_CRC_MAGIC	0x52334643	/* 'R3FC' */
-
-unsigned int xfs_refc_block(struct xfs_mount *mp);
-
-/*
- * Data record/key structure
- *
- * Each record associates a range of physical blocks (starting at
- * rc_startblock and ending rc_blockcount blocks later) with a reference
- * count (rc_refcount).  Extents that are being used to stage a copy on
- * write (CoW) operation are recorded in the refcount btree with a
- * refcount of 1.  All other records must have a refcount > 1 and must
- * track an extent mapped only by file data forks.
- *
- * Extents with a single owner (attributes, metadata, non-shared file
- * data) are not tracked here.  Free space is also not tracked here.
- * This is consistent with pre-reflink XFS.
- */
-
-/*
- * Extents that are being used to stage a copy on write are stored
- * in the refcount btree with a refcount of 1 and the upper bit set
- * on the startblock.  This speeds up mount time deletion of stale
- * staging extents because they're all at the right side of the tree.
- */
-#define XFS_REFC_COW_START		((xfs_agblock_t)(1U << 31))
-#define REFCNTBT_COWFLAG_BITLEN		1
-#define REFCNTBT_AGBLOCK_BITLEN		31
-
-struct xfs_refcount_rec {
-	__be32		rc_startblock;	/* starting block number */
-	__be32		rc_blockcount;	/* count of blocks */
-	__be32		rc_refcount;	/* number of inodes linked here */
-};
-
-struct xfs_refcount_key {
-	__be32		rc_startblock;	/* starting block number */
-};
-
-struct xfs_refcount_irec {
-	xfs_agblock_t	rc_startblock;	/* starting block number */
-	xfs_extlen_t	rc_blockcount;	/* count of free blocks */
-	xfs_nlink_t	rc_refcount;	/* number of inodes linked here */
-};
-
-#define MAXREFCOUNT	((xfs_nlink_t)~0U)
-#define MAXREFCEXTLEN	((xfs_extlen_t)~0U)
-
-/* btree pointer type */
-typedef __be32 xfs_refcount_ptr_t;


 /*
@@ -1630,57 +1435,41 @@ typedef __be64 xfs_bmbt_ptr_t, xfs_bmdr_
  * with the crc feature bit, and all accesses to them must be conditional on
  * that flag.
  */
-/* short form block header */
-struct xfs_btree_block_shdr {
-	__be32		bb_leftsib;
-	__be32		bb_rightsib;
-
-	__be64		bb_blkno;
-	__be64		bb_lsn;
-	uuid_t		bb_uuid;
-	__be32		bb_owner;
-	__le32		bb_crc;
-};
-
-/* long form block header */
-struct xfs_btree_block_lhdr {
-	__be64		bb_leftsib;
-	__be64		bb_rightsib;
-
-	__be64		bb_blkno;
-	__be64		bb_lsn;
-	uuid_t		bb_uuid;
-	__be64		bb_owner;
-	__le32		bb_crc;
-	__be32		bb_pad; /* padding for alignment */
-};
-
 struct xfs_btree_block {
 	__be32		bb_magic;	/* magic number for block type */
 	__be16		bb_level;	/* 0 is a leaf */
 	__be16		bb_numrecs;	/* current # of data records */
 	union {
-		struct xfs_btree_block_shdr s;
-		struct xfs_btree_block_lhdr l;
+		struct {
+			__be32		bb_leftsib;
+			__be32		bb_rightsib;
+
+			__be64		bb_blkno;
+			__be64		bb_lsn;
+			uuid_t		bb_uuid;
+			__be32		bb_owner;
+			__le32		bb_crc;
+		} s;			/* short form pointers */
+		struct	{
+			__be64		bb_leftsib;
+			__be64		bb_rightsib;
+
+			__be64		bb_blkno;
+			__be64		bb_lsn;
+			uuid_t		bb_uuid;
+			__be64		bb_owner;
+			__le32		bb_crc;
+			__be32		bb_pad; /* padding for alignment */
+		} l;			/* long form pointers */
 	} bb_u;				/* rest */
 };

-/* size of a short form block */
-#define XFS_BTREE_SBLOCK_LEN \
-	(offsetof(struct xfs_btree_block, bb_u) + \
-	 offsetof(struct xfs_btree_block_shdr, bb_blkno))
-/* size of a long form block */
-#define XFS_BTREE_LBLOCK_LEN \
-	(offsetof(struct xfs_btree_block, bb_u) + \
-	 offsetof(struct xfs_btree_block_lhdr, bb_blkno))
+#define XFS_BTREE_SBLOCK_LEN	16	/* size of a short form block */
+#define XFS_BTREE_LBLOCK_LEN	24	/* size of a long form block */

 /* sizes of CRC enabled btree blocks */
-#define XFS_BTREE_SBLOCK_CRC_LEN \
-	(offsetof(struct xfs_btree_block, bb_u) + \
-	 sizeof(struct xfs_btree_block_shdr))
-#define XFS_BTREE_LBLOCK_CRC_LEN \
-	(offsetof(struct xfs_btree_block, bb_u) + \
-	 sizeof(struct xfs_btree_block_lhdr))
+#define XFS_BTREE_SBLOCK_CRC_LEN	(XFS_BTREE_SBLOCK_LEN + 40)
+#define XFS_BTREE_LBLOCK_CRC_LEN	(XFS_BTREE_LBLOCK_LEN + 48)

 #define XFS_BTREE_SBLOCK_CRC_OFF \
 	offsetof(struct xfs_btree_block, bb_u.s.bb_crc)
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_fs.h package_partclone/src/xfs/libxfs/xfs_fs.h
--- package_partclone_orig/src/xfs/libxfs/xfs_fs.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_fs.h	2019-11-12 13:59:47.925149884 -0300
@@ -105,16 +105,14 @@ struct getbmapx {
 #define BMV_IF_PREALLOC		0x4	/* rtn status BMV_OF_PREALLOC if req */
 #define BMV_IF_DELALLOC		0x8	/* rtn status BMV_OF_DELALLOC if req */
 #define BMV_IF_NO_HOLES		0x10	/* Do not return holes */
-#define BMV_IF_COWFORK		0x20	/* return CoW fork rather than data */
 #define BMV_IF_VALID	\
 	(BMV_IF_ATTRFORK|BMV_IF_NO_DMAPI_READ|BMV_IF_PREALLOC|	\
-	 BMV_IF_DELALLOC|BMV_IF_NO_HOLES|BMV_IF_COWFORK)
+	 BMV_IF_DELALLOC|BMV_IF_NO_HOLES)

 /*	bmv_oflags values - returned for each non-header segment */
 #define BMV_OF_PREALLOC		0x1	/* segment = unwritten pre-allocation */
 #define BMV_OF_DELALLOC		0x2	/* segment = delayed allocation */
 #define BMV_OF_LAST		0x4	/* segment is the last in the file */
-#define BMV_OF_SHARED		0x8	/* segment shared with another file */

 /*
  * Structure for XFS_IOC_FSSETDM.
@@ -232,8 +230,6 @@ typedef struct xfs_fsop_resblks {
 #define XFS_FSOP_GEOM_FLAGS_FTYPE	0x10000	/* inode directory types */
 #define XFS_FSOP_GEOM_FLAGS_FINOBT	0x20000	/* free inode btree */
 #define XFS_FSOP_GEOM_FLAGS_SPINODES	0x40000	/* sparse inode chunks	*/
-#define XFS_FSOP_GEOM_FLAGS_RMAPBT	0x80000	/* reverse mapping btree */
-#define XFS_FSOP_GEOM_FLAGS_REFLINK	0x100000 /* files can share blocks */

 /*
  * Minimum and maximum sizes need for growth checks.
@@ -302,8 +298,7 @@ typedef struct xfs_bstat {
 #define	bs_projid	bs_projid_lo	/* (previously just bs_projid)	*/
 	__u16		bs_forkoff;	/* inode fork offset in bytes	*/
 	__u16		bs_projid_hi;	/* higher part of project id	*/
-	unsigned char	bs_pad[6];	/* pad space, unused		*/
-	__u32		bs_cowextsize;	/* cow extent size		*/
+	unsigned char	bs_pad[10];	/* pad space, unused		*/
 	__u32		bs_dmevmask;	/* DMIG event mask		*/
 	__u16		bs_dmstate;	/* DMIG state info		*/
 	__u16		bs_aextents;	/* attribute number of extents	*/
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_ialloc_btree.c package_partclone/src/xfs/libxfs/xfs_ialloc_btree.c
--- package_partclone_orig/src/xfs/libxfs/xfs_ialloc_btree.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_ialloc_btree.c	2019-11-12 13:59:47.925149884 -0300
@@ -31,7 +31,6 @@
 #include "xfs_trace.h"
 #include "xfs_cksum.h"
 #include "xfs_trans.h"
-#include "xfs_rmap.h"


 STATIC int
@@ -96,7 +95,6 @@ xfs_inobt_alloc_block(
 	memset(&args, 0, sizeof(args));
 	args.tp = cur->bc_tp;
 	args.mp = cur->bc_mp;
-	xfs_rmap_ag_owner(&args.oinfo, XFS_RMAP_OWN_INOBT);
 	args.fsbno = XFS_AGB_TO_FSB(args.mp, cur->bc_private.a.agno, sbno);
 	args.minlen = 1;
 	args.maxlen = 1;
@@ -126,12 +124,16 @@ xfs_inobt_free_block(
 	struct xfs_btree_cur	*cur,
 	struct xfs_buf		*bp)
 {
-	struct xfs_owner_info	oinfo;
+	xfs_fsblock_t		fsbno;
+	int			error;

-	xfs_rmap_ag_owner(&oinfo, XFS_RMAP_OWN_INOBT);
-	return xfs_free_extent(cur->bc_tp,
-			XFS_DADDR_TO_FSB(cur->bc_mp, XFS_BUF_ADDR(bp)), 1,
-			&oinfo, XFS_AG_RESV_NONE);
+	fsbno = XFS_DADDR_TO_FSB(cur->bc_mp, XFS_BUF_ADDR(bp));
+	error = xfs_free_extent(cur->bc_tp, fsbno, 1);
+	if (error)
+		return error;
+
+	xfs_trans_binval(cur->bc_tp, bp);
+	return error;
 }

 STATIC int
@@ -151,6 +153,14 @@ xfs_inobt_init_key_from_rec(
 }

 STATIC void
+xfs_inobt_init_rec_from_key(
+	union xfs_btree_key	*key,
+	union xfs_btree_rec	*rec)
+{
+	rec->inobt.ir_startino = key->inobt.ir_startino;
+}
+
+STATIC void
 xfs_inobt_init_rec_from_cur(
 	struct xfs_btree_cur	*cur,
 	union xfs_btree_rec	*rec)
@@ -313,6 +323,7 @@ static const struct xfs_btree_ops xfs_in
 	.get_minrecs		= xfs_inobt_get_minrecs,
 	.get_maxrecs		= xfs_inobt_get_maxrecs,
 	.init_key_from_rec	= xfs_inobt_init_key_from_rec,
+	.init_rec_from_key	= xfs_inobt_init_rec_from_key,
 	.init_rec_from_cur	= xfs_inobt_init_rec_from_cur,
 	.init_ptr_from_cur	= xfs_inobt_init_ptr_from_cur,
 	.key_diff		= xfs_inobt_key_diff,
@@ -334,6 +345,7 @@ static const struct xfs_btree_ops xfs_fi
 	.get_minrecs		= xfs_inobt_get_minrecs,
 	.get_maxrecs		= xfs_inobt_get_maxrecs,
 	.init_key_from_rec	= xfs_inobt_init_key_from_rec,
+	.init_rec_from_key	= xfs_inobt_init_rec_from_key,
 	.init_rec_from_cur	= xfs_inobt_init_rec_from_cur,
 	.init_ptr_from_cur	= xfs_finobt_init_ptr_from_cur,
 	.key_diff		= xfs_inobt_key_diff,
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_ialloc.c package_partclone/src/xfs/libxfs/xfs_ialloc.c
--- package_partclone_orig/src/xfs/libxfs/xfs_ialloc.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_ialloc.c	2019-11-12 13:59:47.926149884 -0300
@@ -24,7 +24,6 @@
 #include "xfs_bit.h"
 #include "xfs_sb.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_btree.h"
 #include "xfs_ialloc.h"
@@ -34,7 +33,6 @@
 #include "xfs_cksum.h"
 #include "xfs_trans.h"
 #include "xfs_trace.h"
-#include "xfs_rmap.h"


 /*
@@ -610,7 +608,6 @@ xfs_ialloc_ag_alloc(
 	args.tp = tp;
 	args.mp = tp->t_mountp;
 	args.fsbno = NULLFSBLOCK;
-	xfs_rmap_ag_owner(&args.oinfo, XFS_RMAP_OWN_INODES);

 #ifdef DEBUG
 	/* randomly do sparse inode allocations */
@@ -1814,21 +1811,20 @@ xfs_difree_inode_chunk(
 	struct xfs_mount		*mp,
 	xfs_agnumber_t			agno,
 	struct xfs_inobt_rec_incore	*rec,
-	struct xfs_defer_ops		*dfops)
+	struct xfs_bmap_free		*flist)
 {
 	xfs_agblock_t	sagbno = XFS_AGINO_TO_AGBNO(mp, rec->ir_startino);
 	int		startidx, endidx;
 	int		nextbit;
 	xfs_agblock_t	agbno;
 	int		contigblk;
-	struct xfs_owner_info	oinfo;
 	DECLARE_BITMAP(holemask, XFS_INOBT_HOLEMASK_BITS);
-	xfs_rmap_ag_owner(&oinfo, XFS_RMAP_OWN_INODES);

 	if (!xfs_inobt_issparse(rec->ir_holemask)) {
 		/* not sparse, calculate extent info directly */
-		xfs_bmap_add_free(mp, dfops, XFS_AGB_TO_FSB(mp, agno, sagbno),
-				  mp->m_ialloc_blks, &oinfo);
+		xfs_bmap_add_free(mp, flist, XFS_AGB_TO_FSB(mp, agno,
+				  XFS_AGINO_TO_AGBNO(mp, rec->ir_startino)),
+				  mp->m_ialloc_blks);
 		return;
 	}

@@ -1871,8 +1867,8 @@ xfs_difree_inode_chunk(

 		ASSERT(agbno % mp->m_sb.sb_spino_align == 0);
 		ASSERT(contigblk % mp->m_sb.sb_spino_align == 0);
-		xfs_bmap_add_free(mp, dfops, XFS_AGB_TO_FSB(mp, agno, agbno),
-				  contigblk, &oinfo);
+		xfs_bmap_add_free(mp, flist, XFS_AGB_TO_FSB(mp, agno, agbno),
+				  contigblk);

 		/* reset range to current bit and carry on... */
 		startidx = endidx = nextbit;
@@ -1888,7 +1884,7 @@ xfs_difree_inobt(
 	struct xfs_trans		*tp,
 	struct xfs_buf			*agbp,
 	xfs_agino_t			agino,
-	struct xfs_defer_ops		*dfops,
+	struct xfs_bmap_free		*flist,
 	struct xfs_icluster		*xic,
 	struct xfs_inobt_rec_incore	*orec)
 {
@@ -1975,7 +1971,7 @@ xfs_difree_inobt(
 			goto error0;
 		}

-		xfs_difree_inode_chunk(mp, agno, &rec, dfops);
+		xfs_difree_inode_chunk(mp, agno, &rec, flist);
 	} else {
 		xic->deleted = 0;

@@ -2120,7 +2116,7 @@ int
 xfs_difree(
 	struct xfs_trans	*tp,		/* transaction pointer */
 	xfs_ino_t		inode,		/* inode to be freed */
-	struct xfs_defer_ops	*dfops,		/* extents to free */
+	struct xfs_bmap_free	*flist,		/* extents to free */
 	struct xfs_icluster	*xic)	/* cluster info if deleted */
 {
 	/* REFERENCED */
@@ -2172,7 +2168,7 @@ xfs_difree(
 	/*
 	 * Fix up the inode allocation btree.
 	 */
-	error = xfs_difree_inobt(mp, tp, agbp, agino, dfops, xic, &rec);
+	error = xfs_difree_inobt(mp, tp, agbp, agino, flist, xic, &rec);
 	if (error)
 		goto error0;

@@ -2393,11 +2389,20 @@ void
 xfs_ialloc_compute_maxlevels(
 	xfs_mount_t	*mp)		/* file system mount structure */
 {
-	uint		inodes;
-
-	inodes = (1LL << XFS_INO_AGINO_BITS(mp)) >> XFS_INODES_PER_CHUNK_LOG;
-	mp->m_in_maxlevels = xfs_btree_compute_maxlevels(mp, mp->m_inobt_mnr,
-							 inodes);
+	int		level;
+	uint		maxblocks;
+	uint		maxleafents;
+	int		minleafrecs;
+	int		minnoderecs;
+
+	maxleafents = (1LL << XFS_INO_AGINO_BITS(mp)) >>
+		XFS_INODES_PER_CHUNK_LOG;
+	minleafrecs = mp->m_alloc_mnr[0];
+	minnoderecs = mp->m_alloc_mnr[1];
+	maxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;
+	for (level = 1; maxblocks > 1; level++)
+		maxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;
+	mp->m_in_maxlevels = level;
 }

 /*
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_ialloc.h package_partclone/src/xfs/libxfs/xfs_ialloc.h
--- package_partclone_orig/src/xfs/libxfs/xfs_ialloc.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_ialloc.h	2019-11-12 13:59:47.926149884 -0300
@@ -95,7 +95,7 @@ int					/* error */
 xfs_difree(
 	struct xfs_trans *tp,		/* transaction pointer */
 	xfs_ino_t	inode,		/* inode to be freed */
-	struct xfs_defer_ops *dfops,	/* extents to free */
+	struct xfs_bmap_free *flist,	/* extents to free */
 	struct xfs_icluster *ifree);	/* cluster info if deleted */

 /*
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_inode_buf.c package_partclone/src/xfs/libxfs/xfs_inode_buf.c
--- package_partclone_orig/src/xfs/libxfs/xfs_inode_buf.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_inode_buf.c	2019-11-12 13:59:47.927149884 -0300
@@ -22,7 +22,6 @@
 #include "xfs_log_format.h"
 #include "xfs_trans_resv.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_cksum.h"
 #include "xfs_trans.h"
@@ -205,50 +204,28 @@ xfs_imap_to_bp(
 }

 void
-xfs_inode_from_disk(
-	struct xfs_inode	*ip,
-	struct xfs_dinode	*from)
-{
-	struct xfs_icdinode	*to = &ip->i_d;
-	struct inode		*inode = VFS_I(ip);
-
-
-	/*
-	 * Convert v1 inodes immediately to v2 inode format as this is the
-	 * minimum inode version format we support in the rest of the code.
-	 */
-	to->di_version = from->di_version;
-	if (to->di_version == 1) {
-		set_nlink(inode, be16_to_cpu(from->di_onlink));
-		to->di_projid_lo = 0;
-		to->di_projid_hi = 0;
-		to->di_version = 2;
-	} else {
-		set_nlink(inode, be32_to_cpu(from->di_nlink));
-		to->di_projid_lo = be16_to_cpu(from->di_projid_lo);
-		to->di_projid_hi = be16_to_cpu(from->di_projid_hi);
-	}
-
+xfs_dinode_from_disk(
+	xfs_icdinode_t		*to,
+	xfs_dinode_t		*from)
+{
+	to->di_magic = be16_to_cpu(from->di_magic);
+	to->di_mode = be16_to_cpu(from->di_mode);
+	to->di_version = from ->di_version;
 	to->di_format = from->di_format;
+	to->di_onlink = be16_to_cpu(from->di_onlink);
 	to->di_uid = be32_to_cpu(from->di_uid);
 	to->di_gid = be32_to_cpu(from->di_gid);
+	to->di_nlink = be32_to_cpu(from->di_nlink);
+	to->di_projid_lo = be16_to_cpu(from->di_projid_lo);
+	to->di_projid_hi = be16_to_cpu(from->di_projid_hi);
+	memcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));
 	to->di_flushiter = be16_to_cpu(from->di_flushiter);
-
-	/*
-	 * Time is signed, so need to convert to signed 32 bit before
-	 * storing in inode timestamp which may be 64 bit. Otherwise
-	 * a time before epoch is converted to a time long after epoch
-	 * on 64 bit systems.
-	 */
-	inode->i_atime.tv_sec = (int)be32_to_cpu(from->di_atime.t_sec);
-	inode->i_atime.tv_nsec = (int)be32_to_cpu(from->di_atime.t_nsec);
-	inode->i_mtime.tv_sec = (int)be32_to_cpu(from->di_mtime.t_sec);
-	inode->i_mtime.tv_nsec = (int)be32_to_cpu(from->di_mtime.t_nsec);
-	inode->i_ctime.tv_sec = (int)be32_to_cpu(from->di_ctime.t_sec);
-	inode->i_ctime.tv_nsec = (int)be32_to_cpu(from->di_ctime.t_nsec);
-	inode->i_generation = be32_to_cpu(from->di_gen);
-	inode->i_mode = be16_to_cpu(from->di_mode);
-
+	to->di_atime.t_sec = be32_to_cpu(from->di_atime.t_sec);
+	to->di_atime.t_nsec = be32_to_cpu(from->di_atime.t_nsec);
+	to->di_mtime.t_sec = be32_to_cpu(from->di_mtime.t_sec);
+	to->di_mtime.t_nsec = be32_to_cpu(from->di_mtime.t_nsec);
+	to->di_ctime.t_sec = be32_to_cpu(from->di_ctime.t_sec);
+	to->di_ctime.t_nsec = be32_to_cpu(from->di_ctime.t_nsec);
 	to->di_size = be64_to_cpu(from->di_size);
 	to->di_nblocks = be64_to_cpu(from->di_nblocks);
 	to->di_extsize = be32_to_cpu(from->di_extsize);
@@ -259,97 +236,42 @@ xfs_inode_from_disk(
 	to->di_dmevmask	= be32_to_cpu(from->di_dmevmask);
 	to->di_dmstate	= be16_to_cpu(from->di_dmstate);
 	to->di_flags	= be16_to_cpu(from->di_flags);
+	to->di_gen	= be32_to_cpu(from->di_gen);

 	if (to->di_version == 3) {
-		inode->i_version = be64_to_cpu(from->di_changecount);
+		to->di_changecount = be64_to_cpu(from->di_changecount);
 		to->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);
 		to->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);
 		to->di_flags2 = be64_to_cpu(from->di_flags2);
-		to->di_cowextsize = be32_to_cpu(from->di_cowextsize);
-	}
-}
-
-void
-xfs_inode_to_disk(
-	struct xfs_inode	*ip,
-	struct xfs_dinode	*to,
-	xfs_lsn_t		lsn)
-{
-	struct xfs_icdinode	*from = &ip->i_d;
-	struct inode		*inode = VFS_I(ip);
-
-	to->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);
-	to->di_onlink = 0;
-
-	to->di_version = from->di_version;
-	to->di_format = from->di_format;
-	to->di_uid = cpu_to_be32(from->di_uid);
-	to->di_gid = cpu_to_be32(from->di_gid);
-	to->di_projid_lo = cpu_to_be16(from->di_projid_lo);
-	to->di_projid_hi = cpu_to_be16(from->di_projid_hi);
-
-	memset(to->di_pad, 0, sizeof(to->di_pad));
-	to->di_atime.t_sec = cpu_to_be32(inode->i_atime.tv_sec);
-	to->di_atime.t_nsec = cpu_to_be32(inode->i_atime.tv_nsec);
-	to->di_mtime.t_sec = cpu_to_be32(inode->i_mtime.tv_sec);
-	to->di_mtime.t_nsec = cpu_to_be32(inode->i_mtime.tv_nsec);
-	to->di_ctime.t_sec = cpu_to_be32(inode->i_ctime.tv_sec);
-	to->di_ctime.t_nsec = cpu_to_be32(inode->i_ctime.tv_nsec);
-	to->di_nlink = cpu_to_be32(inode->i_nlink);
-	to->di_gen = cpu_to_be32(inode->i_generation);
-	to->di_mode = cpu_to_be16(inode->i_mode);
-
-	to->di_size = cpu_to_be64(from->di_size);
-	to->di_nblocks = cpu_to_be64(from->di_nblocks);
-	to->di_extsize = cpu_to_be32(from->di_extsize);
-	to->di_nextents = cpu_to_be32(from->di_nextents);
-	to->di_anextents = cpu_to_be16(from->di_anextents);
-	to->di_forkoff = from->di_forkoff;
-	to->di_aformat = from->di_aformat;
-	to->di_dmevmask = cpu_to_be32(from->di_dmevmask);
-	to->di_dmstate = cpu_to_be16(from->di_dmstate);
-	to->di_flags = cpu_to_be16(from->di_flags);
-
-	if (from->di_version == 3) {
-		to->di_changecount = cpu_to_be64(inode->i_version);
-		to->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);
-		to->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);
-		to->di_flags2 = cpu_to_be64(from->di_flags2);
-		to->di_cowextsize = cpu_to_be32(from->di_cowextsize);
-		to->di_ino = cpu_to_be64(ip->i_ino);
-		to->di_lsn = cpu_to_be64(lsn);
-		memset(to->di_pad2, 0, sizeof(to->di_pad2));
-		uuid_copy(&to->di_uuid, &ip->i_mount->m_sb.sb_meta_uuid);
-		to->di_flushiter = 0;
-	} else {
-		to->di_flushiter = cpu_to_be16(from->di_flushiter);
+		to->di_ino = be64_to_cpu(from->di_ino);
+		to->di_lsn = be64_to_cpu(from->di_lsn);
+		memcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));
+		uuid_copy(&to->di_uuid, &from->di_uuid);
 	}
 }

 void
-xfs_log_dinode_to_disk(
-	struct xfs_log_dinode	*from,
-	struct xfs_dinode	*to)
+xfs_dinode_to_disk(
+	xfs_dinode_t		*to,
+	xfs_icdinode_t		*from)
 {
 	to->di_magic = cpu_to_be16(from->di_magic);
 	to->di_mode = cpu_to_be16(from->di_mode);
-	to->di_version = from->di_version;
+	to->di_version = from ->di_version;
 	to->di_format = from->di_format;
-	to->di_onlink = 0;
+	to->di_onlink = cpu_to_be16(from->di_onlink);
 	to->di_uid = cpu_to_be32(from->di_uid);
 	to->di_gid = cpu_to_be32(from->di_gid);
 	to->di_nlink = cpu_to_be32(from->di_nlink);
 	to->di_projid_lo = cpu_to_be16(from->di_projid_lo);
 	to->di_projid_hi = cpu_to_be16(from->di_projid_hi);
 	memcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));
-
 	to->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);
 	to->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);
 	to->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);
 	to->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);
 	to->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);
 	to->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);
-
 	to->di_size = cpu_to_be64(from->di_size);
 	to->di_nblocks = cpu_to_be64(from->di_nblocks);
 	to->di_extsize = cpu_to_be32(from->di_extsize);
@@ -367,7 +289,6 @@ xfs_log_dinode_to_disk(
 		to->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);
 		to->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);
 		to->di_flags2 = cpu_to_be64(from->di_flags2);
-		to->di_cowextsize = cpu_to_be32(from->di_cowextsize);
 		to->di_ino = cpu_to_be64(from->di_ino);
 		to->di_lsn = cpu_to_be64(from->di_lsn);
 		memcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));
@@ -384,9 +305,6 @@ xfs_dinode_verify(
 	xfs_ino_t		ino,
 	struct xfs_dinode	*dip)
 {
-	uint16_t		flags;
-	uint64_t		flags2;
-
 	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 		return false;

@@ -403,23 +321,6 @@ xfs_dinode_verify(
 		return false;
 	if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
 		return false;
-
-	flags = be16_to_cpu(dip->di_flags);
-	flags2 = be64_to_cpu(dip->di_flags2);
-
-	/* don't allow reflink/cowextsize if we don't have reflink */
-	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
-            !xfs_sb_version_hasreflink(&mp->m_sb))
-		return false;
-
-	/* don't let reflink and realtime mix */
-	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
-		return false;
-
-	/* don't let reflink and dax mix */
-	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
-		return false;
-
 	return true;
 }

@@ -475,10 +376,13 @@ xfs_iread(
 	    !(mp->m_flags & XFS_MOUNT_IKEEP)) {
 		/* initialise the on-disk inode core */
 		memset(&ip->i_d, 0, sizeof(ip->i_d));
-		VFS_I(ip)->i_generation = prandom_u32();
-		if (xfs_sb_version_hascrc(&mp->m_sb))
+		ip->i_d.di_magic = XFS_DINODE_MAGIC;
+		ip->i_d.di_gen = prandom_u32();
+		if (xfs_sb_version_hascrc(&mp->m_sb)) {
 			ip->i_d.di_version = 3;
-		else
+			ip->i_d.di_ino = ip->i_ino;
+			uuid_copy(&ip->i_d.di_uuid, &mp->m_sb.sb_meta_uuid);
+		} else
 			ip->i_d.di_version = 2;
 		return 0;
 	}
@@ -508,7 +412,7 @@ xfs_iread(
 	 * Otherwise, just get the truly permanent information.
 	 */
 	if (dip->di_mode) {
-		xfs_inode_from_disk(ip, dip);
+		xfs_dinode_from_disk(&ip->i_d, dip);
 		error = xfs_iformat_fork(ip, dip);
 		if (error)  {
 #ifdef DEBUG
@@ -522,10 +426,16 @@ xfs_iread(
 		 * Partial initialisation of the in-core inode. Just the bits
 		 * that xfs_ialloc won't overwrite or relies on being correct.
 		 */
+		ip->i_d.di_magic = be16_to_cpu(dip->di_magic);
 		ip->i_d.di_version = dip->di_version;
-		VFS_I(ip)->i_generation = be32_to_cpu(dip->di_gen);
+		ip->i_d.di_gen = be32_to_cpu(dip->di_gen);
 		ip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);

+		if (dip->di_version == 3) {
+			ip->i_d.di_ino = be64_to_cpu(dip->di_ino);
+			uuid_copy(&ip->i_d.di_uuid, &dip->di_uuid);
+		}
+
 		/*
 		 * Make sure to pull in the mode here as well in
 		 * case the inode is released without being used.
@@ -533,10 +443,24 @@ xfs_iread(
 		 * the inode is already free and not try to mess
 		 * with the uninitialized part of it.
 		 */
-		VFS_I(ip)->i_mode = 0;
+		ip->i_d.di_mode = 0;
 	}

-	ASSERT(ip->i_d.di_version >= 2);
+	/*
+	 * Automatically convert version 1 inode formats in memory to version 2
+	 * inode format. If the inode is modified, it will get logged and
+	 * rewritten as a version 2 inode. We can do this because we set the
+	 * superblock feature bit for v2 inodes unconditionally during mount
+	 * and it means the reast of the code can assume the inode version is 2
+	 * or higher.
+	 */
+	if (ip->i_d.di_version == 1) {
+		ip->i_d.di_version = 2;
+		memset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));
+		ip->i_d.di_nlink = ip->i_d.di_onlink;
+		ip->i_d.di_onlink = 0;
+		xfs_set_projid(&ip->i_d, 0);
+	}

 	ip->i_delayed_blks = 0;

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_inode_buf.h package_partclone/src/xfs/libxfs/xfs_inode_buf.h
--- package_partclone_orig/src/xfs/libxfs/xfs_inode_buf.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_inode_buf.h	2019-11-12 13:59:47.927149884 -0300
@@ -20,37 +20,7 @@

 struct xfs_inode;
 struct xfs_dinode;
-
-/*
- * In memory representation of the XFS inode. This is held in the in-core struct
- * xfs_inode and represents the current on disk values but the structure is not
- * in on-disk format.  That is, this structure is always translated to on-disk
- * format specific structures at the appropriate time.
- */
-struct xfs_icdinode {
-	__int8_t	di_version;	/* inode version */
-	__int8_t	di_format;	/* format of di_c data */
-	__uint16_t	di_flushiter;	/* incremented on flush */
-	__uint32_t	di_uid;		/* owner's user id */
-	__uint32_t	di_gid;		/* owner's group id */
-	__uint16_t	di_projid_lo;	/* lower part of owner's project id */
-	__uint16_t	di_projid_hi;	/* higher part of owner's project id */
-	xfs_fsize_t	di_size;	/* number of bytes in file */
-	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
-	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
-	xfs_extnum_t	di_nextents;	/* number of extents in data fork */
-	xfs_aextnum_t	di_anextents;	/* number of extents in attribute fork*/
-	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
-	__int8_t	di_aformat;	/* format of attr fork's data */
-	__uint32_t	di_dmevmask;	/* DMIG event mask */
-	__uint16_t	di_dmstate;	/* DMIG state info */
-	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
-
-	__uint64_t	di_flags2;	/* more random flags */
-	__uint32_t	di_cowextsize;	/* basic cow extent size for file */
-
-	xfs_ictimestamp_t di_crtime;	/* time created */
-};
+struct xfs_icdinode;

 /*
  * Inode location information.  Stored in the inode and passed to
@@ -68,11 +38,8 @@ int	xfs_imap_to_bp(struct xfs_mount *, s
 int	xfs_iread(struct xfs_mount *, struct xfs_trans *,
 		  struct xfs_inode *, uint);
 void	xfs_dinode_calc_crc(struct xfs_mount *, struct xfs_dinode *);
-void	xfs_inode_to_disk(struct xfs_inode *ip, struct xfs_dinode *to,
-			  xfs_lsn_t lsn);
-void	xfs_inode_from_disk(struct xfs_inode *ip, struct xfs_dinode *from);
-void	xfs_log_dinode_to_disk(struct xfs_log_dinode *from,
-			       struct xfs_dinode *to);
+void	xfs_dinode_to_disk(struct xfs_dinode *to, struct xfs_icdinode *from);
+void	xfs_dinode_from_disk(struct xfs_icdinode *to, struct xfs_dinode *from);
 bool	xfs_dinode_verify(struct xfs_mount *mp, xfs_ino_t ino,
 			  struct xfs_dinode *dip);

diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_inode_fork.c package_partclone/src/xfs/libxfs/xfs_inode_fork.c
--- package_partclone_orig/src/xfs/libxfs/xfs_inode_fork.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_inode_fork.c	2019-11-12 13:59:47.928149884 -0300
@@ -117,27 +117,7 @@ xfs_iformat_fork(
 		return -EFSCORRUPTED;
 	}

-	if (unlikely(xfs_is_reflink_inode(ip) &&
-	    (VFS_I(ip)->i_mode & S_IFMT) != S_IFREG)) {
-		xfs_warn(ip->i_mount,
-			"corrupt dinode %llu, wrong file type for reflink.",
-			ip->i_ino);
-		XFS_CORRUPTION_ERROR("xfs_iformat(reflink)",
-				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
-		return -EFSCORRUPTED;
-	}
-
-	if (unlikely(xfs_is_reflink_inode(ip) &&
-	    (ip->i_d.di_flags & XFS_DIFLAG_REALTIME))) {
-		xfs_warn(ip->i_mount,
-			"corrupt dinode %llu, has reflink+realtime flag set.",
-			ip->i_ino);
-		XFS_CORRUPTION_ERROR("xfs_iformat(reflink)",
-				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
-		return -EFSCORRUPTED;
-	}
-
-	switch (VFS_I(ip)->i_mode & S_IFMT) {
+	switch (ip->i_d.di_mode & S_IFMT) {
 	case S_IFIFO:
 	case S_IFCHR:
 	case S_IFBLK:
@@ -202,14 +182,9 @@ xfs_iformat_fork(
 		XFS_ERROR_REPORT("xfs_iformat(7)", XFS_ERRLEVEL_LOW, ip->i_mount);
 		return -EFSCORRUPTED;
 	}
-	if (error)
+	if (error) {
 		return error;
-
-	if (xfs_is_reflink_inode(ip)) {
-		ASSERT(ip->i_cowfp == NULL);
-		xfs_ifork_init_cow(ip);
 	}
-
 	if (!XFS_DFORK_Q(dip))
 		return 0;

@@ -229,8 +204,7 @@ xfs_iformat_fork(
 			XFS_CORRUPTION_ERROR("xfs_iformat(8)",
 					     XFS_ERRLEVEL_LOW,
 					     ip->i_mount, dip);
-			error = -EFSCORRUPTED;
-			break;
+			return -EFSCORRUPTED;
 		}

 		error = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);
@@ -248,56 +222,11 @@ xfs_iformat_fork(
 	if (error) {
 		kmem_zone_free(xfs_ifork_zone, ip->i_afp);
 		ip->i_afp = NULL;
-		if (ip->i_cowfp)
-			kmem_zone_free(xfs_ifork_zone, ip->i_cowfp);
-		ip->i_cowfp = NULL;
 		xfs_idestroy_fork(ip, XFS_DATA_FORK);
 	}
 	return error;
 }

-void
-xfs_init_local_fork(
-	struct xfs_inode	*ip,
-	int			whichfork,
-	const void		*data,
-	int			size)
-{
-	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
-	int			mem_size = size, real_size = 0;
-	bool			zero_terminate;
-
-	/*
-	 * If we are using the local fork to store a symlink body we need to
-	 * zero-terminate it so that we can pass it back to the VFS directly.
-	 * Overallocate the in-memory fork by one for that and add a zero
-	 * to terminate it below.
-	 */
-	zero_terminate = S_ISLNK(VFS_I(ip)->i_mode);
-	if (zero_terminate)
-		mem_size++;
-
-	if (size == 0)
-		ifp->if_u1.if_data = NULL;
-	else if (mem_size <= sizeof(ifp->if_u2.if_inline_data))
-		ifp->if_u1.if_data = ifp->if_u2.if_inline_data;
-	else {
-		real_size = roundup(mem_size, 4);
-		ifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);
-	}
-
-	if (size) {
-		memcpy(ifp->if_u1.if_data, data, size);
-		if (zero_terminate)
-			ifp->if_u1.if_data[size] = '\0';
-	}
-
-	ifp->if_bytes = size;
-	ifp->if_real_bytes = real_size;
-	ifp->if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);
-	ifp->if_flags |= XFS_IFINLINE;
-}
-
 /*
  * The file is in-lined in the on-disk inode.
  * If it fits into if_inline_data, then copy
@@ -315,6 +244,8 @@ xfs_iformat_local(
 	int		whichfork,
 	int		size)
 {
+	xfs_ifork_t	*ifp;
+	int		real_size;

 	/*
 	 * If the size is unreasonable, then something
@@ -330,8 +261,22 @@ xfs_iformat_local(
 				     ip->i_mount, dip);
 		return -EFSCORRUPTED;
 	}
-
-	xfs_init_local_fork(ip, whichfork, XFS_DFORK_PTR(dip, whichfork), size);
+	ifp = XFS_IFORK_PTR(ip, whichfork);
+	real_size = 0;
+	if (size == 0)
+		ifp->if_u1.if_data = NULL;
+	else if (size <= sizeof(ifp->if_u2.if_inline_data))
+		ifp->if_u1.if_data = ifp->if_u2.if_inline_data;
+	else {
+		real_size = roundup(size, 4);
+		ifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);
+	}
+	ifp->if_bytes = size;
+	ifp->if_real_bytes = real_size;
+	if (size)
+		memcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);
+	ifp->if_flags &= ~XFS_IFEXTENTS;
+	ifp->if_flags |= XFS_IFINLINE;
 	return 0;
 }

@@ -567,6 +512,7 @@ xfs_iroot_realloc(
 		new_max = cur_max + rec_diff;
 		new_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);
 		ifp->if_broot = kmem_realloc(ifp->if_broot, new_size,
+				XFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),
 				KM_SLEEP | KM_NOFS);
 		op = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,
 						     ifp->if_broot_bytes);
@@ -710,6 +656,7 @@ xfs_idata_realloc(
 				ifp->if_u1.if_data =
 					kmem_realloc(ifp->if_u1.if_data,
 							real_size,
+							ifp->if_real_bytes,
 							KM_SLEEP | KM_NOFS);
 			}
 		} else {
@@ -765,9 +712,6 @@ xfs_idestroy_fork(
 	if (whichfork == XFS_ATTR_FORK) {
 		kmem_zone_free(xfs_ifork_zone, ip->i_afp);
 		ip->i_afp = NULL;
-	} else if (whichfork == XFS_COW_FORK) {
-		kmem_zone_free(xfs_ifork_zone, ip->i_cowfp);
-		ip->i_cowfp = NULL;
 	}
 }

@@ -955,19 +899,6 @@ xfs_iext_get_ext(
 	}
 }

-/* Convert bmap state flags to an inode fork. */
-struct xfs_ifork *
-xfs_iext_state_to_fork(
-	struct xfs_inode	*ip,
-	int			state)
-{
-	if (state & BMAP_COWFORK)
-		return ip->i_cowfp;
-	else if (state & BMAP_ATTRFORK)
-		return ip->i_afp;
-	return &ip->i_df;
-}
-
 /*
  * Insert new item(s) into the extent records for incore inode
  * fork 'ifp'.  'count' new items are inserted at index 'idx'.
@@ -980,7 +911,7 @@ xfs_iext_insert(
 	xfs_bmbt_irec_t	*new,		/* items to insert */
 	int		state)		/* type of extent conversion */
 {
-	xfs_ifork_t	*ifp = xfs_iext_state_to_fork(ip, state);
+	xfs_ifork_t	*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;
 	xfs_extnum_t	i;		/* extent record index */

 	trace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);
@@ -1230,7 +1161,7 @@ xfs_iext_remove(
 	int		ext_diff,	/* number of extents to remove */
 	int		state)		/* type of extent conversion */
 {
-	xfs_ifork_t	*ifp = xfs_iext_state_to_fork(ip, state);
+	xfs_ifork_t	*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;
 	xfs_extnum_t	nextents;	/* number of extents in file */
 	int		new_size;	/* size of extents after removal */

@@ -1441,7 +1372,8 @@ xfs_iext_realloc_direct(
 		if (rnew_size != ifp->if_real_bytes) {
 			ifp->if_u1.if_extents =
 				kmem_realloc(ifp->if_u1.if_extents,
-						rnew_size, KM_NOFS);
+						rnew_size,
+						ifp->if_real_bytes, KM_NOFS);
 		}
 		if (rnew_size > ifp->if_real_bytes) {
 			memset(&ifp->if_u1.if_extents[ifp->if_bytes /
@@ -1514,7 +1446,6 @@ xfs_iext_realloc_indirect(
 	xfs_ifork_t	*ifp,		/* inode fork pointer */
 	int		new_size)	/* new indirection array size */
 {
-#ifdef DEBUG
 	int		nlists;		/* number of irec's (ex lists) */
 	int		size;		/* current indirection array size */

@@ -1523,12 +1454,12 @@ xfs_iext_realloc_indirect(
 	size = nlists * sizeof(xfs_ext_irec_t);
 	ASSERT(ifp->if_real_bytes);
 	ASSERT((new_size >= 0) && (new_size != size));
-#endif
 	if (new_size == 0) {
 		xfs_iext_destroy(ifp);
 	} else {
-		ifp->if_u1.if_ext_irec =
-			kmem_realloc(ifp->if_u1.if_ext_irec, new_size, KM_NOFS);
+		ifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)
+			kmem_realloc(ifp->if_u1.if_ext_irec,
+				new_size, size, KM_NOFS);
 	}
 }

@@ -1562,24 +1493,6 @@ xfs_iext_indirect_to_direct(
 }

 /*
- * Remove all records from the indirection array.
- */
-STATIC void
-xfs_iext_irec_remove_all(
-	struct xfs_ifork *ifp)
-{
-	int		nlists;
-	int		i;
-
-	ASSERT(ifp->if_flags & XFS_IFEXTIREC);
-	nlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;
-	for (i = 0; i < nlists; i++)
-		kmem_free(ifp->if_u1.if_ext_irec[i].er_extbuf);
-	kmem_free(ifp->if_u1.if_ext_irec);
-	ifp->if_flags &= ~XFS_IFEXTIREC;
-}
-
-/*
  * Free incore file extents.
  */
 void
@@ -1587,7 +1500,14 @@ xfs_iext_destroy(
 	xfs_ifork_t	*ifp)		/* inode fork pointer */
 {
 	if (ifp->if_flags & XFS_IFEXTIREC) {
-		xfs_iext_irec_remove_all(ifp);
+		int	erp_idx;
+		int	nlists;
+
+		nlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;
+		for (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {
+			xfs_iext_irec_remove(ifp, erp_idx);
+		}
+		ifp->if_flags &= ~XFS_IFEXTIREC;
 	} else if (ifp->if_real_bytes) {
 		kmem_free(ifp->if_u1.if_extents);
 	} else if (ifp->if_bytes) {
@@ -1977,20 +1897,3 @@ xfs_iext_irec_update_extoffs(
 		ifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;
 	}
 }
-
-/*
- * Initialize an inode's copy-on-write fork.
- */
-void
-xfs_ifork_init_cow(
-	struct xfs_inode	*ip)
-{
-	if (ip->i_cowfp)
-		return;
-
-	ip->i_cowfp = kmem_zone_zalloc(xfs_ifork_zone,
-				       KM_SLEEP | KM_NOFS);
-	ip->i_cowfp->if_flags = XFS_IFEXTENTS;
-	ip->i_cformat = XFS_DINODE_FMT_EXTENTS;
-	ip->i_cnextents = 0;
-}
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_inode_fork.h package_partclone/src/xfs/libxfs/xfs_inode_fork.h
--- package_partclone_orig/src/xfs/libxfs/xfs_inode_fork.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_inode_fork.h	2019-11-12 13:59:47.928149884 -0300
@@ -92,9 +92,7 @@ typedef struct xfs_ifork {
 #define XFS_IFORK_PTR(ip,w)		\
 	((w) == XFS_DATA_FORK ? \
 		&(ip)->i_df : \
-		((w) == XFS_ATTR_FORK ? \
-			(ip)->i_afp : \
-			(ip)->i_cowfp))
+		(ip)->i_afp)
 #define XFS_IFORK_DSIZE(ip) \
 	(XFS_IFORK_Q(ip) ? \
 		XFS_IFORK_BOFF(ip) : \
@@ -107,38 +105,26 @@ typedef struct xfs_ifork {
 #define XFS_IFORK_SIZE(ip,w) \
 	((w) == XFS_DATA_FORK ? \
 		XFS_IFORK_DSIZE(ip) : \
-		((w) == XFS_ATTR_FORK ? \
-			XFS_IFORK_ASIZE(ip) : \
-			0))
+		XFS_IFORK_ASIZE(ip))
 #define XFS_IFORK_FORMAT(ip,w) \
 	((w) == XFS_DATA_FORK ? \
 		(ip)->i_d.di_format : \
-		((w) == XFS_ATTR_FORK ? \
-			(ip)->i_d.di_aformat : \
-			(ip)->i_cformat))
+		(ip)->i_d.di_aformat)
 #define XFS_IFORK_FMT_SET(ip,w,n) \
 	((w) == XFS_DATA_FORK ? \
 		((ip)->i_d.di_format = (n)) : \
-		((w) == XFS_ATTR_FORK ? \
-			((ip)->i_d.di_aformat = (n)) : \
-			((ip)->i_cformat = (n))))
+		((ip)->i_d.di_aformat = (n)))
 #define XFS_IFORK_NEXTENTS(ip,w) \
 	((w) == XFS_DATA_FORK ? \
 		(ip)->i_d.di_nextents : \
-		((w) == XFS_ATTR_FORK ? \
-			(ip)->i_d.di_anextents : \
-			(ip)->i_cnextents))
+		(ip)->i_d.di_anextents)
 #define XFS_IFORK_NEXT_SET(ip,w,n) \
 	((w) == XFS_DATA_FORK ? \
 		((ip)->i_d.di_nextents = (n)) : \
-		((w) == XFS_ATTR_FORK ? \
-			((ip)->i_d.di_anextents = (n)) : \
-			((ip)->i_cnextents = (n))))
+		((ip)->i_d.di_anextents = (n)))
 #define XFS_IFORK_MAXEXT(ip, w) \
 	(XFS_IFORK_SIZE(ip, w) / sizeof(xfs_bmbt_rec_t))

-struct xfs_ifork *xfs_iext_state_to_fork(struct xfs_inode *ip, int state);
-
 int		xfs_iformat_fork(struct xfs_inode *, struct xfs_dinode *);
 void		xfs_iflush_fork(struct xfs_inode *, struct xfs_dinode *,
 				struct xfs_inode_log_item *, int);
@@ -148,7 +134,6 @@ void		xfs_iroot_realloc(struct xfs_inode
 int		xfs_iread_extents(struct xfs_trans *, struct xfs_inode *, int);
 int		xfs_iextents_copy(struct xfs_inode *, struct xfs_bmbt_rec *,
 				  int);
-void		xfs_init_local_fork(struct xfs_inode *, int, const void *, int);

 struct xfs_bmbt_rec_host *
 		xfs_iext_get_ext(struct xfs_ifork *, xfs_extnum_t);
@@ -183,6 +168,4 @@ void		xfs_iext_irec_update_extoffs(struc

 extern struct kmem_zone	*xfs_ifork_zone;

-extern void xfs_ifork_init_cow(struct xfs_inode *ip);
-
 #endif	/* __XFS_INODE_FORK_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_log_format.h package_partclone/src/xfs/libxfs/xfs_log_format.h
--- package_partclone_orig/src/xfs/libxfs/xfs_log_format.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_log_format.h	2019-11-12 13:59:47.929149884 -0300
@@ -110,13 +110,7 @@ static inline uint xlog_get_cycle(char *
 #define XLOG_REG_TYPE_COMMIT		18
 #define XLOG_REG_TYPE_TRANSHDR		19
 #define XLOG_REG_TYPE_ICREATE		20
-#define XLOG_REG_TYPE_RUI_FORMAT	21
-#define XLOG_REG_TYPE_RUD_FORMAT	22
-#define XLOG_REG_TYPE_CUI_FORMAT	23
-#define XLOG_REG_TYPE_CUD_FORMAT	24
-#define XLOG_REG_TYPE_BUI_FORMAT	25
-#define XLOG_REG_TYPE_BUD_FORMAT	26
-#define XLOG_REG_TYPE_MAX		26
+#define XLOG_REG_TYPE_MAX		20

 /*
  * Flags to log operation header
@@ -218,11 +212,6 @@ typedef struct xfs_trans_header {
 #define	XFS_TRANS_HEADER_MAGIC	0x5452414e	/* TRAN */

 /*
- * The only type valid for th_type in CIL-enabled file system logs:
- */
-#define XFS_TRANS_CHECKPOINT	40
-
-/*
  * Log item types.
  */
 #define	XFS_LI_EFI		0x1236
@@ -233,12 +222,6 @@ typedef struct xfs_trans_header {
 #define	XFS_LI_DQUOT		0x123d
 #define	XFS_LI_QUOTAOFF		0x123e
 #define	XFS_LI_ICREATE		0x123f
-#define	XFS_LI_RUI		0x1240	/* rmap update intent */
-#define	XFS_LI_RUD		0x1241
-#define	XFS_LI_CUI		0x1242	/* refcount update intent */
-#define	XFS_LI_CUD		0x1243
-#define	XFS_LI_BUI		0x1244	/* bmbt update intent */
-#define	XFS_LI_BUD		0x1245

 #define XFS_LI_TYPE_DESC \
 	{ XFS_LI_EFI,		"XFS_LI_EFI" }, \
@@ -248,13 +231,7 @@ typedef struct xfs_trans_header {
 	{ XFS_LI_BUF,		"XFS_LI_BUF" }, \
 	{ XFS_LI_DQUOT,		"XFS_LI_DQUOT" }, \
 	{ XFS_LI_QUOTAOFF,	"XFS_LI_QUOTAOFF" }, \
-	{ XFS_LI_ICREATE,	"XFS_LI_ICREATE" }, \
-	{ XFS_LI_RUI,		"XFS_LI_RUI" }, \
-	{ XFS_LI_RUD,		"XFS_LI_RUD" }, \
-	{ XFS_LI_CUI,		"XFS_LI_CUI" }, \
-	{ XFS_LI_CUD,		"XFS_LI_CUD" }, \
-	{ XFS_LI_BUI,		"XFS_LI_BUI" }, \
-	{ XFS_LI_BUD,		"XFS_LI_BUD" }
+	{ XFS_LI_ICREATE,	"XFS_LI_ICREATE" }

 /*
  * Inode Log Item Format definitions.
@@ -313,7 +290,6 @@ typedef struct xfs_inode_log_format_64 {
 	__int32_t		ilf_boffset;	/* off of inode in buffer */
 } xfs_inode_log_format_64_t;

-
 /*
  * Flags for xfs_trans_log_inode flags field.
  */
@@ -384,15 +360,15 @@ typedef struct xfs_ictimestamp {
 } xfs_ictimestamp_t;

 /*
- * Define the format of the inode core that is logged. This structure must be
- * kept identical to struct xfs_dinode except for the endianness annotations.
+ * NOTE:  This structure must be kept identical to struct xfs_dinode
+ *	  except for the endianness annotations.
  */
-struct xfs_log_dinode {
+typedef struct xfs_icdinode {
 	__uint16_t	di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
 	__uint16_t	di_mode;	/* mode and type of file */
 	__int8_t	di_version;	/* inode version */
 	__int8_t	di_format;	/* format of di_c data */
-	__uint8_t	di_pad3[2];	/* unused in v2/3 inodes */
+	__uint16_t	di_onlink;	/* old number of links to file */
 	__uint32_t	di_uid;		/* owner's user id */
 	__uint32_t	di_gid;		/* owner's group id */
 	__uint32_t	di_nlink;	/* number of links to file */
@@ -423,8 +399,7 @@ struct xfs_log_dinode {
 	__uint64_t	di_changecount;	/* number of attribute changes */
 	xfs_lsn_t	di_lsn;		/* flush sequence */
 	__uint64_t	di_flags2;	/* more random flags */
-	__uint32_t	di_cowextsize;	/* basic cow extent size for file */
-	__uint8_t	di_pad2[12];	/* more padding for future expansion */
+	__uint8_t	di_pad2[16];	/* more padding for future expansion */

 	/* fields only written to during inode creation */
 	xfs_ictimestamp_t di_crtime;	/* time created */
@@ -432,13 +407,13 @@ struct xfs_log_dinode {
 	uuid_t		di_uuid;	/* UUID of the filesystem */

 	/* structure must be padded to 64 bit alignment */
-};
+} xfs_icdinode_t;

-static inline uint xfs_log_dinode_size(int version)
+static inline uint xfs_icdinode_size(int version)
 {
 	if (version == 3)
-		return sizeof(struct xfs_log_dinode);
-	return offsetof(struct xfs_log_dinode, di_next_unlinked);
+		return sizeof(struct xfs_icdinode);
+	return offsetof(struct xfs_icdinode, di_next_unlinked);
 }

 /*
@@ -520,8 +495,6 @@ enum xfs_blft {
 	XFS_BLFT_ATTR_LEAF_BUF,
 	XFS_BLFT_ATTR_RMT_BUF,
 	XFS_BLFT_SB_BUF,
-	XFS_BLFT_RTBITMAP_BUF,
-	XFS_BLFT_RTSUMMARY_BUF,
 	XFS_BLFT_MAX_BUF = (1 << XFS_BLFT_BITS),
 };

@@ -623,166 +596,6 @@ typedef struct xfs_efd_log_format_64 {
 } xfs_efd_log_format_64_t;

 /*
- * RUI/RUD (reverse mapping) log format definitions
- */
-struct xfs_map_extent {
-	__uint64_t		me_owner;
-	__uint64_t		me_startblock;
-	__uint64_t		me_startoff;
-	__uint32_t		me_len;
-	__uint32_t		me_flags;
-};
-
-/* rmap me_flags: upper bits are flags, lower byte is type code */
-#define XFS_RMAP_EXTENT_MAP		1
-#define XFS_RMAP_EXTENT_MAP_SHARED	2
-#define XFS_RMAP_EXTENT_UNMAP		3
-#define XFS_RMAP_EXTENT_UNMAP_SHARED	4
-#define XFS_RMAP_EXTENT_CONVERT		5
-#define XFS_RMAP_EXTENT_CONVERT_SHARED	6
-#define XFS_RMAP_EXTENT_ALLOC		7
-#define XFS_RMAP_EXTENT_FREE		8
-#define XFS_RMAP_EXTENT_TYPE_MASK	0xFF
-
-#define XFS_RMAP_EXTENT_ATTR_FORK	(1U << 31)
-#define XFS_RMAP_EXTENT_BMBT_BLOCK	(1U << 30)
-#define XFS_RMAP_EXTENT_UNWRITTEN	(1U << 29)
-
-#define XFS_RMAP_EXTENT_FLAGS		(XFS_RMAP_EXTENT_TYPE_MASK | \
-					 XFS_RMAP_EXTENT_ATTR_FORK | \
-					 XFS_RMAP_EXTENT_BMBT_BLOCK | \
-					 XFS_RMAP_EXTENT_UNWRITTEN)
-
-/*
- * This is the structure used to lay out an rui log item in the
- * log.  The rui_extents field is a variable size array whose
- * size is given by rui_nextents.
- */
-struct xfs_rui_log_format {
-	__uint16_t		rui_type;	/* rui log item type */
-	__uint16_t		rui_size;	/* size of this item */
-	__uint32_t		rui_nextents;	/* # extents to free */
-	__uint64_t		rui_id;		/* rui identifier */
-	struct xfs_map_extent	rui_extents[];	/* array of extents to rmap */
-};
-
-static inline size_t
-xfs_rui_log_format_sizeof(
-	unsigned int		nr)
-{
-	return sizeof(struct xfs_rui_log_format) +
-			nr * sizeof(struct xfs_map_extent);
-}
-
-/*
- * This is the structure used to lay out an rud log item in the
- * log.  The rud_extents array is a variable size array whose
- * size is given by rud_nextents;
- */
-struct xfs_rud_log_format {
-	__uint16_t		rud_type;	/* rud log item type */
-	__uint16_t		rud_size;	/* size of this item */
-	__uint32_t		__pad;
-	__uint64_t		rud_rui_id;	/* id of corresponding rui */
-};
-
-/*
- * CUI/CUD (refcount update) log format definitions
- */
-struct xfs_phys_extent {
-	__uint64_t		pe_startblock;
-	__uint32_t		pe_len;
-	__uint32_t		pe_flags;
-};
-
-/* refcount pe_flags: upper bits are flags, lower byte is type code */
-/* Type codes are taken directly from enum xfs_refcount_intent_type. */
-#define XFS_REFCOUNT_EXTENT_TYPE_MASK	0xFF
-
-#define XFS_REFCOUNT_EXTENT_FLAGS	(XFS_REFCOUNT_EXTENT_TYPE_MASK)
-
-/*
- * This is the structure used to lay out a cui log item in the
- * log.  The cui_extents field is a variable size array whose
- * size is given by cui_nextents.
- */
-struct xfs_cui_log_format {
-	__uint16_t		cui_type;	/* cui log item type */
-	__uint16_t		cui_size;	/* size of this item */
-	__uint32_t		cui_nextents;	/* # extents to free */
-	__uint64_t		cui_id;		/* cui identifier */
-	struct xfs_phys_extent	cui_extents[];	/* array of extents */
-};
-
-static inline size_t
-xfs_cui_log_format_sizeof(
-	unsigned int		nr)
-{
-	return sizeof(struct xfs_cui_log_format) +
-			nr * sizeof(struct xfs_phys_extent);
-}
-
-/*
- * This is the structure used to lay out a cud log item in the
- * log.  The cud_extents array is a variable size array whose
- * size is given by cud_nextents;
- */
-struct xfs_cud_log_format {
-	__uint16_t		cud_type;	/* cud log item type */
-	__uint16_t		cud_size;	/* size of this item */
-	__uint32_t		__pad;
-	__uint64_t		cud_cui_id;	/* id of corresponding cui */
-};
-
-/*
- * BUI/BUD (inode block mapping) log format definitions
- */
-
-/* bmbt me_flags: upper bits are flags, lower byte is type code */
-/* Type codes are taken directly from enum xfs_bmap_intent_type. */
-#define XFS_BMAP_EXTENT_TYPE_MASK	0xFF
-
-#define XFS_BMAP_EXTENT_ATTR_FORK	(1U << 31)
-#define XFS_BMAP_EXTENT_UNWRITTEN	(1U << 30)
-
-#define XFS_BMAP_EXTENT_FLAGS		(XFS_BMAP_EXTENT_TYPE_MASK | \
-					 XFS_BMAP_EXTENT_ATTR_FORK | \
-					 XFS_BMAP_EXTENT_UNWRITTEN)
-
-/*
- * This is the structure used to lay out an bui log item in the
- * log.  The bui_extents field is a variable size array whose
- * size is given by bui_nextents.
- */
-struct xfs_bui_log_format {
-	__uint16_t		bui_type;	/* bui log item type */
-	__uint16_t		bui_size;	/* size of this item */
-	__uint32_t		bui_nextents;	/* # extents to free */
-	__uint64_t		bui_id;		/* bui identifier */
-	struct xfs_map_extent	bui_extents[];	/* array of extents to bmap */
-};
-
-static inline size_t
-xfs_bui_log_format_sizeof(
-	unsigned int		nr)
-{
-	return sizeof(struct xfs_bui_log_format) +
-			nr * sizeof(struct xfs_map_extent);
-}
-
-/*
- * This is the structure used to lay out an bud log item in the
- * log.  The bud_extents array is a variable size array whose
- * size is given by bud_nextents;
- */
-struct xfs_bud_log_format {
-	__uint16_t		bud_type;	/* bud log item type */
-	__uint16_t		bud_size;	/* size of this item */
-	__uint32_t		__pad;
-	__uint64_t		bud_bui_id;	/* id of corresponding bui */
-};
-
-/*
  * Dquot Log format definitions.
  *
  * The first two fields must be the type and size fitting into
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_rmap.h package_partclone/src/xfs/libxfs/xfs_rmap.h
--- package_partclone_orig/src/xfs/libxfs/xfs_rmap.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_rmap.h	2019-11-12 13:59:47.929149884 -0300
@@ -20,6 +20,9 @@
 #ifndef __XFS_RMAP_H__
 #define __XFS_RMAP_H__

+
+#include "xfs/libxfs/xfs_format.h"
+
 static inline void
 xfs_rmap_ag_owner(
 	struct xfs_owner_info	*oi,
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_rtbitmap.c package_partclone/src/xfs/libxfs/xfs_rtbitmap.c
--- package_partclone_orig/src/xfs/libxfs/xfs_rtbitmap.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_rtbitmap.c	2019-11-12 13:59:47.929149884 -0300
@@ -37,35 +37,10 @@
  */

 /*
- * Real time buffers need verifiers to avoid runtime warnings during IO.
- * We don't have anything to verify, however, so these are just dummy
- * operations.
- */
-static void
-xfs_rtbuf_verify_read(
-	struct xfs_buf	*bp)
-{
-	return;
-}
-
-static void
-xfs_rtbuf_verify_write(
-	struct xfs_buf	*bp)
-{
-	return;
-}
-
-const struct xfs_buf_ops xfs_rtbuf_ops = {
-	.name = "rtbuf",
-	.verify_read = xfs_rtbuf_verify_read,
-	.verify_write = xfs_rtbuf_verify_write,
-};
-
-/*
  * Get a buffer for the bitmap or summary file block specified.
  * The buffer is returned read and locked.
  */
-static int
+int
 xfs_rtbuf_get(
 	xfs_mount_t	*mp,		/* file system mount structure */
 	xfs_trans_t	*tp,		/* transaction pointer */
@@ -88,12 +63,9 @@ xfs_rtbuf_get(
 	ASSERT(map.br_startblock != NULLFSBLOCK);
 	error = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,
 				   XFS_FSB_TO_DADDR(mp, map.br_startblock),
-				   mp->m_bsize, 0, &bp, &xfs_rtbuf_ops);
+				   mp->m_bsize, 0, &bp, NULL);
 	if (error)
 		return error;
-
-	xfs_trans_buf_set_type(tp, bp, issum ? XFS_BLFT_RTSUMMARY_BUF
-					     : XFS_BLFT_RTBITMAP_BUF);
 	*bpp = bp;
 	return 0;
 }
@@ -1006,7 +978,7 @@ xfs_rtfree_extent(
 	    mp->m_sb.sb_rextents) {
 		if (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))
 			mp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;
-		*(__uint64_t *)&VFS_I(mp->m_rbmip)->i_atime = 0;
+		*(__uint64_t *)&mp->m_rbmip->i_d.di_atime = 0;
 		xfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);
 	}
 	return 0;
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_sb.c package_partclone/src/xfs/libxfs/xfs_sb.c
--- package_partclone_orig/src/xfs/libxfs/xfs_sb.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_sb.c	2019-11-12 13:59:47.930149885 -0300
@@ -24,7 +24,6 @@
 #include "xfs_bit.h"
 #include "xfs_sb.h"
 #include "xfs_mount.h"
-#include "xfs_defer.h"
 #include "xfs_inode.h"
 #include "xfs_ialloc.h"
 #include "xfs_alloc.h"
@@ -34,9 +33,6 @@
 #include "xfs_bmap_btree.h"
 #include "xfs_alloc_btree.h"
 #include "xfs_ialloc_btree.h"
-#include "xfs_rmap_btree.h"
-#include "xfs_bmap.h"
-#include "xfs_refcount_btree.h"

 /*
  * Physical superblock buffer manipulations. Shared with libxfs in userspace.
@@ -570,8 +566,7 @@ xfs_sb_verify(
 	 * Only check the in progress field for the primary superblock as
 	 * mkfs.xfs doesn't clear it from secondary superblocks.
 	 */
-	return xfs_mount_validate_sb(mp, &sb,
-				     bp->b_maps[0].bm_bn == XFS_SB_DADDR,
+	return xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,
 				     check_version);
 }

@@ -719,18 +714,6 @@ xfs_sb_mount_common(
 	mp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;
 	mp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;

-	mp->m_rmap_mxr[0] = xfs_rmapbt_maxrecs(mp, sbp->sb_blocksize, 1);
-	mp->m_rmap_mxr[1] = xfs_rmapbt_maxrecs(mp, sbp->sb_blocksize, 0);
-	mp->m_rmap_mnr[0] = mp->m_rmap_mxr[0] / 2;
-	mp->m_rmap_mnr[1] = mp->m_rmap_mxr[1] / 2;
-
-	mp->m_refc_mxr[0] = xfs_refcountbt_maxrecs(mp, sbp->sb_blocksize,
-			true);
-	mp->m_refc_mxr[1] = xfs_refcountbt_maxrecs(mp, sbp->sb_blocksize,
-			false);
-	mp->m_refc_mnr[0] = mp->m_refc_mxr[0] / 2;
-	mp->m_refc_mnr[1] = mp->m_refc_mxr[1] / 2;
-
 	mp->m_bsize = XFS_FSB_TO_BB(mp, 1);
 	mp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,
 					sbp->sb_inopblock);
@@ -740,8 +723,6 @@ xfs_sb_mount_common(
 		mp->m_ialloc_min_blks = sbp->sb_spino_align;
 	else
 		mp->m_ialloc_min_blks = mp->m_ialloc_blks;
-	mp->m_alloc_set_aside = xfs_alloc_set_aside(mp);
-	mp->m_ag_max_usable = xfs_alloc_ag_max_usable(mp);
 }

 /*
@@ -842,10 +823,12 @@ xfs_sync_sb(
 	struct xfs_trans	*tp;
 	int			error;

-	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_sb, 0, 0,
-			XFS_TRANS_NO_WRITECOUNT, &tp);
-	if (error)
+	tp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);
+	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);
+	if (error) {
+		xfs_trans_cancel(tp);
 		return error;
+	}

 	xfs_log_sb(tp);
 	if (wait)
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_sb.h package_partclone/src/xfs/libxfs/xfs_sb.h
--- package_partclone_orig/src/xfs/libxfs/xfs_sb.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_sb.h	2019-11-12 13:59:47.930149885 -0300
@@ -27,6 +27,7 @@ extern struct xfs_perag *xfs_perag_get_t
 extern void	xfs_perag_put(struct xfs_perag *pag);
 extern int	xfs_initialize_perag_data(struct xfs_mount *, xfs_agnumber_t);

+extern void	xfs_sb_calc_crc(struct xfs_buf *bp);
 extern void	xfs_log_sb(struct xfs_trans *tp);
 extern int	xfs_sync_sb(struct xfs_mount *mp, bool wait);
 extern void	xfs_sb_mount_common(struct xfs_mount *mp, struct xfs_sb *sbp);
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_shared.h package_partclone/src/xfs/libxfs/xfs_shared.h
--- package_partclone_orig/src/xfs/libxfs/xfs_shared.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_shared.h	2019-11-12 13:59:47.931149885 -0300
@@ -38,8 +38,6 @@ extern const struct xfs_buf_ops xfs_agi_
 extern const struct xfs_buf_ops xfs_agf_buf_ops;
 extern const struct xfs_buf_ops xfs_agfl_buf_ops;
 extern const struct xfs_buf_ops xfs_allocbt_buf_ops;
-extern const struct xfs_buf_ops xfs_rmapbt_buf_ops;
-extern const struct xfs_buf_ops xfs_refcountbt_buf_ops;
 extern const struct xfs_buf_ops xfs_attr3_leaf_buf_ops;
 extern const struct xfs_buf_ops xfs_attr3_rmt_buf_ops;
 extern const struct xfs_buf_ops xfs_bmbt_buf_ops;
@@ -55,7 +53,103 @@ extern const struct xfs_buf_ops xfs_dquo
 extern const struct xfs_buf_ops xfs_sb_buf_ops;
 extern const struct xfs_buf_ops xfs_sb_quiet_buf_ops;
 extern const struct xfs_buf_ops xfs_symlink_buf_ops;
-extern const struct xfs_buf_ops xfs_rtbuf_ops;
+
+/*
+ * Transaction types.  Used to distinguish types of buffers. These never reach
+ * the log.
+ */
+#define XFS_TRANS_SETATTR_NOT_SIZE	1
+#define XFS_TRANS_SETATTR_SIZE		2
+#define XFS_TRANS_INACTIVE		3
+#define XFS_TRANS_CREATE		4
+#define XFS_TRANS_CREATE_TRUNC		5
+#define XFS_TRANS_TRUNCATE_FILE		6
+#define XFS_TRANS_REMOVE		7
+#define XFS_TRANS_LINK			8
+#define XFS_TRANS_RENAME		9
+#define XFS_TRANS_MKDIR			10
+#define XFS_TRANS_RMDIR			11
+#define XFS_TRANS_SYMLINK		12
+#define XFS_TRANS_SET_DMATTRS		13
+#define XFS_TRANS_GROWFS		14
+#define XFS_TRANS_STRAT_WRITE		15
+#define XFS_TRANS_DIOSTRAT		16
+/* 17 was XFS_TRANS_WRITE_SYNC */
+#define	XFS_TRANS_WRITEID		18
+#define	XFS_TRANS_ADDAFORK		19
+#define	XFS_TRANS_ATTRINVAL		20
+#define	XFS_TRANS_ATRUNCATE		21
+#define	XFS_TRANS_ATTR_SET		22
+#define	XFS_TRANS_ATTR_RM		23
+#define	XFS_TRANS_ATTR_FLAG		24
+#define	XFS_TRANS_CLEAR_AGI_BUCKET	25
+#define XFS_TRANS_SB_CHANGE		26
+/*
+ * Dummy entries since we use the transaction type to index into the
+ * trans_type[] in xlog_recover_print_trans_head()
+ */
+#define XFS_TRANS_DUMMY1		27
+#define XFS_TRANS_DUMMY2		28
+#define XFS_TRANS_QM_QUOTAOFF		29
+#define XFS_TRANS_QM_DQALLOC		30
+#define XFS_TRANS_QM_SETQLIM		31
+#define XFS_TRANS_QM_DQCLUSTER		32
+#define XFS_TRANS_QM_QINOCREATE		33
+#define XFS_TRANS_QM_QUOTAOFF_END	34
+#define XFS_TRANS_FSYNC_TS		35
+#define	XFS_TRANS_GROWFSRT_ALLOC	36
+#define	XFS_TRANS_GROWFSRT_ZERO		37
+#define	XFS_TRANS_GROWFSRT_FREE		38
+#define	XFS_TRANS_SWAPEXT		39
+#define	XFS_TRANS_CHECKPOINT		40
+#define	XFS_TRANS_ICREATE		41
+#define	XFS_TRANS_CREATE_TMPFILE	42
+#define	XFS_TRANS_TYPE_MAX		43
+/* new transaction types need to be reflected in xfs_logprint(8) */
+
+#define XFS_TRANS_TYPES \
+	{ XFS_TRANS_SETATTR_NOT_SIZE,	"SETATTR_NOT_SIZE" }, \
+	{ XFS_TRANS_SETATTR_SIZE,	"SETATTR_SIZE" }, \
+	{ XFS_TRANS_INACTIVE,		"INACTIVE" }, \
+	{ XFS_TRANS_CREATE,		"CREATE" }, \
+	{ XFS_TRANS_CREATE_TRUNC,	"CREATE_TRUNC" }, \
+	{ XFS_TRANS_TRUNCATE_FILE,	"TRUNCATE_FILE" }, \
+	{ XFS_TRANS_REMOVE,		"REMOVE" }, \
+	{ XFS_TRANS_LINK,		"LINK" }, \
+	{ XFS_TRANS_RENAME,		"RENAME" }, \
+	{ XFS_TRANS_MKDIR,		"MKDIR" }, \
+	{ XFS_TRANS_RMDIR,		"RMDIR" }, \
+	{ XFS_TRANS_SYMLINK,		"SYMLINK" }, \
+	{ XFS_TRANS_SET_DMATTRS,	"SET_DMATTRS" }, \
+	{ XFS_TRANS_GROWFS,		"GROWFS" }, \
+	{ XFS_TRANS_STRAT_WRITE,	"STRAT_WRITE" }, \
+	{ XFS_TRANS_DIOSTRAT,		"DIOSTRAT" }, \
+	{ XFS_TRANS_WRITEID,		"WRITEID" }, \
+	{ XFS_TRANS_ADDAFORK,		"ADDAFORK" }, \
+	{ XFS_TRANS_ATTRINVAL,		"ATTRINVAL" }, \
+	{ XFS_TRANS_ATRUNCATE,		"ATRUNCATE" }, \
+	{ XFS_TRANS_ATTR_SET,		"ATTR_SET" }, \
+	{ XFS_TRANS_ATTR_RM,		"ATTR_RM" }, \
+	{ XFS_TRANS_ATTR_FLAG,		"ATTR_FLAG" }, \
+	{ XFS_TRANS_CLEAR_AGI_BUCKET,	"CLEAR_AGI_BUCKET" }, \
+	{ XFS_TRANS_SB_CHANGE,		"SBCHANGE" }, \
+	{ XFS_TRANS_DUMMY1,		"DUMMY1" }, \
+	{ XFS_TRANS_DUMMY2,		"DUMMY2" }, \
+	{ XFS_TRANS_QM_QUOTAOFF,	"QM_QUOTAOFF" }, \
+	{ XFS_TRANS_QM_DQALLOC,		"QM_DQALLOC" }, \
+	{ XFS_TRANS_QM_SETQLIM,		"QM_SETQLIM" }, \
+	{ XFS_TRANS_QM_DQCLUSTER,	"QM_DQCLUSTER" }, \
+	{ XFS_TRANS_QM_QINOCREATE,	"QM_QINOCREATE" }, \
+	{ XFS_TRANS_QM_QUOTAOFF_END,	"QM_QOFF_END" }, \
+	{ XFS_TRANS_FSYNC_TS,		"FSYNC_TS" }, \
+	{ XFS_TRANS_GROWFSRT_ALLOC,	"GROWFSRT_ALLOC" }, \
+	{ XFS_TRANS_GROWFSRT_ZERO,	"GROWFSRT_ZERO" }, \
+	{ XFS_TRANS_GROWFSRT_FREE,	"GROWFSRT_FREE" }, \
+	{ XFS_TRANS_SWAPEXT,		"SWAPEXT" }, \
+	{ XFS_TRANS_CHECKPOINT,		"CHECKPOINT" }, \
+	{ XFS_TRANS_ICREATE,		"ICREATE" }, \
+	{ XFS_TRANS_CREATE_TMPFILE,	"CREATE_TMPFILE" }, \
+	{ XLOG_UNMOUNT_REC_TYPE,	"UNMOUNT" }

 /*
  * This structure is used to track log items associated with
@@ -86,9 +180,8 @@ int	xfs_log_calc_minimum_size(struct xfs
 #define	XFS_TRANS_SYNC		0x08	/* make commit synchronous */
 #define XFS_TRANS_DQ_DIRTY	0x10	/* at least one dquot in trx dirty */
 #define XFS_TRANS_RESERVE	0x20    /* OK to use reserved data blocks */
-#define XFS_TRANS_NO_WRITECOUNT 0x40	/* do not elevate SB writecount */
-#define XFS_TRANS_NOFS		0x80	/* pass KM_NOFS to kmem_alloc */
-
+#define XFS_TRANS_FREEZE_PROT	0x40	/* Transaction has elevated writer
+					   count in superblock */
 /*
  * Field values for xfs_trans_mod_sb.
  */
@@ -118,12 +211,10 @@ int	xfs_log_calc_minimum_size(struct xfs
 #define	XFS_INO_BTREE_REF	3
 #define	XFS_ALLOC_BTREE_REF	2
 #define	XFS_BMAP_BTREE_REF	2
-#define	XFS_RMAP_BTREE_REF	2
 #define	XFS_DIR_BTREE_REF	2
 #define	XFS_INO_REF		2
 #define	XFS_ATTR_BTREE_REF	1
 #define	XFS_DQUOT_REF		1
-#define	XFS_REFC_BTREE_REF	1

 /*
  * Flags for xfs_trans_ichgtime().
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_trans_resv.c package_partclone/src/xfs/libxfs/xfs_trans_resv.c
--- package_partclone_orig/src/xfs/libxfs/xfs_trans_resv.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_trans_resv.c	2019-11-12 13:59:47.931149885 -0300
@@ -63,33 +63,6 @@ xfs_calc_buf_res(
 }

 /*
- * Per-extent log reservation for the btree changes involved in freeing or
- * allocating an extent.  In classic XFS there were two trees that will be
- * modified (bnobt + cntbt).  With rmap enabled, there are three trees
- * (rmapbt).  With reflink, there are four trees (refcountbt).  The number of
- * blocks reserved is based on the formula:
- *
- * num trees * ((2 blocks/level * max depth) - 1)
- *
- * Keep in mind that max depth is calculated separately for each type of tree.
- */
-uint
-xfs_allocfree_log_count(
-	struct xfs_mount *mp,
-	uint		num_ops)
-{
-	uint		blocks;
-
-	blocks = num_ops * 2 * (2 * mp->m_ag_maxlevels - 1);
-	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
-		blocks += num_ops * (2 * mp->m_rmap_maxlevels - 1);
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		blocks += num_ops * (2 * mp->m_refc_maxlevels - 1);
-
-	return blocks;
-}
-
-/*
  * Logging inodes is really tricksy. They are logged in memory format,
  * which means that what we write into the log doesn't directly translate into
  * the amount of space they use on disk.
@@ -152,7 +125,7 @@ xfs_calc_inode_res(
  */
 STATIC uint
 xfs_calc_finobt_res(
-	struct xfs_mount	*mp,
+	struct xfs_mount 	*mp,
 	int			alloc,
 	int			modify)
 {
@@ -163,7 +136,7 @@ xfs_calc_finobt_res(

 	res = xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1));
 	if (alloc)
-		res += xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		res += xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 					XFS_FSB_TO_B(mp, 1));
 	if (modify)
 		res += (uint)XFS_FSB_TO_B(mp, 1);
@@ -179,9 +152,9 @@ xfs_calc_finobt_res(
  * item logged to try to account for the overhead of the transaction mechanism.
  *
  * Note:  Most of the reservations underestimate the number of allocation
- * groups into which they could free extents in the xfs_defer_finish() call.
+ * groups into which they could free extents in the xfs_bmap_finish() call.
  * This is because the number in the worst case is quite high and quite
- * unusual.  In order to fix this we need to change xfs_defer_finish() to free
+ * unusual.  In order to fix this we need to change xfs_bmap_finish() to free
  * extents in only a single AG at a time.  This will require changes to the
  * EFI code as well, however, so that the EFI for the extents not freed is
  * logged again in each transaction.  See SGI PV #261917.
@@ -214,10 +187,10 @@ xfs_calc_write_reservation(
 		     xfs_calc_buf_res(XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK),
 				      XFS_FSB_TO_B(mp, 1)) +
 		     xfs_calc_buf_res(3, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 2),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 2),
 				      XFS_FSB_TO_B(mp, 1))),
 		    (xfs_calc_buf_res(5, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 2),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 2),
 				      XFS_FSB_TO_B(mp, 1))));
 }

@@ -243,10 +216,10 @@ xfs_calc_itruncate_reservation(
 		     xfs_calc_buf_res(XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) + 1,
 				      XFS_FSB_TO_B(mp, 1))),
 		    (xfs_calc_buf_res(9, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 4),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 4),
 				      XFS_FSB_TO_B(mp, 1)) +
 		    xfs_calc_buf_res(5, 0) +
-		    xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		    xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				     XFS_FSB_TO_B(mp, 1)) +
 		    xfs_calc_buf_res(2 + mp->m_ialloc_blks +
 				     mp->m_in_maxlevels, 0)));
@@ -273,7 +246,7 @@ xfs_calc_rename_reservation(
 		     xfs_calc_buf_res(2 * XFS_DIROP_LOG_COUNT(mp),
 				      XFS_FSB_TO_B(mp, 1))),
 		    (xfs_calc_buf_res(7, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 3),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 3),
 				      XFS_FSB_TO_B(mp, 1))));
 }

@@ -312,7 +285,7 @@ xfs_calc_link_reservation(
 		     xfs_calc_buf_res(XFS_DIROP_LOG_COUNT(mp),
 				      XFS_FSB_TO_B(mp, 1))),
 		    (xfs_calc_buf_res(3, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				      XFS_FSB_TO_B(mp, 1))));
 }

@@ -350,7 +323,7 @@ xfs_calc_remove_reservation(
 		     xfs_calc_buf_res(XFS_DIROP_LOG_COUNT(mp),
 				      XFS_FSB_TO_B(mp, 1))),
 		    (xfs_calc_buf_res(4, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 2),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 2),
 				      XFS_FSB_TO_B(mp, 1))));
 }

@@ -397,7 +370,7 @@ xfs_calc_create_resv_alloc(
 		mp->m_sb.sb_sectsize +
 		xfs_calc_buf_res(mp->m_ialloc_blks, XFS_FSB_TO_B(mp, 1)) +
 		xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1)) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1));
 }

@@ -425,7 +398,7 @@ xfs_calc_icreate_resv_alloc(
 	return xfs_calc_buf_res(2, mp->m_sb.sb_sectsize) +
 		mp->m_sb.sb_sectsize +
 		xfs_calc_buf_res(mp->m_in_maxlevels, XFS_FSB_TO_B(mp, 1)) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1)) +
 		xfs_calc_finobt_res(mp, 0, 0);
 }
@@ -509,7 +482,7 @@ xfs_calc_ifree_reservation(
 		xfs_calc_buf_res(1, 0) +
 		xfs_calc_buf_res(2 + mp->m_ialloc_blks +
 				 mp->m_in_maxlevels, 0) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1)) +
 		xfs_calc_finobt_res(mp, 0, 1);
 }
@@ -539,7 +512,7 @@ xfs_calc_growdata_reservation(
 	struct xfs_mount	*mp)
 {
 	return xfs_calc_buf_res(3, mp->m_sb.sb_sectsize) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1));
 }

@@ -561,7 +534,7 @@ xfs_calc_growrtalloc_reservation(
 		xfs_calc_buf_res(XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK),
 				 XFS_FSB_TO_B(mp, 1)) +
 		xfs_calc_inode_res(mp, 1) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1));
 }

@@ -637,7 +610,7 @@ xfs_calc_addafork_reservation(
 		xfs_calc_buf_res(1, mp->m_dir_geo->blksize) +
 		xfs_calc_buf_res(XFS_DAENTER_BMAP1B(mp, XFS_DATA_FORK) + 1,
 				 XFS_FSB_TO_B(mp, 1)) +
-		xfs_calc_buf_res(xfs_allocfree_log_count(mp, 1),
+		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
 				 XFS_FSB_TO_B(mp, 1));
 }

@@ -660,7 +633,7 @@ xfs_calc_attrinval_reservation(
 		    xfs_calc_buf_res(XFS_BM_MAXLEVELS(mp, XFS_ATTR_FORK),
 				     XFS_FSB_TO_B(mp, 1))),
 		   (xfs_calc_buf_res(9, mp->m_sb.sb_sectsize) +
-		    xfs_calc_buf_res(xfs_allocfree_log_count(mp, 4),
+		    xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 4),
 				     XFS_FSB_TO_B(mp, 1))));
 }

@@ -727,7 +700,7 @@ xfs_calc_attrrm_reservation(
 					XFS_BM_MAXLEVELS(mp, XFS_ATTR_FORK)) +
 		     xfs_calc_buf_res(XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK), 0)),
 		    (xfs_calc_buf_res(5, mp->m_sb.sb_sectsize) +
-		     xfs_calc_buf_res(xfs_allocfree_log_count(mp, 2),
+		     xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 2),
 				      XFS_FSB_TO_B(mp, 1))));
 }

@@ -811,18 +784,11 @@ xfs_trans_resv_calc(
 	 * require a permanent reservation on space.
 	 */
 	resp->tr_write.tr_logres = xfs_calc_write_reservation(mp);
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		resp->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT_REFLINK;
-	else
-		resp->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT;
+	resp->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT;
 	resp->tr_write.tr_logflags |= XFS_TRANS_PERM_LOG_RES;

 	resp->tr_itruncate.tr_logres = xfs_calc_itruncate_reservation(mp);
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		resp->tr_itruncate.tr_logcount =
-				XFS_ITRUNCATE_LOG_COUNT_REFLINK;
-	else
-		resp->tr_itruncate.tr_logcount = XFS_ITRUNCATE_LOG_COUNT;
+	resp->tr_itruncate.tr_logcount = XFS_ITRUNCATE_LOG_COUNT;
 	resp->tr_itruncate.tr_logflags |= XFS_TRANS_PERM_LOG_RES;

 	resp->tr_rename.tr_logres = xfs_calc_rename_reservation(mp);
@@ -879,10 +845,7 @@ xfs_trans_resv_calc(
 	resp->tr_growrtalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;

 	resp->tr_qm_dqalloc.tr_logres = xfs_calc_qm_dqalloc_reservation(mp);
-	if (xfs_sb_version_hasreflink(&mp->m_sb))
-		resp->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT_REFLINK;
-	else
-		resp->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT;
+	resp->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT;
 	resp->tr_qm_dqalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;

 	/*
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_trans_resv.h package_partclone/src/xfs/libxfs/xfs_trans_resv.h
--- package_partclone_orig/src/xfs/libxfs/xfs_trans_resv.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_trans_resv.h	2019-11-12 13:59:47.932149885 -0300
@@ -68,6 +68,16 @@ struct xfs_trans_resv {
 #define M_RES(mp)	(&(mp)->m_resv)

 /*
+ * Per-extent log reservation for the allocation btree changes
+ * involved in freeing or allocating an extent.
+ * 2 trees * (2 blocks/level * max depth - 1) * block size
+ */
+#define	XFS_ALLOCFREE_LOG_RES(mp,nx) \
+	((nx) * (2 * XFS_FSB_TO_B((mp), 2 * (mp)->m_ag_maxlevels - 1)))
+#define	XFS_ALLOCFREE_LOG_COUNT(mp,nx) \
+	((nx) * (2 * (2 * (mp)->m_ag_maxlevels - 1)))
+
+/*
  * Per-directory log reservation for any directory change.
  * dir blocks: (1 btree block per level + data block + free block) * dblock size
  * bmap btree: (levels + 2) * max depth * block size
@@ -87,7 +97,6 @@ struct xfs_trans_resv {
 #define	XFS_DEFAULT_LOG_COUNT		1
 #define	XFS_DEFAULT_PERM_LOG_COUNT	2
 #define	XFS_ITRUNCATE_LOG_COUNT		2
-#define	XFS_ITRUNCATE_LOG_COUNT_REFLINK	8
 #define XFS_INACTIVE_LOG_COUNT		2
 #define	XFS_CREATE_LOG_COUNT		2
 #define	XFS_CREATE_TMPFILE_LOG_COUNT	2
@@ -97,13 +106,11 @@ struct xfs_trans_resv {
 #define	XFS_LINK_LOG_COUNT		2
 #define	XFS_RENAME_LOG_COUNT		2
 #define	XFS_WRITE_LOG_COUNT		2
-#define	XFS_WRITE_LOG_COUNT_REFLINK	8
 #define	XFS_ADDAFORK_LOG_COUNT		2
 #define	XFS_ATTRINVAL_LOG_COUNT		1
 #define	XFS_ATTRSET_LOG_COUNT		3
 #define	XFS_ATTRRM_LOG_COUNT		3

 void xfs_trans_resv_calc(struct xfs_mount *mp, struct xfs_trans_resv *resp);
-uint xfs_allocfree_log_count(struct xfs_mount *mp, uint num_ops);

 #endif	/* __XFS_TRANS_RESV_H__ */
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_trans_space.h package_partclone/src/xfs/libxfs/xfs_trans_space.h
--- package_partclone_orig/src/xfs/libxfs/xfs_trans_space.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_trans_space.h	2019-11-12 13:59:47.932149885 -0300
@@ -21,8 +21,6 @@
 /*
  * Components of space reservations.
  */
-#define XFS_MAX_CONTIG_RMAPS_PER_BLOCK(mp)    \
-		(((mp)->m_rmap_mxr[0]) - ((mp)->m_rmap_mnr[0]))
 #define XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp)    \
 		(((mp)->m_alloc_mxr[0]) - ((mp)->m_alloc_mnr[0]))
 #define	XFS_EXTENTADD_SPACE_RES(mp,w)	(XFS_BM_MAXLEVELS(mp,w) - 1)
@@ -30,13 +28,6 @@
 	(((b + XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp) - 1) / \
 	  XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp)) * \
 	  XFS_EXTENTADD_SPACE_RES(mp,w))
-#define XFS_SWAP_RMAP_SPACE_RES(mp,b,w)\
-	(((b + XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp) - 1) / \
-	  XFS_MAX_CONTIG_EXTENTS_PER_BLOCK(mp)) * \
-	  XFS_EXTENTADD_SPACE_RES(mp,w) + \
-	 ((b + XFS_MAX_CONTIG_RMAPS_PER_BLOCK(mp) - 1) / \
-	  XFS_MAX_CONTIG_RMAPS_PER_BLOCK(mp)) * \
-	  (mp)->m_rmap_maxlevels)
 #define	XFS_DAENTER_1B(mp,w)	\
 	((w) == XFS_DATA_FORK ? (mp)->m_dir_geo->fsbcount : 1)
 #define	XFS_DAENTER_DBS(mp,w)	\
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfs/libxfs/xfs_types.h package_partclone/src/xfs/libxfs/xfs_types.h
--- package_partclone_orig/src/xfs/libxfs/xfs_types.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfs/libxfs/xfs_types.h	2019-11-12 13:59:47.932149885 -0300
@@ -93,7 +93,6 @@ typedef __int64_t	xfs_sfiloff_t;	/* sign
  */
 #define	XFS_DATA_FORK	0
 #define	XFS_ATTR_FORK	1
-#define	XFS_COW_FORK	2

 /*
  * Min numbers of data/attr fork btree root pointers.
@@ -112,8 +111,8 @@ typedef enum {
 } xfs_lookup_t;

 typedef enum {
-	XFS_BTNUM_BNOi, XFS_BTNUM_CNTi, XFS_BTNUM_RMAPi, XFS_BTNUM_BMAPi,
-	XFS_BTNUM_INOi, XFS_BTNUM_FINOi, XFS_BTNUM_REFCi, XFS_BTNUM_MAX
+	XFS_BTNUM_BNOi, XFS_BTNUM_CNTi, XFS_BTNUM_BMAPi, XFS_BTNUM_INOi,
+	XFS_BTNUM_FINOi, XFS_BTNUM_MAX
 } xfs_btnum_t;

 struct xfs_name {
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfsclone.c package_partclone/src/xfsclone.c
--- package_partclone_orig/src/xfsclone.c	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfsclone.c	2019-11-12 13:59:47.933149885 -0300
@@ -15,16 +15,16 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <pthread.h>
-#include "xfs/libxfs.h"
+#include <xfs/libxfs.h>
 #include "partclone.h"
 #include "xfsclone.h"
-#include "progress.h"
+//#include "progress.h"
 #include "fs_common.h"

 #undef crc32
 int	source_fd = -1;
 int     first_residue;
-progress_bar        prog;
+//progress_bar        prog;
 unsigned long long checked;
 unsigned long long total_block;
 int bitmap_done = 0;
@@ -74,7 +74,7 @@ void get_sb(xfs_sb_t *sbp, xfs_off_t off
 }


-static void set_bitmap(unsigned long* bitmap, uint64_t start, int count)
+static void set_bitmap_xfs(unsigned long* bitmap, uint64_t start, int count)
 {
     uint64_t block;

@@ -109,9 +109,9 @@ addtohist(


 	log_mesg(1, 0, 0, fs_opt.debug, "%s: add %8d %8d %8d\n", __FILE__, agno, agbno, len);
-
+
 	start_block = (agno*mp->m_sb.sb_agblocks) + agbno;
-	set_bitmap(xfs_bitmap, start_block, len);
+	set_bitmap_xfs(xfs_bitmap, start_block, len);

 }

@@ -246,7 +246,7 @@ scan_ag(



-static void fs_open(char* device)
+static void fs_open_xfs(char* device)
 {

     int		    open_flags;
@@ -337,15 +337,15 @@ static void fs_open(char* device)

 }

-static void fs_close()
+static void fs_close_xfs()
 {
     libxfs_device_close(xargs.ddev);
-    log_mesg(0, 0, 0, fs_opt.debug, "%s: fs_close\n", __FILE__);
+    log_mesg(0, 0, 0, fs_opt.debug, "%s: fs_close_xfs\n", __FILE__);
 }

-void read_super_blocks(char* device, file_system_info* fs_info)
+void read_super_block_xfs(char* device, file_system_info* fs_info)
 {
-    fs_open(device);
+    fs_open_xfs(device);
     strncpy(fs_info->fs, xfs_MAGIC, FS_MAGIC_SIZE);
     fs_info->block_size  = mp->m_sb.sb_blocksize;
     fs_info->totalblock  = mp->m_sb.sb_dblocks;
@@ -356,43 +356,45 @@ void read_super_blocks(char* device, fil
     log_mesg(1, 0, 0, fs_opt.debug, "%s: free block= %lli\n", __FILE__, mp->m_sb.sb_fdblocks);
     log_mesg(1, 0, 0, fs_opt.debug, "%s: used block= %lli\n", __FILE__, (mp->m_sb.sb_dblocks - mp->m_sb.sb_fdblocks));
     log_mesg(1, 0, 0, fs_opt.debug, "%s: device size= %lli\n", __FILE__, (mp->m_sb.sb_blocksize*mp->m_sb.sb_dblocks));
-    fs_close();
+    fs_close_xfs();

 }

-void read_bitmap(char* device, file_system_info fs_info, unsigned long* bitmap, int pui)
+void read_bitmap_xfs(char* device, file_system_info *fs_info, unsigned long* bitmap, int pui)
 {

     xfs_agnumber_t  agno = 0;
     xfs_agnumber_t  num_ags;

-    int start = 0;
-    int bit_size = 1;
-    int bres;
-    pthread_t prog_bitmap_thread;
+    //int start = 0;
+    //int bit_size = 1;
+    //int bres;
+    //pthread_t prog_bitmap_thread;

     uint64_t bused = 0;
     uint64_t bfree = 0;
     unsigned long long current_block = 0;
-    total_block = fs_info.totalblock;
+    total_block = fs_info->totalblock;

     xfs_bitmap = bitmap;

-    for(current_block = 0; current_block < fs_info.totalblock; current_block++){
-	pc_set_bit(current_block, bitmap, fs_info.totalblock);
+    for(current_block = 0; current_block < fs_info->totalblock; current_block++){
+	pc_set_bit(current_block, bitmap, fs_info->totalblock);
     }
     /// init progress
-    progress_init(&prog, start, fs_info.totalblock, fs_info.totalblock, BITMAP, bit_size);
+    //progress_init(&prog, start, fs_info.totalblock, fs_info.totalblock, BITMAP, bit_size);
     checked = 0;
     /**
      * thread to print progress
      */
+    /*
     bres = pthread_create(&prog_bitmap_thread, NULL, thread_update_bitmap_pui, NULL);
     if(bres){
 	    log_mesg(0, 1, 1, fs_opt.debug, "%s, %i, thread create error\n", __func__, __LINE__);
     }
+    */

-    fs_open(device);
+    fs_open_xfs(device);

     num_ags = mp->m_sb.sb_agcount;

@@ -401,19 +403,20 @@ void read_bitmap(char* device, file_syst
 	/* read in first blocks of the ag */
 	scan_ag(agno);
     }
-    for(current_block = 0; current_block < fs_info.totalblock; current_block++){
-	if(pc_test_bit(current_block, bitmap, fs_info.totalblock))
+    for(current_block = 0; current_block < fs_info->totalblock; current_block++){
+	if(pc_test_bit(current_block, bitmap, fs_info->totalblock))
 	    bused++;
 	else
 	    bfree++;
     }
     log_mesg(0, 0, 0, fs_opt.debug, "%s: bused = %lli, bfree = %lli\n", __FILE__, bused, bfree);

-    fs_close();
+    fs_close_xfs();
     bitmap_done = 1;
-    update_pui(&prog, 1, 1, 1);
+    //update_pui(&prog, 1, 1, 1);

 }
+/*
 void *thread_update_bitmap_pui(void *arg){

     while (bitmap_done == 0) {
@@ -422,4 +425,4 @@ void *thread_update_bitmap_pui(void *arg
     }
     pthread_exit("exit");
 }
-
+*/
diff -rupN --no-dereference -x ABOUT-NLS -x '*.m4' -x m4 -x ar-lib -x autom4te.cache -x compile -x config.guess -x config.h -x '*~' -x config.log -x config.rpath -x config.status -x config.sub -x configure -x depcomp -x install-sh -x libtool -x ltmain.sh -x Makefile -x Makefile.in -x missing -x po -x .deps -x '*.la' -x '*.lo' -x builddefs -x stamp-h1 -x external -x .libs package_partclone_orig/src/xfsclone.h package_partclone/src/xfsclone.h
--- package_partclone_orig/src/xfsclone.h	2018-10-28 10:54:37.000000000 -0300
+++ package_partclone/src/xfsclone.h	2019-11-12 13:59:47.933149885 -0300
@@ -12,3 +12,7 @@
  */

 #undef crc32
+
+extern void read_super_block_xfs(char* device, file_system_info* fs_info);
+extern void read_bitmap_xfs(char* device, file_system_info* fs_info, unsigned long* bitmap, int pui);
+
